/**
 * Modules
 *
 * Copyright (c) 2013 Filatov Dmitry (dfilatov@yandex-team.ru)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * @version 0.1.2
 */

(function(global) {

  var undef,

      DECL_STATES = {
        NOT_RESOLVED: 'NOT_RESOLVED',
        IN_RESOLVING: 'IN_RESOLVING',
        RESOLVED: 'RESOLVED',
      },

      /**
       * Creates a new instance of modular system
       * @returns {Object}
       */
      create = function() {
        var curOptions = {
              trackCircularDependencies: true,
              allowMultipleDeclarations: true,
            },

            modulesStorage = {},
            waitForNextTick = false,
            pendingRequires = [],

            /**
             * Defines module
             * @param {String} name
             * @param {String[]} [deps]
             * @param {Function} declFn
             */
            define = function(name, deps, declFn) {
              if (!declFn) {
                declFn = deps;
                deps = [];
              }

              var module = modulesStorage[name];
              if (!module) {
                module = modulesStorage[name] = {
                  name: name,
                  decl: undef,
                };
              }

              module.decl = {
                name: name,
                prev: module.decl,
                fn: declFn,
                state: DECL_STATES.NOT_RESOLVED,
                deps: deps,
                dependents: [],
                exports: undef,
              };
            },

            /**
             * Requires modules
             * @param {String|String[]} modules
             * @param {Function} cb
             * @param {Function} [errorCb]
             */
            require = function(modules, cb, errorCb) {
              if (typeof modules === 'string') {
                modules = [modules];
              }

              if (!waitForNextTick) {
                waitForNextTick = true;
                nextTick(onNextTick);
              }

              pendingRequires.push({
                deps: modules,
                cb: function(exports, error) {
                  error ?
                      (errorCb || onError)(error) :
                      cb.apply(global, exports);
                },
              });
            },

            /**
             * Returns state of module
             * @param {String} name
             * @returns {String} state, possible values are NOT_DEFINED, NOT_RESOLVED, IN_RESOLVING, RESOLVED
             */
            getState = function(name) {
              var module = modulesStorage[name];
              return module ?
                  DECL_STATES[module.decl.state] :
                  'NOT_DEFINED';
            },

            /**
             * Returns whether the module is defined
             * @param {String} name
             * @returns {Boolean}
             */
            isDefined = function(name) {
              return !!modulesStorage[name];
            },

            /**
             * Sets options
             * @param {Object} options
             */
            setOptions = function(options) {
              for (var name in options) {
                if (options.hasOwnProperty(name)) {
                  curOptions[name] = options[name];
                }
              }
            },

            getStat = function() {
              var res = {},
                  module;

              for (var name in modulesStorage) {
                if (modulesStorage.hasOwnProperty(name)) {
                  module = modulesStorage[name];
                  (res[module.decl.state] ||
                      (res[module.decl.state] = [])).push(name);
                }
              }

              return res;
            },

            onNextTick = function() {
              waitForNextTick = false;
              applyRequires();
            },

            applyRequires = function() {
              var requiresToProcess = pendingRequires,
                  i = 0, require;

              pendingRequires = [];

              while (require = requiresToProcess[i++]) {
                requireDeps(null, require.deps, [], require.cb);
              }
            },

            requireDeps = function(fromDecl, deps, path, cb) {
              var unresolvedDepsCnt = deps.length;
              if (!unresolvedDepsCnt) {
                cb([]);
              }

              var decls = [],
                  onDeclResolved = function(_, error) {
                    if (error) {
                      cb(null, error);
                      return;
                    }

                    if (!--unresolvedDepsCnt) {
                      var exports = [],
                          i = 0, decl;
                      while (decl = decls[i++]) {
                        exports.push(decl.exports);
                      }
                      cb(exports);
                    }
                  },
                  i = 0, len = unresolvedDepsCnt,
                  dep, decl;

              while (i < len) {
                dep = deps[i++];
                if (typeof dep === 'string') {
                  if (!modulesStorage[dep]) {
                    cb(null, buildModuleNotFoundError(dep, fromDecl));
                    return;
                  }

                  decl = modulesStorage[dep].decl;
                }
                else {
                  decl = dep;
                }

                decls.push(decl);

                startDeclResolving(decl, path, onDeclResolved);
              }
            },

            startDeclResolving = function(decl, path, cb) {
              if (decl.state === DECL_STATES.RESOLVED) {
                cb(decl.exports);
                return;
              }
              else if (decl.state === DECL_STATES.IN_RESOLVING) {
                curOptions.trackCircularDependencies &&
                isDependenceCircular(decl, path) ?
                    cb(null, buildCircularDependenceError(decl, path)) :
                    decl.dependents.push(cb);
                return;
              }

              decl.dependents.push(cb);

              if (decl.prev && !curOptions.allowMultipleDeclarations) {
                provideError(decl, buildMultipleDeclarationError(decl));
                return;
              }

              curOptions.trackCircularDependencies &&
              (path = path.slice()).push(decl);

              var isProvided = false,
                  deps = decl.prev ? decl.deps.concat([decl.prev]) : decl.deps;

              decl.state = DECL_STATES.IN_RESOLVING;
              requireDeps(
                  decl,
                  deps,
                  path,
                  function(depDeclsExports, error) {
                    if (error) {
                      provideError(decl, error);
                      return;
                    }

                    depDeclsExports.unshift(function(exports, error) {
                      if (isProvided) {
                        cb(null, buildDeclAreadyProvidedError(decl));
                        return;
                      }

                      isProvided = true;
                      error ?
                          provideError(decl, error) :
                          provideDecl(decl, exports);
                    });

                    decl.fn.apply(
                        {
                          name: decl.name,
                          deps: decl.deps,
                          global: global,
                        },
                        depDeclsExports);
                  });
            },

            provideDecl = function(decl, exports) {
              decl.exports = exports;
              decl.state = DECL_STATES.RESOLVED;

              var i = 0, dependent;
              while (dependent = decl.dependents[i++]) {
                dependent(exports);
              }

              decl.dependents = undef;
            },

            provideError = function(decl, error) {
              decl.state = DECL_STATES.NOT_RESOLVED;

              var i = 0, dependent;
              while (dependent = decl.dependents[i++]) {
                dependent(null, error);
              }

              decl.dependents = [];
            };

        return {
          create: create,
          define: define,
          require: require,
          getState: getState,
          isDefined: isDefined,
          setOptions: setOptions,
          getStat: getStat,
        };
      },

      onError = function(e) {
        nextTick(function() {
          throw e;
        });
      },

      buildModuleNotFoundError = function(name, decl) {
        return Error(decl ?
            'Module "' + decl.name + '": can\'t resolve dependence "' + name +
            '"' :
            'Required module "' + name + '" can\'t be resolved');
      },

      buildCircularDependenceError = function(decl, path) {
        var strPath = [],
            i = 0, pathDecl;
        while (pathDecl = path[i++]) {
          strPath.push(pathDecl.name);
        }
        strPath.push(decl.name);

        return Error('Circular dependence has been detected: "' +
            strPath.join(' -> ') + '"');
      },

      buildDeclAreadyProvidedError = function(decl) {
        return Error('Declaration of module "' + decl.name +
            '" has already been provided');
      },

      buildMultipleDeclarationError = function(decl) {
        return Error('Multiple declarations of module "' + decl.name +
            '" have been detected');
      },

      isDependenceCircular = function(decl, path) {
        var i = 0, pathDecl;
        while (pathDecl = path[i++]) {
          if (decl === pathDecl) {
            return true;
          }
        }
        return false;
      },

      nextTick = (function() {
        var fns = [],
            enqueueFn = function(fn) {
              return fns.push(fn) === 1;
            },
            callFns = function() {
              var fnsToCall = fns, i = 0, len = fns.length;
              fns = [];
              while (i < len) {
                fnsToCall[i++]();
              }
            };

        if (typeof process === 'object' && process.nextTick) { // nodejs
          return function(fn) {
            enqueueFn(fn) && process.nextTick(callFns);
          };
        }

        if (global.setImmediate) { // ie10
          return function(fn) {
            enqueueFn(fn) && global.setImmediate(callFns);
          };
        }

        if (global.postMessage && !global.opera) { // modern browsers
          var isPostMessageAsync = true;
          if (global.attachEvent) {
            var checkAsync = function() {
              isPostMessageAsync = false;
            };
            global.attachEvent('onmessage', checkAsync);
            global.postMessage('__checkAsync', '*');
            global.detachEvent('onmessage', checkAsync);
          }

          if (isPostMessageAsync) {
            var msg = '__modules' + (+new Date()),
                onMessage = function(e) {
                  if (e.data === msg) {
                    e.stopPropagation && e.stopPropagation();
                    callFns();
                  }
                };

            global.addEventListener ?
                global.addEventListener('message', onMessage, true) :
                global.attachEvent('onmessage', onMessage);

            return function(fn) {
              enqueueFn(fn) && global.postMessage(msg, '*');
            };
          }
        }

        var doc = global.document;
        if ('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
          var head = doc.getElementsByTagName('head')[0],
              createScript = function() {
                var script = doc.createElement('script');
                script.onreadystatechange = function() {
                  script.parentNode.removeChild(script);
                  script = script.onreadystatechange = null;
                  callFns();
                };
                head.appendChild(script);
              };

          return function(fn) {
            enqueueFn(fn) && createScript();
          };
        }

        return function(fn) { // old browsers
          enqueueFn(fn) && setTimeout(callFns, 0);
        };
      })();

  if (typeof exports === 'object') {
    module.exports = create();
  }
  else {
    global.modules = create();
  }

})(typeof window !== 'undefined' ? window : global);

/* begin: ../../node_modules/bem-core/common.blocks/i-bem-dom/i-bem-dom.js */
/**
 * @module i-bem-dom
 */

modules.define(
    'i-bem-dom',
    [
      'i-bem',
      'i-bem__internal',
      'i-bem-dom__collection',
      'i-bem-dom__events_type_dom',
      'i-bem-dom__events_type_bem',
      'inherit',
      'identify',
      'objects',
      'functions',
      'jquery',
      'dom',
    ],
    function(
        provide,
        bem,
        bemInternal,
        BemDomCollection,
        domEvents,
        bemEvents,
        inherit,
        identify,
        objects,
        functions,
        $,
        dom) {

      var undef,
          /**
           * Storage for DOM elements by unique key
           * @type Object
           */
          uniqIdToDomElems = {},

          /**
           * Storage for blocks by unique key
           * @type Object
           */
          uniqIdToEntity = {},

          /**
           * Storage for DOM element's parent nodes
           * @type Object
           */
          domNodesToParents = {},

          /**
           * Storage for block parameters
           * @type Object
           */
          domElemToParams = {},

          /**
           * Storage for DOM nodes that are being destructed
           * @type Object
           */
          destructingDomNodes = {},

          entities = bem.entities,

          BEM_CLASS_NAME = 'i-bem',
          BEM_SELECTOR = '.' + BEM_CLASS_NAME,
          BEM_PARAMS_ATTR = 'data-bem',

          NAME_PATTERN = bemInternal.NAME_PATTERN,

          MOD_DELIM = bemInternal.MOD_DELIM,
          ELEM_DELIM = bemInternal.ELEM_DELIM,

          buildModPostfix = bemInternal.buildModPostfix,
          buildClassName = bemInternal.buildClassName,

          reverse = Array.prototype.reverse,
          slice = Array.prototype.slice,

          domEventManagerFactory = new domEvents.EventManagerFactory(
              getEntityCls),
          bemEventManagerFactory = new bemEvents.EventManagerFactory(
              getEntityCls),

          bemDom;

      /**
       * Initializes entities on a DOM element
       * @param {jQuery} domElem DOM element
       * @param {String} uniqInitId ID of the "initialization wave"
       * @param {Object} [dropElemCacheQueue] queue of elems to be droped from cache
       */
      function initEntities(domElem, uniqInitId, dropElemCacheQueue) {
        var domNode = domElem[0],
            params = getParams(domNode),
            entityName,
            splitted,
            blockName,
            elemName;

        for (entityName in params) {
          splitted = entityName.split(ELEM_DELIM);
          blockName = splitted[0];
          elemName = splitted[1];
          elemName &&
          ((dropElemCacheQueue[blockName] ||
              (dropElemCacheQueue[blockName] = {}))[elemName] = true);

          initEntity(
              entityName,
              domElem,
              processParams(params[entityName], entityName, uniqInitId));
        }
      }

      /**
       * Initializes a specific entity on a DOM element, or returns the existing entity if it was already created
       * @param {String} entityName Entity name
       * @param {jQuery} domElem DOM element
       * @param {Object} [params] Initialization parameters
       * @param {Boolean} [ignoreLazyInit=false] Ignore lazy initialization
       * @param {Function} [callback] Handler to call after complete initialization
       */
      function initEntity(
          entityName, domElem, params, ignoreLazyInit, callback) {
        var domNode = domElem[0];

        if (destructingDomNodes[identify(domNode)]) return;

        params || (params = processParams(getEntityParams(domNode, entityName),
            entityName));

        var uniqId = params.uniqId,
            entity = uniqIdToEntity[uniqId];

        if (entity) {
          if (entity.domElem.index(domNode) < 0) {
            entity.domElem = entity.domElem.add(domElem);
            objects.extend(entity.params, params);
          }

          return entity;
        }

        uniqIdToDomElems[uniqId] = uniqIdToDomElems[uniqId] ?
            uniqIdToDomElems[uniqId].add(domElem) :
            domElem;

        var parentDomNode = domNode.parentNode;
        if (!parentDomNode || parentDomNode.nodeType === 11) { // jquery doesn't unique disconnected node
          $.unique(uniqIdToDomElems[uniqId]);
        }

        var entityCls = getEntityCls(entityName);

        entityCls._processInit();

        if (ignoreLazyInit || params.lazyInit === false ||
            !entityCls.lazyInit && !params.lazyInit) {
          ignoreLazyInit && domElem.addClass(BEM_CLASS_NAME); // add css class for preventing memory leaks in further destructing

          entity = new entityCls(uniqIdToDomElems[uniqId], params,
              !!ignoreLazyInit);
          delete uniqIdToDomElems[uniqId];
          callback && callback.apply(entity, slice.call(arguments, 4));
          return entity;
        }
      }

      function getEntityCls(entityName) {
        if (entities[entityName]) return entities[entityName];

        var splitted = entityName.split(ELEM_DELIM);
        return splitted[1] ?
            bemDom.declElem(splitted[0], splitted[1], {}, {lazyInit: true}) :
            bemDom.declBlock(entityName, {}, {lazyInit: true});
      }

      /**
       * Processes and adds necessary entity parameters
       * @param {Object} params Initialization parameters
       * @param {String} entityName Entity name
       * @param {String} [uniqInitId] ID of the "initialization wave"
       */
      function processParams(params, entityName, uniqInitId) {
        params.uniqId ||
        (params.uniqId = (params.id ?
            entityName + '-id-' + params.id :
            identify()) + (uniqInitId || identify()));

        return params;
      }

      /**
       * Helper for searching for a DOM element using a selector inside the context, including the context itself
       * @param {jQuery} ctx Context
       * @param {String} selector CSS selector
       * @param {Boolean} [excludeSelf=false] Exclude context from search
       * @returns {jQuery}
       */
      function findDomElem(ctx, selector, excludeSelf) {
        var res = ctx.find(selector);
        return excludeSelf ?
            res :
            res.add(ctx.filter(selector));
      }

      /**
       * Returns parameters of an entity's DOM element
       * @param {HTMLElement} domNode DOM node
       * @returns {Object}
       */
      function getParams(domNode) {
        var uniqId = identify(domNode);
        return domElemToParams[uniqId] ||
            (domElemToParams[uniqId] = extractParams(domNode));
      }

      /**
       * Returns parameters of an entity extracted from DOM node
       * @param {HTMLElement} domNode DOM node
       * @param {String} entityName
       * @returns {Object}
       */

      function getEntityParams(domNode, entityName) {
        var params = getParams(domNode);
        return params[entityName] || (params[entityName] = {});
      }

      /**
       * Retrieves entity parameters from a DOM element
       * @param {HTMLElement} domNode DOM node
       * @returns {Object}
       */
      function extractParams(domNode) {
        var attrVal = domNode.getAttribute(BEM_PARAMS_ATTR);
        return attrVal ? JSON.parse(attrVal) : {};
      }

      /**
       * Uncouple DOM node from the entity. If this is the last node, then destroys the entity.
       * @param {BemDomEntity} entity entity
       * @param {HTMLElement} domNode DOM node
       */
      function removeDomNodeFromEntity(entity, domNode) {
        if (entity.domElem.length === 1) {
          entity.delMod('js');
          delete uniqIdToEntity[entity._uniqId];
        } else {
          entity.domElem = entity.domElem.not(domNode);
        }
      }

      /**
       * Stores DOM node's parent nodes to the storage
       * @param {jQuery} domElem
       */
      function storeDomNodeParents(domElem) {
        domElem.each(function() {
          domNodesToParents[identify(this)] = this.parentNode;
        });
      }

      /**
       * Clears the cache for elements in context
       * @param {jQuery} ctx
       */
      function dropElemCacheForCtx(ctx, dropElemCacheQueue) {
        ctx.add(ctx.parents()).each(function(_, domNode) {
          var params = domElemToParams[identify(domNode)];

          params && objects.each(params, function(entityParams) {
            var entity = uniqIdToEntity[entityParams.uniqId];
            if (entity) {
              var elemNames = dropElemCacheQueue[entity.__self._blockName];
              elemNames && entity._dropElemCache(Object.keys(elemNames));
            }
          });
        });
      }

      /**
       * Build key for elem
       * @param {Function|String|Object} elem Element class or name or description elem, modName, modVal
       * @returns {Object}
       */
      function buildElemKey(elem) {
        if (typeof elem === 'string') {
          elem = {elem: elem};
        } else if (functions.isFunction(elem)) {
          elem = {elem: elem.getName()};
        } else if (functions.isFunction(elem.elem)) {
          elem.elem = elem.elem.getName();
        }

        return {
          elem: elem.elem,
          mod: buildModPostfix(elem.modName, elem.modVal),
        };
      }

// jscs:disable requireMultipleVarDecl

      /**
       * Returns jQuery collection for provided HTML
       * @param {jQuery|String} html
       * @returns {jQuery}
       */
      function getJqueryCollection(html) {
        return $(
            typeof html === 'string' ? $.parseHTML(html, null, true) : html);
      }

      /**
       * Validates block to be class or specified description
       * @param {*} Block Any argument passed to find*Block as Block
       * @throws {Error} Will throw an error if the Block argument isn't correct
       */
      function validateBlockParam(Block) {
        if (
            typeof Block === 'string' ||
            typeof Block === 'object' && typeof Block.block === 'string'
        ) {
          throw new Error(
              'Block must be a class or description (block, modName, modVal) of the block to find');
        }
      }

      /**
       * Returns base entities for declaration
       * @param {Function} baseCls block|elem class
       * @param {String} entityName entityName
       * @param {Function|Array[Function]} [base] base block|elem + mixes
       * @returns {Array<Function>}
       */
      function getEntityBase(baseCls, entityName, base) {
        base || (base = entities[entityName] || baseCls);

        Array.isArray(base) || (base = [base]);

        if (!base[0].__bemEntity) {
          base = base.slice();
          base.unshift(entities[entityName] || baseCls);
        }

        return base;
      }

      /**
       * @class BemDomEntity
       * @description Base mix for BEM entities that have DOM representation
       */
      var BemDomEntity = inherit(/** @lends BemDomEntity.prototype */{
        /**
         * @constructor
         * @private
         * @param {jQuery} domElem DOM element that the entity is created on
         * @param {Object} params parameters
         * @param {Boolean} [initImmediately=true]
         */
        __constructor: function(domElem, params, initImmediately) {
          /**
           * DOM elements of entity
           * @member {jQuery}
           * @readonly
           */
          this.domElem = domElem;

          /**
           * Cache for elements collections
           * @member {Object}
           * @private
           */
          this._elemsCache = {};

          /**
           * Cache for elements
           * @member {Object}
           * @private
           */
          this._elemCache = {};

          /**
           * References to parent entities which found current entity ever
           * @type {Array}
           * @private
           */
          this._findBackRefs = [];

          uniqIdToEntity[params.uniqId || identify(this)] = this;

          this.__base(null, params, initImmediately);
        },

        /**
         * @abstract
         * @protected
         * @returns {Block}
         */
        _block: function() {
        },

        /**
         * Lazy search for elements nested in a block (caches results)
         * @protected
         * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
         * @returns {BemDomCollection}
         */
        _elems: function(Elem) {
          var key = buildElemKey(Elem),
              elemsCache = this._elemsCache[key.elem];

          if (elemsCache && key.mod in elemsCache)
            return elemsCache[key.mod];

          var res = (elemsCache || (this._elemsCache[key.elem] = {}))[key.mod] =
              this.findMixedElems(Elem).concat(this.findChildElems(Elem));

          res.forEach(function(entity) {
            entity._findBackRefs.push(this);
          }, this);

          return res;
        },

        /**
         * Lazy search for the first element nested in a block (caches results)
         * @protected
         * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
         * @returns {Elem}
         */
        _elem: function(Elem) {
          var key = buildElemKey(Elem),
              elemCache = this._elemCache[key.elem];

          // NOTE: can use this._elemsCache but it's too rare case
          if (elemCache && key.mod in elemCache)
            return elemCache[key.mod];

          var res = (elemCache || (this._elemCache[key.elem] = {}))[key.mod] =
              this.findMixedElem(Elem) || this.findChildElem(Elem);

          res && res._findBackRefs.push(this);

          return res;
        },

        /**
         * Clears the cache for elements
         * @private
         * @param {?...(Function|String|Object)} elems Nested elements names or description elem, modName, modVal
         * @returns {BemDomEntity} this
         */
        _dropElemCache: function(elems) {
          if (!arguments.length) {
            this._elemsCache = {};
            this._elemCache = {};
            return this;
          }

          (Array.isArray(elems) ? elems : slice.call(arguments)).forEach(
              function(elem) {
                var key = buildElemKey(elem);
                if (key.mod) {
                  this._elemsCache[key.elem] &&
                  delete this._elemsCache[key.elem][key.mod];
                  this._elemCache[key.elem] &&
                  delete this._elemCache[key.elem][key.mod];
                } else {
                  delete this._elemsCache[key.elem];
                  delete this._elemCache[key.elem];
                }
              }, this);

          return this;
        },

        /**
         * Finds the first child block
         * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
         * @returns {Block}
         */
        findChildBlock: function(Block) {
          validateBlockParam(Block);

          return this._findEntities('find', Block, true);
        },

        /**
         * Finds child blocks
         * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
         * @returns {BemDomCollection}
         */
        findChildBlocks: function(Block) {
          validateBlockParam(Block);

          return this._findEntities('find', Block);
        },

        /**
         * Finds the first parent block
         * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
         * @returns {Block}
         */
        findParentBlock: function(Block) {
          validateBlockParam(Block);

          return this._findEntities('parents', Block, true);
        },

        /**
         * Finds parent blocks
         * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
         * @returns {BemDomCollection}
         */
        findParentBlocks: function(Block) {
          validateBlockParam(Block);

          return this._findEntities('parents', Block);
        },

        /**
         * Finds first mixed block
         * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
         * @returns {Block}
         */
        findMixedBlock: function(Block) {
          validateBlockParam(Block);

          return this._findEntities('filter', Block, true);
        },

        /**
         * Finds mixed blocks
         * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
         * @returns {BemDomCollection}
         */
        findMixedBlocks: function(Block) {
          validateBlockParam(Block);

          return this._findEntities('filter', Block);
        },

        /**
         * Finds the first child element
         * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
         * @param {Boolean} [strictMode=false]
         * @returns {Elem}
         */
        findChildElem: function(Elem, strictMode) {
          return strictMode ?
              this._filterFindElemResults(this._findEntities('find', Elem)).
                  get(0) :
              this._findEntities('find', Elem, true);
        },

        /**
         * Finds child elements
         * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
         * @param {Boolean} [strictMode=false]
         * @returns {BemDomCollection}
         */
        findChildElems: function(Elem, strictMode) {
          var res = this._findEntities('find', Elem);

          return strictMode ?
              this._filterFindElemResults(res) :
              res;
        },

        /**
         * Finds the first parent element
         * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
         * @param {Boolean} [strictMode=false]
         * @returns {Elem}
         */
        findParentElem: function(Elem, strictMode) {
          return strictMode ?
              this._filterFindElemResults(
                  this._findEntities('parents', Elem))[0] :
              this._findEntities('parents', Elem, true);
        },

        /**
         * Finds parent elements
         * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
         * @param {Boolean} [strictMode=false]
         * @returns {BemDomCollection}
         */
        findParentElems: function(Elem, strictMode) {
          var res = this._findEntities('parents', Elem);
          return strictMode ? this._filterFindElemResults(res) : res;
        },

        /**
         * Finds the first mixed element
         * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
         * @returns {Elem}
         */
        findMixedElem: function(Elem) {
          return this._findEntities('filter', Elem, true);
        },

        /**
         * Finds mixed elements.
         * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
         * @returns {BemDomCollection}
         */
        findMixedElems: function(Elem) {
          return this._findEntities('filter', Elem);
        },

        /**
         * Filters results of findElem helper execution in strict mode
         * @private
         * @param {BemDomCollection} res Elements
         * @returns {BemDomCollection}
         */
        _filterFindElemResults: function(res) {
          var block = this._block();
          return res.filter(function(elem) {
            return elem._block() === block;
          });
        },

        /**
         * Finds entities
         * @private
         * @param {String} select
         * @param {Function|String|Object} entity
         * @param {Boolean} [onlyFirst=false]
         * @returns {*}
         */
        _findEntities: function(select, entity, onlyFirst) {
          var entityName = functions.isFunction(entity) ?
              entity.getEntityName() :
              typeof entity === 'object' ?
                  entity.block ?
                      entity.block.getEntityName() :
                      typeof entity.elem === 'string' ?
                          this.__self._blockName + ELEM_DELIM + entity.elem :
                          entity.elem.getEntityName() :
                  this.__self._blockName + ELEM_DELIM + entity,
              selector = '.' +
                  (typeof entity === 'object' ?
                      buildClassName(
                          entityName,
                          entity.modName,
                          typeof entity.modVal === 'undefined' ?
                              true :
                              entity.modVal) :
                      entityName) +
                  (onlyFirst ? ':first' : ''),
              domElems = this.domElem[select](selector);

          if (onlyFirst) return domElems[0] ?
              initEntity(entityName, domElems.eq(0), undef, true).
                  _setInitedMod() :
              null;

          var res = [],
              uniqIds = {};

          domElems.each(function(i, domElem) {
            var block = initEntity(entityName, $(domElem), undef, true).
                _setInitedMod();
            if (!uniqIds[block._uniqId]) {
              uniqIds[block._uniqId] = true;
              res.push(block);
            }
          });

          return new BemDomCollection(res);
        },

        /**
         * Returns an manager to bind and unbind DOM events for particular context
         * @protected
         * @param {Function|String|Object|Elem|BemDomCollection|document|window} [ctx=this.domElem] context to bind,
         *     can be BEM-entity class, instance, collection of BEM-entities,
         *     element name or description (elem, modName, modVal), document or window
         * @returns {EventManager}
         */
        _domEvents: function(ctx) {
          return domEventManagerFactory.getEventManager(this, ctx,
              this.domElem);
        },

        /**
         * Returns an manager to bind and unbind BEM events for particular context
         * @protected
         * @param {Function|String|BemDomEntity|BemDomCollection|Object} [ctx=this.domElem] context to bind,
         *     can be BEM-entity class, instance, collection of BEM-entities,
         *     element name or description (elem, modName, modVal)
         * @returns {EventManager}
         */
        _events: function(ctx) {
          return bemEventManagerFactory.getEventManager(this, ctx,
              this.domElem);
        },

        /**
         * Executes the BEM entity's event handlers and delegated handlers
         * @protected
         * @param {String|Object|events:Event} e Event name
         * @param {Object} [data] Additional information
         * @returns {BemEntity} this
         */
        _emit: function(e, data) {
          if ((typeof e === 'object' && e.modName === 'js') ||
              this.hasMod('js', 'inited')) {
            bemEvents.emit(this, e, data);
          }

          return this;
        },

        /** @override */
        _extractModVal: function(modName) {
          var domNode = this.domElem[0],
              matches;

          domNode &&
          (matches = domNode.className.match(
              this.__self._buildModValRE(modName)));

          return matches ? matches[2] || true : '';
        },

        /** @override */
        _onSetMod: function(modName, modVal, oldModVal) {
          var _self = this.__self,
              name = _self.getName();

          this._findBackRefs.forEach(function(ref) {
            oldModVal === '' || ref._dropElemCache(
                {elem: name, modName: modName, modVal: oldModVal});
            ref._dropElemCache(modVal === '' ?
                name :
                {elem: name, modName: modName, modVal: modVal});
          });

          this.__base.apply(this, arguments);

          if (modName !== 'js' || modVal !== '') {
            var classNamePrefix = _self._buildModClassNamePrefix(modName),
                classNameRE = _self._buildModValRE(modName),
                needDel = modVal === '';

            this.domElem.each(function() {
              var className = this.className,
                  modClassName = classNamePrefix;

              modVal !== true && (modClassName += MOD_DELIM + modVal);

              (oldModVal === true ?
                  classNameRE.test(className) :
                  (' ' + className).indexOf(' ' + classNamePrefix + MOD_DELIM) >
                  -1) ?
                  this.className = className.replace(
                      classNameRE,
                      (needDel ? '' : '$1' + modClassName)) :
                  needDel || $(this).addClass(modClassName);
            });
          }
        },

        /** @override */
        _afterSetMod: function(modName, modVal, oldModVal) {
          var eventData = {
            modName: modName,
            modVal: modVal,
            oldModVal: oldModVal,
          };
          this._emit({modName: modName, modVal: '*'}, eventData).
              _emit({modName: modName, modVal: modVal}, eventData);
        },

        /**
         * Checks whether an entity is in the entity
         * @param {BemDomEntity} entity entity
         * @returns {Boolean}
         */
        containsEntity: function(entity) {
          return dom.contains(this.domElem, entity.domElem);
        },

      }, /** @lends BemDomEntity */{
        /** @override */
        create: function() {
          throw Error(
              'bemDom entities can not be created otherwise than from DOM');
        },

        /** @override */
        _processInit: function(heedInit) {
          /* jshint eqeqeq: false */
          if (this.onInit && this._inited == heedInit) {
            this.__base(heedInit);

            this.onInit();

            var name = this.getName(),
                origOnInit = this.onInit;

            // allow future calls of init only in case of inheritance in other block
            this.init = function() {
              this.getName() === name && origOnInit.apply(this, arguments);
            };
          }
        },

        /**
         * Returns an manager to bind and unbind events for particular context
         * @protected
         * @param {Function|String|Object} [ctx] context to bind,
         *     can be BEM-entity class, instance, element name or description (elem, modName, modVal)
         * @returns {EventManager}
         */
        _domEvents: function(ctx) {
          return domEventManagerFactory.getEventManager(this, ctx,
              bemDom.scope);
        },

        /**
         * Returns an manager to bind and unbind BEM events for particular context
         * @protected
         * @param {Function|String|Object} [ctx] context to bind,
         *     can be BEM-entity class, instance, element name or description (block or elem, modName, modVal)
         * @returns {EventManager}
         */
        _events: function(ctx) {
          return bemEventManagerFactory.getEventManager(this, ctx,
              bemDom.scope);
        },

        /**
         * Builds a prefix for the CSS class of a DOM element of the entity, based on modifier name
         * @private
         * @param {String} modName Modifier name
         * @returns {String}
         */
        _buildModClassNamePrefix: function(modName) {
          return this.getEntityName() + MOD_DELIM + modName;
        },

        /**
         * Builds a regular expression for extracting modifier values from a DOM element of an entity
         * @private
         * @param {String} modName Modifier name
         * @returns {RegExp}
         */
        _buildModValRE: function(modName) {
          return new RegExp(
              '(\\s|^)' +
              this._buildModClassNamePrefix(modName) +
              '(?:' + MOD_DELIM + '(' + NAME_PATTERN + '))?(?=\\s|$)');
        },

        /**
         * Builds a CSS class name corresponding to the entity and modifier
         * @protected
         * @param {String} [modName] Modifier name
         * @param {String} [modVal] Modifier value
         * @returns {String}
         */
        _buildClassName: function(modName, modVal) {
          return buildClassName(this.getEntityName(), modName, modVal);
        },

        /**
         * Builds a CSS selector corresponding to an entity and modifier
         * @protected
         * @param {String} [modName] Modifier name
         * @param {String} [modVal] Modifier value
         * @returns {String}
         */
        _buildSelector: function(modName, modVal) {
          return '.' + this._buildClassName(modName, modVal);
        },
      });

      /**
       * @class Block
       * @description Base class for creating BEM blocks that have DOM representation
       * @augments i-bem:Block
       * @exports i-bem-dom:Block
       */
      var Block = inherit([bem.Block, BemDomEntity],
          /** @lends Block.prototype */{
            /** @override */
            _block: function() {
              return this;
            },
          });

      /**
       * @class Elem
       * @description Base class for creating BEM elements that have DOM representation
       * @augments i-bem:Elem
       * @exports i-bem-dom:Elem
       */
      var Elem = inherit([bem.Elem, BemDomEntity], /** @lends Elem.prototype */{
        /** @override */
        _block: function() {
          return this._blockInstance ||
              (this._blockInstance = this.findParentBlock(
                  getEntityCls(this.__self._blockName)));
        },
      });

      /**
       * Returns a block on a DOM element and initializes it if necessary
       * @param {Function} BemDomEntity entity
       * @param {Object} [params] entity parameters
       * @returns {BemDomEntity|null}
       */
      $.fn.bem = function(BemDomEntity, params) {
        var entity = initEntity(BemDomEntity.getEntityName(), this, params,
            true);
        return entity ? entity._setInitedMod() : null;
      };

      $(function() {

        bemDom = /** @exports */{
          /**
           * Scope
           * @type jQuery
           */
          scope: $('body'),

          /**
           * Document shortcut
           * @type jQuery
           */
          doc: $(document),

          /**
           * Window shortcut
           * @type jQuery
           */
          win: $(window),

          /**
           * Base bemDom block
           * @type Function
           */
          Block: Block,

          /**
           * Base bemDom element
           * @type Function
           */
          Elem: Elem,

          /**
           * @param {*} entity
           * @returns {Boolean}
           */
          isEntity: function(entity) {
            return entity instanceof Block || entity instanceof Elem;
          },

          /**
           * Declares DOM-based block and creates block class
           * @param {String|Function} blockName Block name or block class
           * @param {Function|Array[Function]} [base] base block + mixes
           * @param {Object} [props] Methods
           * @param {Object} [staticProps] Static methods
           * @returns {Function} Block class
           */
          declBlock: function(blockName, base, props, staticProps) {
            if (!base || (typeof base === 'object' && !Array.isArray(base))) {
              staticProps = props;
              props = base;
              base = typeof blockName === 'string' ?
                  entities[blockName] || Block :
                  blockName;
            }

            base = getEntityBase(Block, blockName, base);

            return bem.declBlock(blockName, base, props, staticProps);
          },

          /**
           * Declares elem and creates elem class
           * @param {String} blockName Block name
           * @param {String} elemName Elem name
           * @param {Function|Array[Function]} [base] base elem + mixes
           * @param {Object} [props] Methods
           * @param {Object} [staticProps] Static methods
           * @returns {Function} Elem class
           */
          declElem: function(blockName, elemName, base, props, staticProps) {
            var entityName = blockName + ELEM_DELIM + elemName;

            if (!base || (typeof base === 'object' && !Array.isArray(base))) {
              staticProps = props;
              props = base;
              base = entities[entityName] || Elem;
            }

            base = getEntityBase(Elem, entityName, base);

            return bem.declElem(blockName, elemName, base, props, staticProps);
          },

          declMixin: bem.declMixin,

          /**
           * Initializes blocks on a fragment of the DOM tree
           * @param {jQuery|String} [ctx=scope] Root DOM node
           * @returns {jQuery} ctx Initialization context
           */
          init: function(ctx) {
            ctx = typeof ctx === 'string' ?
                $(ctx) :
                ctx || bemDom.scope;

            var dropElemCacheQueue = {},
                uniqInitId = identify();

            // NOTE: we find only js-entities, so cahced elems without js can't be dropped from cache
            findDomElem(ctx, BEM_SELECTOR).each(function() {
              initEntities($(this), uniqInitId, dropElemCacheQueue);
            });

            bem._runInitFns();

            dropElemCacheForCtx(ctx, dropElemCacheQueue);

            return ctx;
          },

          /**
           * @param {jQuery} ctx Root DOM node
           * @param {Boolean} [excludeSelf=false] Exclude the main domElem
           * @param {Boolean} [destructDom=false] Remove DOM node during destruction
           * @private
           */
          _destruct: function(ctx, excludeSelf, destructDom) {
            var _ctx,
                currentDestructingDomNodes = [];

            storeDomNodeParents(_ctx = excludeSelf ? ctx.children() : ctx);

            reverse.call(findDomElem(_ctx, BEM_SELECTOR)).
                each(function(_, domNode) {
                  var params = getParams(domNode),
                      domNodeId = identify(domNode);

                  destructingDomNodes[domNodeId] = true;
                  currentDestructingDomNodes.push(domNodeId);

                  objects.each(params, function(entityParams) {
                    if (entityParams.uniqId) {
                      var entity = uniqIdToEntity[entityParams.uniqId];
                      entity ?
                          removeDomNodeFromEntity(entity, domNode) :
                          delete uniqIdToDomElems[entityParams.uniqId];
                    }
                  });
                  delete domElemToParams[identify(domNode)];
                });

            // NOTE: it was moved here as jquery events aren't triggered on detached DOM elements
            destructDom &&
            (excludeSelf ? ctx.empty() : ctx.remove());

            // flush parent nodes storage that has been filled above
            domNodesToParents = {};

            currentDestructingDomNodes.forEach(function(domNodeId) {
              delete destructingDomNodes[domNodeId];
            });
          },

          /**
           * Destroys blocks on a fragment of the DOM tree
           * @param {jQuery} ctx Root DOM node
           * @param {Boolean} [excludeSelf=false] Exclude the main domElem
           */
          destruct: function(ctx, excludeSelf) {
            this._destruct(ctx, excludeSelf, true);
          },

          /**
           * Detaches blocks on a fragment of the DOM tree without DOM tree destruction
           * @param {jQuery} ctx Root DOM node
           * @param {Boolean} [excludeSelf=false] Exclude the main domElem
           */
          detach: function(ctx, excludeSelf) {
            this._destruct(ctx, excludeSelf);
          },

          /**
           * Replaces a fragment of the DOM tree inside the context, destroying old blocks and intializing new ones
           * @param {jQuery} ctx Root DOM node
           * @param {jQuery|String} content New content
           * @returns {jQuery} Updated root DOM node
           */
          update: function(ctx, content) {
            this.destruct(ctx, true);
            return this.init(ctx.html(content));
          },

          /**
           * Changes a fragment of the DOM tree including the context and initializes blocks.
           * @param {jQuery} ctx Root DOM node
           * @param {jQuery|String} content Content to be added
           * @returns {jQuery} New content
           */
          replace: function(ctx, content) {
            var prev = ctx.prev(),
                parent = ctx.parent();

            content = getJqueryCollection(content);

            this.destruct(ctx);

            return this.init(prev.length ?
                content.insertAfter(prev) :
                content.prependTo(parent));
          },

          /**
           * Adds a fragment of the DOM tree at the end of the context and initializes blocks
           * @param {jQuery} ctx Root DOM node
           * @param {jQuery|String} content Content to be added
           * @returns {jQuery} New content
           */
          append: function(ctx, content) {
            return this.init(getJqueryCollection(content).appendTo(ctx));
          },

          /**
           * Adds a fragment of the DOM tree at the beginning of the context and initializes blocks
           * @param {jQuery} ctx Root DOM node
           * @param {jQuery|String} content Content to be added
           * @returns {jQuery} New content
           */
          prepend: function(ctx, content) {
            return this.init(getJqueryCollection(content).prependTo(ctx));
          },

          /**
           * Adds a fragment of the DOM tree before the context and initializes blocks
           * @param {jQuery} ctx Contextual DOM node
           * @param {jQuery|String} content Content to be added
           * @returns {jQuery} New content
           */
          before: function(ctx, content) {
            return this.init(getJqueryCollection(content).insertBefore(ctx));
          },

          /**
           * Adds a fragment of the DOM tree after the context and initializes blocks
           * @param {jQuery} ctx Contextual DOM node
           * @param {jQuery|String} content Content to be added
           * @returns {jQuery} New content
           */
          after: function(ctx, content) {
            return this.init(getJqueryCollection(content).insertAfter(ctx));
          },
        };

        provide(bemDom);

      });

    });

(function() {

  var origDefine = modules.define,
      storedDeps = []; // NOTE: see https://github.com/bem/bem-core/issues/1446

  modules.define = function(name, deps, decl) {
    origDefine.apply(modules, arguments);

    if (name !== 'i-bem-dom__init' && arguments.length > 2 &&
        ~deps.indexOf('i-bem-dom')) {
      storedDeps.push(name);
      storedDeps.length === 1 &&
      modules.define('i-bem-dom__init', storedDeps, function(provide) {
        provide(arguments[arguments.length - 1]);
        storedDeps = [];
      });
    }
  };

})();

/* end: ../../node_modules/bem-core/common.blocks/i-bem-dom/i-bem-dom.js */
/* begin: ../../node_modules/bem-core/common.blocks/inherit/inherit.vanilla.js */
/**
 * @module inherit
 * @version 2.2.6
 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
 * @description This module provides some syntax sugar for "class" declarations, constructors, mixins, "super" calls and static members.
 */

(function(global) {

  var noop = function() {
      },
      hasOwnProperty = Object.prototype.hasOwnProperty,
      objCreate = Object.create || function(ptp) {
        var inheritance = function() {
        };
        inheritance.prototype = ptp;
        return new inheritance();
      },
      objKeys = Object.keys || function(obj) {
        var res = [];
        for (var i in obj) {
          hasOwnProperty.call(obj, i) && res.push(i);
        }
        return res;
      },
      extend = function(o1, o2) {
        for (var i in o2) {
          hasOwnProperty.call(o2, i) && (o1[i] = o2[i]);
        }

        return o1;
      },
      toStr = Object.prototype.toString,
      isArray = Array.isArray || function(obj) {
        return toStr.call(obj) === '[object Array]';
      },
      isFunction = function(obj) {
        return toStr.call(obj) === '[object Function]';
      },
      needCheckProps = true,
      testPropObj = {toString: ''};

  for (var i in testPropObj) { // It's a pity ie hasn't toString, valueOf in for
    testPropObj.hasOwnProperty(i) && (needCheckProps = false);
  }

  var specProps = needCheckProps ? ['toString', 'valueOf'] : null;

  function getPropList(obj) {
    var res = objKeys(obj);
    if (needCheckProps) {
      var specProp, i = 0;
      while (specProp = specProps[i++]) {
        obj.hasOwnProperty(specProp) && res.push(specProp);
      }
    }

    return res;
  }

  function override(base, res, add) {
    var addList = getPropList(add),
        j = 0, len = addList.length,
        name, prop;
    while (j < len) {
      if ((name = addList[j++]) === '__self') {
        continue;
      }
      prop = add[name];
      if (isFunction(prop) &&
          (!prop.prototype || !prop.prototype.__self) && // check to prevent wrapping of "class" functions
          (prop.toString().indexOf('.__base') > -1)) {
        res[name] = (function(name, prop) {
          var baseMethod = base[name] ?
              base[name] :
              name === '__constructor' ? // case of inheritance from plain function
                  res.__self.__parent :
                  noop,
              result = function() {
                var baseSaved = this.__base;

                this.__base = result.__base;
                var res = prop.apply(this, arguments);
                this.__base = baseSaved;

                return res;
              };
          result.__base = baseMethod;

          return result;
        })(name, prop);
      } else {
        res[name] = prop;
      }
    }
  }

  function applyMixins(mixins, res) {
    var i = 1, mixin;
    while (mixin = mixins[i++]) {
      res ?
          isFunction(mixin) ?
              inherit.self(res, mixin.prototype, mixin) :
              inherit.self(res, mixin) :
          res = isFunction(mixin) ?
              inherit(mixins[0], mixin.prototype, mixin) :
              inherit(mixins[0], mixin);
    }
    return res || mixins[0];
  }

  /**
   * Creates class
   * @exports
   * @param {Function|Array} [baseClass|baseClassAndMixins] class (or class and mixins) to inherit from
   * @param {Object} prototypeFields
   * @param {Object} [staticFields]
   * @returns {Function} class
   */
  function inherit() {
    var args = arguments,
        withMixins = isArray(args[0]),
        hasBase = withMixins || isFunction(args[0]),
        base = hasBase ? withMixins ? applyMixins(args[0]) : args[0] : noop,
        props = args[hasBase ? 1 : 0] || {},
        staticProps = args[hasBase ? 2 : 1],
        res = props.__constructor ||
        (hasBase && base.prototype && base.prototype.__constructor) ?
            function() {
              return this.__constructor.apply(this, arguments);
            } :
            hasBase ?
                function() {
                  return base.apply(this, arguments);
                } :
                function() {
                };

    if (!hasBase) {
      res.prototype = props;
      res.prototype.__self = res.prototype.constructor = res;
      return extend(res, staticProps);
    }

    extend(res, base);

    res.__parent = base;

    var basePtp = base.prototype,
        resPtp = res.prototype = objCreate(basePtp);

    resPtp.__self = resPtp.constructor = res;

    props && override(basePtp, resPtp, props);
    staticProps && override(base, res, staticProps);

    return res;
  }

  inherit.self = function() {
    var args = arguments,
        withMixins = isArray(args[0]),
        base = withMixins ? applyMixins(args[0], args[0][0]) : args[0],
        props = args[1],
        staticProps = args[2],
        basePtp = base.prototype;

    props && override(basePtp, basePtp, props);
    staticProps && override(base, base, staticProps);

    return base;
  };

  var defineAsGlobal = true;
  /* istanbul ignore next */
  if (typeof exports === 'object') {
    module.exports = inherit;
    defineAsGlobal = false;
  }
  /* istanbul ignore next */
  if (typeof modules === 'object' && typeof modules.define === 'function') {
    modules.define('inherit', function(provide) {
      provide(inherit);
    });
    defineAsGlobal = false;
  }
  /* istanbul ignore next */
  if (typeof define === 'function') {
    define(function(require, exports, module) {
      module.exports = inherit;
    });
    defineAsGlobal = false;
  }
  /* istanbul ignore next */
  defineAsGlobal && (global.inherit = inherit);

})(this);

/* end: ../../node_modules/bem-core/common.blocks/inherit/inherit.vanilla.js */
/* begin: ../../node_modules/bem-core/common.blocks/jquery/jquery.js */
/**
 * @module jquery
 * @description Provide jQuery (load if it does not exist).
 */

modules.define(
    'jquery',
    ['loader_type_js', 'jquery__config'],
    function(provide, loader, cfg) {

      /* global jQuery */

      function doProvide(preserveGlobal) {
        /**
         * @exports
         * @type Function
         */
        provide(preserveGlobal ? jQuery : jQuery.noConflict(true));
      }

      typeof jQuery !== 'undefined' ?
          doProvide(true) :
          loader(cfg.url, doProvide);
    });

/* end: ../../node_modules/bem-core/common.blocks/jquery/jquery.js */
/* begin: ../../node_modules/bem-core/common.blocks/jquery/__config/jquery__config.js */
/**
 * @module jquery__config
 * @description Configuration for jQuery
 */

modules.define('jquery__config', function(provide) {

  provide(/** @exports */{
    /**
     * URL for loading jQuery if it does not exist
     * @type {String}
     */
    url: 'https://yastatic.net/jquery/3.2.1/jquery.min.js',
  });

});

/* end: ../../node_modules/bem-core/common.blocks/jquery/__config/jquery__config.js */
/* begin: ../../node_modules/bem-core/desktop.blocks/jquery/__config/jquery__config.js */
/**
 * @module jquery__config
 * @description Configuration for jQuery
 */

modules.define(
    'jquery__config',
    ['ua', 'objects'],
    function(provide, ua, objects, base) {

      provide(
          ua.msie && parseInt(ua.version, 10) < 9 ?
              objects.extend(
                  base,
                  {
                    url: 'https://yastatic.net/jquery/1.12.4/jquery.min.js',
                  }) :
              base);

    });

/* end: ../../node_modules/bem-core/desktop.blocks/jquery/__config/jquery__config.js */
/* begin: ../../node_modules/bem-core/desktop.blocks/ua/ua.js */
/**
 * @module ua
 * @description Detect some user agent features (works like jQuery.browser in jQuery 1.8)
 * @see http://code.jquery.com/jquery-migrate-1.1.1.js
 */

modules.define('ua', function(provide) {

  var ua = navigator.userAgent.toLowerCase(),
      match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
          /(webkit)[ \/]([\w.]+)/.exec(ua) ||
          /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
          /(msie) ([\w.]+)/.exec(ua) ||
          ua.indexOf('compatible') < 0 &&
          /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
          [],
      matched = {
        browser: match[1] || '',
        version: match[2] || '0',
      },
      browser = {};

  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
  }

  if (browser.chrome) {
    browser.webkit = true;
  } else if (browser.webkit) {
    browser.safari = true;
  }

  /**
   * @exports
   * @type Object
   */
  provide(browser);

});

/* end: ../../node_modules/bem-core/desktop.blocks/ua/ua.js */
/* begin: ../../node_modules/bem-core/common.blocks/objects/objects.vanilla.js */
/**
 * @module objects
 * @description A set of helpers to work with JavaScript objects
 */

modules.define('objects', function(provide) {

  var hasOwnProp = Object.prototype.hasOwnProperty;

  provide(/** @exports */{
    /**
     * Extends a given target by
     * @param {Object} target object to extend
     * @param {Object} source
     * @returns {Object}
     */
    extend: function(target, source) {
      (typeof target !== 'object' || target === null) && (target = {});

      for (var i = 1, len = arguments.length; i < len; i++) {
        var obj = arguments[i];
        if (obj) {
          for (var key in obj) {
            hasOwnProp.call(obj, key) && (target[key] = obj[key]);
          }
        }
      }

      return target;
    },

    /**
     * Check whether a given object is empty (contains no enumerable properties)
     * @param {Object} obj
     * @returns {Boolean}
     */
    isEmpty: function(obj) {
      for (var key in obj) {
        if (hasOwnProp.call(obj, key)) {
          return false;
        }
      }

      return true;
    },

    /**
     * Generic iterator function over object
     * @param {Object} obj object to iterate
     * @param {Function} fn callback
     * @param {Object} [ctx] callbacks's context
     */
    each: function(obj, fn, ctx) {
      for (var key in obj) {
        if (hasOwnProp.call(obj, key)) {
          ctx ? fn.call(ctx, obj[key], key) : fn(obj[key], key);
        }
      }
    },
  });

});

/* end: ../../node_modules/bem-core/common.blocks/objects/objects.vanilla.js */
/* begin: ../../node_modules/bem-core/common.blocks/functions/functions.vanilla.js */
/**
 * @module functions
 * @description A set of helpers to work with JavaScript functions
 */

modules.define('functions', function(provide) {

  var toStr = Object.prototype.toString;

  provide(/** @exports */{
    /**
     * Checks whether a given object is function
     * @param {*} obj
     * @returns {Boolean}
     */
    isFunction: function(obj) {
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === 'function' && typeof obj.nodeType !== 'number';
    },

    /**
     * Empty function
     */
    noop: function() {
    },
  });

});

/* end: ../../node_modules/bem-core/common.blocks/functions/functions.vanilla.js */
/* begin: ../../node_modules/bem-core/common.blocks/dom/dom.js */
/**
 * @module dom
 * @description some DOM utils
 */

modules.define('dom', ['jquery'], function(provide, $) {

  var EDITABLE_INPUT_TYPES = {
    'datetime-local': true,
    date: true,
    month: true,
    number: true,
    password: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true,
  };

  provide(/** @exports */{
    /**
     * Checks whether a DOM elem is in a context
     * @param {jQuery} ctx DOM elem where check is being performed
     * @param {jQuery} domElem DOM elem to check
     * @returns {Boolean}
     */
    contains: function(ctx, domElem) {
      var res = false;

      domElem.each(function() {
        var domNode = this;
        do {
          if (~ctx.index(domNode)) return !(res = true);
        } while (domNode = domNode.parentNode);

        return res;
      });

      return res;
    },

    /**
     * Returns current focused DOM elem in document
     * @returns {jQuery}
     */
    getFocused: function() {
      // "Error: Unspecified error." in iframe in IE9
      try {
        return $(document.activeElement);
      } catch (e) {
      }
    },

    /**
     * Checks whether a DOM element contains focus
     * @param {jQuery} domElem
     * @returns {Boolean}
     */
    containsFocus: function(domElem) {
      return this.contains(domElem, this.getFocused());
    },

    /**
     * Checks whether a browser currently can set focus on DOM elem
     * @param {jQuery} domElem
     * @returns {Boolean}
     */
    isFocusable: function(domElem) {
      var domNode = domElem[0];

      if (!domNode) return false;
      if (domNode.hasAttribute('tabindex')) return true;

      switch (domNode.tagName.toLowerCase()) {
        case 'iframe':
          return true;

        case 'input':
        case 'button':
        case 'textarea':
        case 'select':
          return !domNode.disabled;

        case 'a':
          return !!domNode.href;
      }

      return false;
    },

    /**
     * Checks whether a domElem is intended to edit text
     * @param {jQuery} domElem
     * @returns {Boolean}
     */
    isEditable: function(domElem) {
      var domNode = domElem[0];

      if (!domNode) return false;

      switch (domNode.tagName.toLowerCase()) {
        case 'input':
          return EDITABLE_INPUT_TYPES.hasOwnProperty(domNode.type) &&
              !domNode.disabled && !domNode.readOnly;

        case 'textarea':
          return !domNode.disabled && !domNode.readOnly;

        default:
          return domNode.contentEditable === 'true';
      }
    },
  });

});

/* end: ../../node_modules/bem-core/common.blocks/dom/dom.js */
/* begin: ../../node_modules/bem-core/common.blocks/i-bem-dom/__init/i-bem-dom__init.js */
/**
 * @module i-bem-dom__init
 */

modules.define('i-bem-dom__init', ['i-bem-dom'], function(provide, bemDom) {

  provide(
      /**
       * Initializes blocks on a fragment of the DOM tree
       * @exports
       * @param {jQuery} [ctx=scope] Root DOM node
       * @returns {jQuery} ctx Initialization context
       */
      function(ctx) {
        return bemDom.init(ctx);
      });
});

/* end: ../../node_modules/bem-core/common.blocks/i-bem-dom/__init/i-bem-dom__init.js */
/* begin: ../../node_modules/bem-core/common.blocks/i-bem/i-bem.vanilla.js */
/**
 * @module i-bem
 */

modules.define(
    'i-bem',
    [
      'i-bem__internal',
      'inherit',
      'identify',
      'next-tick',
      'objects',
      'functions',
    ],
    function(
        provide,
        bemInternal,
        inherit,
        identify,
        nextTick,
        objects,
        functions) {

      var undef,

          ELEM_DELIM = bemInternal.ELEM_DELIM,

          /**
           * Storage for block init functions
           * @private
           * @type Array
           */
          initFns = [],

          /**
           * Storage for block declarations (hash by block name)
           * @private
           * @type Object
           */
          entities = {};

      /**
       * Builds the name of the handler method for setting a modifier
       * @param {String} prefix
       * @param {String} modName Modifier name
       * @param {String} modVal Modifier value
       * @returns {String}
       */
      function buildModFnName(prefix, modName, modVal) {
        return '__' + prefix +
            '__mod' +
            (modName ? '_' + modName : '') +
            (modVal ? '_' + modVal : '');
      }

      /**
       * Builds the function for the handler method for setting a modifier
       * for special syntax
       * @param {String} modVal Declared modifier value
       * @param {Function} curModFn Declared modifier handler
       * @param {Function} [prevModFn] Previous handler
       * @param {Function} [condition] Condition function
       * (called with declared, set and previous modifier values)
       * @returns {Function}
       */
      function buildSpecialModFn(modVal, curModFn, prevModFn, condition) {
        return prevModFn || condition ?
            function(_modName, _modVal, _prevModVal) {
              var res1, res2;
              prevModFn &&
              (res1 = prevModFn.apply(this, arguments) === false);
              (condition ? condition(modVal, _modVal, _prevModVal) : true) &&
              (res2 = curModFn.apply(this, arguments) === false);
              if (res1 || res2) return false;
            } :
            curModFn;
      }

      var specialModConditions = {
        '!': function(modVal, _modVal, _prevModVal) {
          return _modVal !== modVal;
        },
        '~': function(modVal, _modVal, _prevModVal) {
          return _prevModVal === modVal;
        },
      };

      /**
       * Transforms a hash of modifier handlers to methods
       * @param {String} prefix
       * @param {Object} modFns
       * @param {Object} props
       */
      function modFnsToProps(prefix, modFns, props) {
        if (functions.isFunction(modFns)) {
          props[buildModFnName(prefix, '*', '*')] = modFns;
        } else {
          var modName, modVal, modFn;
          for (modName in modFns) {
            modFn = modFns[modName];
            if (functions.isFunction(modFn)) {
              props[buildModFnName(prefix, modName, '*')] = modFn;
            } else {
              var starModFnName = buildModFnName(prefix, modName, '*');
              for (modVal in modFn) {
                var curModFn = modFn[modVal],
                    modValPrefix = modVal[0];

                if (modValPrefix === '!' || modValPrefix === '~' || modVal ===
                    '*') {
                  modVal === '*' || (modVal = modVal.substr(1));
                  props[starModFnName] = buildSpecialModFn(
                      modVal,
                      curModFn,
                      props[starModFnName],
                      specialModConditions[modValPrefix]);
                } else {
                  props[buildModFnName(prefix, modName, modVal)] = curModFn;
                }
              }
            }
          }
        }
      }

      function buildCheckMod(modName, modVal) {
        return modVal ?
            Array.isArray(modVal) ?
                function(block) {
                  var i = 0, len = modVal.length;
                  while (i < len)
                    if (checkMod(block, modName, modVal[i++]))
                      return true;
                  return false;
                } :
                function(block) {
                  return checkMod(block, modName, modVal);
                } :
            function(block) {
              return checkMod(block, modName, true);
            };
      }

      function checkMod(block, modName, modVal) {
        var prevModVal = block._processingMods[modName];

        // check if a block has either current or previous modifier value equal to passed modVal
        return modVal === '*' ?
            /* jshint eqnull: true */
            block.hasMod(modName) || prevModVal != null :
            block.hasMod(modName, modVal) || prevModVal === modVal;
      }

      function convertModHandlersToMethods(props) {
        if (props.beforeSetMod) {
          modFnsToProps('before', props.beforeSetMod, props);
          delete props.beforeSetMod;
        }

        if (props.onSetMod) {
          modFnsToProps('after', props.onSetMod, props);
          delete props.onSetMod;
        }
      }

      function declEntity(baseCls, entityName, base, props, staticProps) {
        base || (base = entities[entityName] || baseCls);

        Array.isArray(base) || (base = [base]);

        if (!base[0].__bemEntity) {
          base = base.slice();
          base.unshift(entities[entityName] || baseCls);
        }

        props && convertModHandlersToMethods(props);

        var entityCls;

        entityName === base[0].getEntityName() ?
            // makes a new "init" if the old one was already executed
            (entityCls = inherit.self(base, props, staticProps))._processInit(
                true) :
            (entityCls = entities[entityName] = inherit(base, props,
                staticProps));

        return entityCls;
      }

// jscs:disable requireMultipleVarDecl

      /**
       * @class BemEntity
       * @description Base block for creating BEM blocks
       */
      var BemEntity = inherit(/** @lends BemEntity.prototype */ {
        /**
         * @constructor
         * @private
         * @param {Object} mods BemEntity modifiers
         * @param {Object} params BemEntity parameters
         * @param {Boolean} [initImmediately=true]
         */
        __constructor: function(mods, params, initImmediately) {
          /**
           * Cache of modifiers
           * @member {Object}
           * @private
           */
          this._modCache = mods || {};

          /**
           * Current modifiers in the stack
           * @member {Object}
           * @private
           */
          this._processingMods = {};

          /**
           * BemEntity parameters, taking into account the defaults
           * @member {Object}
           * @readonly
           */
          this.params = objects.extend(this._getDefaultParams(), params);

          /**
           * @member {String} Unique entity ID
           * @private
           */
          this._uniqId = this.params.uniqId || identify(this);

          initImmediately !== false ?
              this._setInitedMod() :
              initFns.push(this._setInitedMod, this);
        },

        /**
         * Initializes a BEM entity
         * @private
         */
        _setInitedMod: function() {
          return this.setMod('js', 'inited');
        },

        /**
         * Checks whether a BEM entity has a modifier
         * @param {String} modName Modifier name
         * @param {String|Boolean} [modVal] Modifier value. If not of type String or Boolean, it is casted to String
         * @returns {Boolean}
         */
        hasMod: function(modName, modVal) {
          var typeModVal = typeof modVal;
          typeModVal === 'undefined' || typeModVal === 'boolean' ||
          (modVal = modVal.toString());

          var res = this.getMod(modName) === (modVal || '');
          return arguments.length === 1 ? !res : res;
        },

        /**
         * Returns the value of the modifier of the BEM entity
         * @param {String} modName Modifier name
         * @returns {String} Modifier value
         */
        getMod: function(modName) {
          var modCache = this._modCache;
          return modName in modCache ?
              modCache[modName] || '' :
              modCache[modName] = this._extractModVal(modName);
        },

        /**
         * Sets the modifier for a BEM entity
         * @param {String} modName Modifier name
         * @param {String|Boolean} [modVal=true] Modifier value. If not of type String or Boolean, it is casted to String
         * @returns {BemEntity} this
         */
        setMod: function(modName, modVal) {
          var typeModVal = typeof modVal;
          if (typeModVal === 'undefined') {
            modVal = true;
          } else if (typeModVal === 'boolean') {
            modVal === false && (modVal = '');
          } else {
            modVal = modVal.toString();
          }

          /* jshint eqnull: true */
          if (this._processingMods[modName] != null) return this;

          var curModVal = this.getMod(modName);
          if (curModVal === modVal) return this;

          this._processingMods[modName] = curModVal;

          var needSetMod = true,
              modFnParams = [modName, modVal, curModVal],
              modVars = [['*', '*'], [modName, '*'], [modName, modVal]],
              prefixes = ['before', 'after'],
              i = 0, prefix, j, modVar;

          while (prefix = prefixes[i++]) {
            j = 0;
            while (modVar = modVars[j++]) {
              if (this._callModFn(prefix, modVar[0], modVar[1], modFnParams) ===
                  false) {
                needSetMod = false;
                break;
              }
            }

            if (!needSetMod) break;

            if (prefix === 'before') {
              this._modCache[modName] = modVal;
              this._onSetMod(modName, modVal, curModVal);
            }
          }

          this._processingMods[modName] = null;
          needSetMod && this._afterSetMod(modName, modVal, curModVal);

          return this;
        },

        /**
         * @protected
         * @param {String} modName Modifier name
         * @param {String} modVal Modifier value
         * @param {String} oldModVal Old modifier value
         */
        _onSetMod: function(modName, modVal, oldModVal) {
        },

        /**
         * @protected
         * @param {String} modName Modifier name
         * @param {String} modVal Modifier value
         * @param {String} oldModVal Old modifier value
         */
        _afterSetMod: function(modName, modVal, oldModVal) {
        },

        /**
         * Sets a modifier for a BEM entity, depending on conditions.
         * If the condition parameter is passed: when true, modVal1 is set; when false, modVal2 is set.
         * If the condition parameter is not passed: modVal1 is set if modVal2 was set, or vice versa.
         * @param {String} modName Modifier name
         * @param {String} [modVal1=true] First modifier value, optional for boolean modifiers
         * @param {String} [modVal2] Second modifier value
         * @param {Boolean} [condition] Condition
         * @returns {BemEntity} this
         */
        toggleMod: function(modName, modVal1, modVal2, condition) {
          typeof modVal1 === 'undefined' && (modVal1 = true); // boolean mod

          if (typeof modVal2 === 'undefined') {
            modVal2 = '';
          } else if (typeof modVal2 === 'boolean') {
            condition = modVal2;
            modVal2 = '';
          }

          var modVal = this.getMod(modName);
          (modVal === modVal1 || modVal === modVal2) &&
          this.setMod(
              modName,
              typeof condition === 'boolean' ?
                  (condition ? modVal1 : modVal2) :
                  this.hasMod(modName, modVal1) ? modVal2 : modVal1);

          return this;
        },

        /**
         * Removes a modifier from a BEM entity
         * @param {String} modName Modifier name
         * @returns {BemEntity} this
         */
        delMod: function(modName) {
          return this.setMod(modName, '');
        },

        /**
         * Executes handlers for setting modifiers
         * @private
         * @param {String} prefix
         * @param {String} modName Modifier name
         * @param {String} modVal Modifier value
         * @param {Array} modFnParams Handler parameters
         */
        _callModFn: function(prefix, modName, modVal, modFnParams) {
          var modFnName = buildModFnName(prefix, modName, modVal);
          return this[modFnName] ?
              this[modFnName].apply(this, modFnParams) :
              undef;
        },

        _extractModVal: function(modName) {
          return '';
        },

        /**
         * Returns a BEM entity's default parameters
         * @protected
         * @returns {Object}
         */
        _getDefaultParams: function() {
          return {};
        },

        /**
         * Executes given callback on next turn eventloop in BEM entity's context
         * @protected
         * @param {Function} fn callback
         * @returns {BemEntity} this
         */
        _nextTick: function(fn) {
          var _this = this;
          nextTick(function() {
            _this.hasMod('js', 'inited') && fn.call(_this);
          });
          return this;
        },
      }, /** @lends BemEntity */{
        /**
         * Factory method for creating an instance
         * @param {Object} mods modifiers
         * @param {Object} params params
         * @returns {BemEntity}
         */
        create: function(mods, params) {
          return new this(mods, params);
        },

        /**
         * Declares modifier
         * @param {Object} mod
         * @param {String} mod.modName
         * @param {String|Boolean|Array} [mod.modVal]
         * @param {Object} props
         * @param {Object} [staticProps]
         * @returns {Function}
         */
        declMod: function(mod, props, staticProps) {
          props && convertModHandlersToMethods(props);

          var checkMod = buildCheckMod(mod.modName, mod.modVal),
              basePtp = this.prototype;

          objects.each(props, function(prop, name) {
            functions.isFunction(prop) &&
            (props[name] = function() {
              var method;
              if (checkMod(this)) {
                method = prop;
              } else {
                var baseMethod = basePtp[name];
                baseMethod && baseMethod !== prop &&
                (method = this.__base);
              }
              return method ?
                  method.apply(this, arguments) :
                  undef;
            });
          });

          return inherit.self(this, props, staticProps);
        },

        __bemEntity: true,

        _name: null,

        /**
         * Processes a BEM entity's init
         * @private
         * @param {Boolean} [heedInit=false] Whether to take into account that the BEM entity already processed its init property
         */
        _processInit: function(heedInit) {
          this._inited = true;
        },

        /**
         * Returns the name of the current BEM entity
         * @returns {String}
         */
        getName: function() {
          return this._name;
        },

        /**
         * Returns the name of the current BEM entity
         * @returns {String}
         */
        getEntityName: function() {
          return this._name;
        },
      });

      /**
       * @class Block
       * @description Class for creating BEM blocks
       * @augments BemEntity
       */
      var Block = BemEntity;

      /**
       * @class Elem
       * @description Class for creating BEM elems
       * @augments BemEntity
       */
      var Elem = inherit(BemEntity, /** @lends Elem.prototype */ {
        /**
         * Returns the own block of current element
         * @protected
         * @returns {Block}
         */
        _block: function() {
          return this._blockInstance;
        },
      }, /** @lends Elem */{
        /**
         * Factory method for creating an instance
         * @param {Object} block block instance
         * @param {Object} mods modifiers
         * @param {Object} params params
         * @returns {BemEntity}
         */
        create: function(block, mods, params) {
          var res = new this(mods, params);
          res._blockInstance = block;
          return res;
        },

        /**
         * Returns the name of the current BEM entity
         * @returns {String}
         */
        getEntityName: function() {
          return this._blockName + ELEM_DELIM + this._name;
        },
      });

      provide(/** @exports */{
        /**
         * Block class
         * @type Function
         */
        Block: Block,

        /**
         * Elem class
         * @type Function
         */
        Elem: Elem,

        /**
         * Storage for block declarations (hash by block name)
         * @type Object
         */
        entities: entities,

        /**
         * Declares block and creates a block class
         * @param {String|Function} blockName Block name or block class
         * @param {Function|Array[Function]} [base] base block + mixes
         * @param {Object} [props] Methods
         * @param {Object} [staticProps] Static methods
         * @returns {Function} Block class
         */
        declBlock: function(blockName, base, props, staticProps) {
          if (typeof base === 'object' && !Array.isArray(base)) {
            staticProps = props;
            props = base;
            base = undef;
          }

          var baseCls = Block;
          if (typeof blockName !== 'string') {
            baseCls = blockName;
            blockName = blockName.getEntityName();
          }

          var res = declEntity(baseCls, blockName, base, props, staticProps);
          res._name = res._blockName = blockName;
          return res;
        },

        /**
         * Declares elem and creates an elem class
         * @param {String} [blockName] Block name
         * @param {String|Function} elemName Elem name or elem class
         * @param {Function|Function[]} [base] base elem + mixes
         * @param {Object} [props] Methods
         * @param {Object} [staticProps] Static methods
         * @returns {Function} Elem class
         */
        declElem: function(blockName, elemName, base, props, staticProps) {
          var baseCls = Elem,
              entityName;

          if (typeof blockName !== 'string') {
            staticProps = props;
            props = base;
            base = elemName;
            elemName = blockName._name;
            baseCls = blockName;
            blockName = baseCls._blockName;
            entityName = baseCls.getEntityName();
          } else {
            entityName = blockName + ELEM_DELIM + elemName;
          }

          if (typeof base === 'object' && !Array.isArray(base)) {
            staticProps = props;
            props = base;
            base = undef;
          }

          var res = declEntity(baseCls, entityName, base, props, staticProps);
          res._blockName = blockName;
          res._name = elemName;
          return res;
        },

        /**
         * Declares mixin
         * @param {Object} [props] Methods
         * @param {Object} [staticProps] Static methods
         * @returns {Function} mix
         */
        declMixin: function(props, staticProps) {
          convertModHandlersToMethods(props || (props = {}));
          return inherit(props, staticProps);
        },

        /**
         * Executes the block init functions
         * @private
         */
        _runInitFns: function() {
          if (initFns.length) {
            var fns = initFns,
                fn, i = 0;

            initFns = [];
            while (fn = fns[i]) {
              fn.call(fns[i + 1]);
              i += 2;
            }
          }
        },
      });

    });

/* end: ../../node_modules/bem-core/common.blocks/i-bem/i-bem.vanilla.js */
/* begin: ../../node_modules/bem-core/common.blocks/i-bem/__internal/i-bem__internal.vanilla.js */
/**
 * @module i-bem__internal
 */

modules.define('i-bem__internal', function(provide) {

  var undef,
      /**
       * Separator for modifiers and their values
       * @const
       * @type String
       */
      MOD_DELIM = '_',

      /**
       * Separator between names of a block and a nested element
       * @const
       * @type String
       */
      ELEM_DELIM = '__',

      /**
       * Pattern for acceptable element and modifier names
       * @const
       * @type String
       */
      NAME_PATTERN = '[a-zA-Z0-9-]+';

  function isSimple(obj) {
    var typeOf = typeof obj;
    return typeOf === 'string' || typeOf === 'number' || typeOf === 'boolean';
  }

  function buildModPostfix(modName, modVal) {
    var res = '';
    /* jshint eqnull: true */
    if (modVal != null && modVal !== false) {
      res += MOD_DELIM + modName;
      modVal !== true && (res += MOD_DELIM + modVal);
    }
    return res;
  }

  function buildBlockClassName(name, modName, modVal) {
    return name + buildModPostfix(modName, modVal);
  }

  function buildElemClassName(block, name, modName, modVal) {
    return buildBlockClassName(block, undef, undef) +
        ELEM_DELIM + name +
        buildModPostfix(modName, modVal);
  }

  provide(/** @exports */{
    NAME_PATTERN: NAME_PATTERN,

    MOD_DELIM: MOD_DELIM,
    ELEM_DELIM: ELEM_DELIM,

    buildModPostfix: buildModPostfix,

    /**
     * Builds the class name of a block or element with a modifier
     * @param {String} block Block name
     * @param {String} [elem] Element name
     * @param {String} [modName] Modifier name
     * @param {String|Number} [modVal] Modifier value
     * @returns {String} Class name
     */
    buildClassName: function(block, elem, modName, modVal) {
      if (isSimple(modName)) {
        if (!isSimple(modVal)) {
          modVal = modName;
          modName = elem;
          elem = undef;
        }
      } else if (typeof modName !== 'undefined') {
        modName = undef;
      } else if (elem && typeof elem !== 'string') {
        elem = undef;
      }

      if (!(elem || modName)) { // optimization for simple case
        return block;
      }

      return elem ?
          buildElemClassName(block, elem, modName, modVal) :
          buildBlockClassName(block, modName, modVal);
    },

    /**
     * Builds full class names for a buffer or element with modifiers
     * @param {String} block Block name
     * @param {String} [elem] Element name
     * @param {Object} [mods] Modifiers
     * @returns {String} Class
     */
    buildClassNames: function(block, elem, mods) {
      if (elem && typeof elem !== 'string') {
        mods = elem;
        elem = undef;
      }

      var res = elem ?
          buildElemClassName(block, elem, undef, undef) :
          buildBlockClassName(block, undef, undef);

      if (mods) {
        for (var modName in mods) {
          if (mods.hasOwnProperty(modName) && mods[modName]) {
            res += ' ' + (elem ?
                buildElemClassName(block, elem, modName, mods[modName]) :
                buildBlockClassName(block, modName, mods[modName]));
          }
        }
      }

      return res;
    },
  });

});

/* end: ../../node_modules/bem-core/common.blocks/i-bem/__internal/i-bem__internal.vanilla.js */
/* begin: ../../node_modules/bem-core/common.blocks/identify/identify.vanilla.js */
/**
 * @module identify
 */

modules.define('identify', function(provide) {

  var counter = 0,
      expando = '__' + (+new Date),
      global = this.global,
      get = function() {
        return 'uniq' + (++counter);
      },
      identify = function(obj) {
        if ((typeof obj === 'object' && obj !== null) || typeof obj ===
            'function') {
          var key;
          if ('uniqueID' in obj) {
            obj === global.document && (obj = obj.documentElement);
            key = 'uniqueID';
          } else {
            key = expando;
          }
          return key in obj ?
              obj[key] :
              obj[key] = get();
        }

        return '';
      };

  provide(
      /**
       * Makes unique ID
       * @exports
       * @param {?...Object} obj Object that needs to be identified
       * @returns {String} ID
       */
      function(obj) {
        if (arguments.length) {
          if (arguments.length === 1) {
            return identify(obj);
          }

          var res = [];
          for (var i = 0, len = arguments.length; i < len; i++) {
            res.push(identify(arguments[i]));
          }
          return res.sort().join('');
        }

        return get();
      },
  );

});

/* end: ../../node_modules/bem-core/common.blocks/identify/identify.vanilla.js */
/* begin: ../../node_modules/bem-core/common.blocks/next-tick/next-tick.vanilla.js */
/**
 * @module next-tick
 */

modules.define('next-tick', function(provide) {

  /**
   * Executes given function on next tick.
   * @exports
   * @type Function
   * @param {Function} fn
   */

  var global = this.global,
      fns = [],
      enqueueFn = function(fn) {
        fns.push(fn);
        return fns.length === 1;
      },
      callFns = function() {
        var fnsToCall = fns, i = 0, len = fns.length;
        fns = [];
        while (i < len) {
          fnsToCall[i++]();
        }
      };

  /* global process */
  if (typeof process === 'object' && process.nextTick) { // nodejs
    return provide(function(fn) {
      enqueueFn(fn) && process.nextTick(callFns);
    });
  }

  if (global.setImmediate) { // ie10
    return provide(function(fn) {
      enqueueFn(fn) && global.setImmediate(callFns);
    });
  }

  if (global.postMessage) { // modern browsers
    var isPostMessageAsync = true;
    if (global.attachEvent) {
      var checkAsync = function() {
        isPostMessageAsync = false;
      };
      global.attachEvent('onmessage', checkAsync);
      global.postMessage('__checkAsync', '*');
      global.detachEvent('onmessage', checkAsync);
    }

    if (isPostMessageAsync) {
      var msg = '__nextTick' + (+new Date),
          onMessage = function(e) {
            if (e.data === msg) {
              e.stopPropagation && e.stopPropagation();
              callFns();
            }
          };

      global.addEventListener ?
          global.addEventListener('message', onMessage, true) :
          global.attachEvent('onmessage', onMessage);

      return provide(function(fn) {
        enqueueFn(fn) && global.postMessage(msg, '*');
      });
    }
  }

  var doc = global.document;
  if ('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
    var head = doc.getElementsByTagName('head')[0],
        createScript = function() {
          var script = doc.createElement('script');
          script.onreadystatechange = function() {
            script.parentNode.removeChild(script);
            script = script.onreadystatechange = null;
            callFns();
          };
          head.appendChild(script);
        };

    return provide(function(fn) {
      enqueueFn(fn) && createScript();
    });
  }

  provide(function(fn) { // old browsers
    enqueueFn(fn) && global.setTimeout(callFns, 0);
  });
});

/* end: ../../node_modules/bem-core/common.blocks/next-tick/next-tick.vanilla.js */
/* begin: ../../node_modules/bem-core/common.blocks/i-bem-dom/__events/i-bem-dom__events.js */
/**
 * @module i-bem-dom__events
 */
modules.define(
    'i-bem-dom__events',
    [
      'i-bem__internal',
      'i-bem-dom__collection',
      'inherit',
      'identify',
      'objects',
      'jquery',
      'functions',
    ],
    function(
        provide,
        bemInternal,
        BemDomCollection,
        inherit,
        identify,
        objects,
        $,
        functions) {

      var undef,
          winNode = window,
          docNode = document,
          winId = identify(winNode),
          docId = identify(docNode),
          eventStorage = {},

          /**
           * @class EventManager
           */
          EventManager = inherit(/** @lends EventManager.prototype */{
            /**
             * @constructor
             * @param {Object} params EventManager parameters
             * @param {Function} fnWrapper Wrapper function to build event handler
             * @param {Function} eventBuilder Function to build event
             */
            __constructor: function(params, fnWrapper, eventBuilder) {
              this._params = params;
              this._fnWrapper = fnWrapper;
              this._eventBuilder = eventBuilder;
              this._storage = {};
            },

            /**
             * Adds an event handler
             * @param {String|Object|events:Event} e Event type
             * @param {*} [data] Additional data that the handler gets as e.data
             * @param {Function} fn Handler
             * @returns {EventManager} this
             */
            on: function(e, data, fn, _fnCtx, _isOnce) {
              var params = this._params,
                  event = this._eventBuilder(e, params);

              if (functions.isFunction(data)) {
                _isOnce = _fnCtx;
                _fnCtx = fn;
                fn = data;
                data = undef;
              }

              var fnStorage = this._storage[event] ||
                  (this._storage[event] = {}),
                  fnId = identify(fn, _fnCtx);

              if (!fnStorage[fnId]) {
                var bindDomElem = params.bindDomElem,
                    bindSelector = params.bindSelector,
                    _this = this,
                    handler = fnStorage[fnId] = this._fnWrapper(
                        _isOnce ?
                            function() {
                              _this.un(e, fn, _fnCtx);
                              fn.apply(this, arguments);
                            } :
                            fn,
                        _fnCtx,
                        fnId);

                bindDomElem.on(event, bindSelector, data, handler);
                bindSelector && bindDomElem.is(bindSelector) &&
                bindDomElem.on(event, data, handler);
                // FIXME: "once" won't properly work in case of nested and mixed elem with the same name
              }

              return this;
            },

            /**
             * Adds an event handler
             * @param {String} e Event type
             * @param {*} [data] Additional data that the handler gets as e.data
             * @param {Function} fn Handler
             * @returns {EventManager} this
             */
            once: function(e, data, fn, _fnCtx) {
              if (functions.isFunction(data)) {
                _fnCtx = fn;
                fn = data;
                data = undef;
              }

              return this.on(e, data, fn, _fnCtx, true);
            },

            /**
             * Removes event handler or handlers
             * @param {String|Object|events:Event} [e] Event type
             * @param {Function} [fn] Handler
             * @returns {EventManager} this
             */
            un: function(e, fn, _fnCtx) {
              var argsLen = arguments.length;
              if (argsLen) {
                var params = this._params,
                    event = this._eventBuilder(e, params);

                if (argsLen === 1) {
                  this._unbindByEvent(this._storage[event], event);
                } else {
                  var wrappedFn,
                      fnId = identify(fn, _fnCtx),
                      fnStorage = this._storage[event],
                      bindDomElem = params.bindDomElem,
                      bindSelector = params.bindSelector;

                  if (wrappedFn = fnStorage && fnStorage[fnId])
                    delete fnStorage[fnId];

                  var handler = wrappedFn || fn;

                  bindDomElem.off(event, params.bindSelector, handler);
                  bindSelector && bindDomElem.is(bindSelector) &&
                  bindDomElem.off(event, handler);
                }
              } else {
                objects.each(this._storage, this._unbindByEvent, this);
              }

              return this;
            },

            _unbindByEvent: function(fnStorage, e) {
              var params = this._params,
                  bindDomElem = params.bindDomElem,
                  bindSelector = params.bindSelector,
                  unbindWithoutSelector = bindSelector &&
                      bindDomElem.is(bindSelector);

              fnStorage && objects.each(fnStorage, function(fn) {
                bindDomElem.off(e, bindSelector, fn);
                unbindWithoutSelector && bindDomElem.off(e, fn);
              });
              this._storage[e] = null;
            },
          }),
          buildForEachEventManagerProxyFn = function(methodName) {
            return function() {
              var args = arguments;

              this._eventManagers.forEach(function(eventManager) {
                eventManager[methodName].apply(eventManager, args);
              });

              return this;
            };
          },
          /**
           * @class CollectionEventManager
           */
          CollectionEventManager = inherit(
              /** @lends CollectionEventManager.prototype */{
                /**
                 * @constructor
                 * @param {Array} eventManagers Array of event managers
                 */
                __constructor: function(eventManagers) {
                  this._eventManagers = eventManagers;
                },

                /**
                 * Adds an event handler
                 * @param {String|Object|events:Event} e Event type
                 * @param {Object} [data] Additional data that the handler gets as e.data
                 * @param {Function} fn Handler
                 * @returns {CollectionEventManager} this
                 */
                on: buildForEachEventManagerProxyFn('on'),

                /**
                 * Adds an event handler
                 * @param {String} e Event type
                 * @param {Object} [data] Additional data that the handler gets as e.data
                 * @param {Function} fn Handler
                 * @returns {CollectionEventManager} this
                 */
                once: buildForEachEventManagerProxyFn('once'),

                /**
                 * Removes event handler or handlers
                 * @param {String|Object|events:Event} [e] Event type
                 * @param {Function} [fn] Handler
                 * @returns {CollectionEventManager} this
                 */
                un: buildForEachEventManagerProxyFn('un'),
              }),
          /**
           * @class EventManagerFactory
           * @exports i-bem-dom__events:EventManagerFactory
           */
          EventManagerFactory = inherit(
              /** @lends EventManagerFactory.prototype */{
                __constructor: function(getEntityCls) {
                  this._storageSuffix = identify();
                  this._getEntityCls = getEntityCls;
                  this._eventManagerCls = EventManager;
                },

                /**
                 * Instantiates event manager
                 * @param {Function|i-bem-dom:BemDomEntity} ctx BemDomEntity class or instance
                 * @param {*} bindCtx context to bind
                 * @param {jQuery} bindScope bind scope
                 * @returns {EventManager}
                 */
                getEventManager: function(ctx, bindCtx, bindScope) {
                  if (bindCtx instanceof BemDomCollection) {
                    return new CollectionEventManager(
                        bindCtx.map(function(entity) {
                          return this.getEventManager(ctx, entity, bindScope);
                        }, this));
                  }

                  var ctxId = identify(ctx),
                      ctxStorage = eventStorage[ctxId],
                      storageSuffix = this._storageSuffix,
                      isBindToInstance = typeof ctx !== 'function',
                      ctxCls,
                      selector = '';

                  if (isBindToInstance) {
                    ctxCls = ctx.__self;
                  } else {
                    ctxCls = ctx;
                    selector = ctx._buildSelector();
                  }

                  var params = this._buildEventManagerParams(bindCtx, bindScope,
                      selector, ctxCls),
                      storageKey = params.key + storageSuffix;

                  if (!ctxStorage) {
                    ctxStorage = eventStorage[ctxId] = {};
                    if (isBindToInstance) {
                      ctx._events().on({modName: 'js', modVal: ''}, function() {
                        params.bindToArbitraryDomElem &&
                        ctxStorage[storageKey] &&
                        ctxStorage[storageKey].un();
                        delete ctxStorage[ctxId];
                      });
                    }
                  }

                  return ctxStorage[storageKey] ||
                      (ctxStorage[storageKey] = this._createEventManager(ctx,
                          params, isBindToInstance));
                },

                _buildEventManagerParams: function(
                    bindCtx, bindScope, ctxSelector, ctxCls) {
                  var res = {
                    bindEntityCls: null,
                    bindDomElem: bindScope,
                    bindToArbitraryDomElem: false,
                    bindSelector: ctxSelector,
                    ctxSelector: ctxSelector,
                    key: '',
                  };

                  if (bindCtx) {
                    var typeOfCtx = typeof bindCtx;

                    if (bindCtx.jquery) {
                      res.bindDomElem = bindCtx;
                      res.key = identify.apply(null, bindCtx.get());
                      res.bindToArbitraryDomElem = true;
                    } else if (bindCtx === winNode || bindCtx === docNode ||
                        (typeOfCtx === 'object' && bindCtx.nodeType === 1)) { // NOTE: duck-typing check for "is-DOM-element"
                      res.bindDomElem = $(bindCtx);
                      res.key = identify(bindCtx);
                      res.bindToArbitraryDomElem = true;
                    } else if (typeOfCtx === 'object' && bindCtx.__self) { // bem entity instance
                      res.bindDomElem = bindCtx.domElem;
                      res.key = bindCtx._uniqId;
                      res.bindEntityCls = bindCtx.__self;
                    } else if (typeOfCtx === 'string' || typeOfCtx ===
                        'object' || typeOfCtx === 'function') {
                      var blockName, elemName, modName, modVal;
                      if (typeOfCtx === 'string') { // elem name
                        blockName = ctxCls._blockName;
                        elemName = bindCtx;
                      } else if (typeOfCtx === 'object') { // bem entity with optional mod val
                        blockName = bindCtx.block ?
                            bindCtx.block.getName() :
                            ctxCls._blockName;
                        elemName = typeof bindCtx.elem === 'function' ?
                            bindCtx.elem.getName() :
                            bindCtx.elem;
                        modName = bindCtx.modName;
                        modVal = bindCtx.modVal;
                      } else if (bindCtx.getName() ===
                          bindCtx.getEntityName()) { // block class
                        blockName = bindCtx.getName();
                      } else { // elem class
                        blockName = ctxCls._blockName;
                        elemName = bindCtx.getName();
                      }

                      var entityName = bemInternal.buildClassName(blockName,
                          elemName);
                      res.bindEntityCls = this._getEntityCls(entityName);
                      res.bindSelector = '.' + (res.key = entityName +
                          bemInternal.buildModPostfix(modName, modVal));
                    }
                  } else {
                    res.bindEntityCls = ctxCls;
                  }

                  return res;
                },

                _createEventManager: function(ctx, params, isInstance) {
                  throw new Error('not implemented');
                },
              });

      provide({
        EventManagerFactory: EventManagerFactory,
      });

    });

/* end: ../../node_modules/bem-core/common.blocks/i-bem-dom/__events/i-bem-dom__events.js */
/* begin: ../../node_modules/bem-core/common.blocks/i-bem-dom/__collection/i-bem-dom__collection.js */
/**
 * @module i-bem-dom__collection
 */
modules.define('i-bem-dom__collection', ['inherit', 'i-bem__collection'],
    function(provide, inherit, BemCollection) {

      /**
       * @class BemDomCollection
       */
      var BemDomCollection = inherit(BemCollection,
          /** @lends BemDomCollection.prototype */{
            /**
             * Finds the first child block for every entities in collection
             * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
             * @returns {BemDomCollection}
             */
            findChildBlock: buildProxyMethodForOne('findChildBlock'),

            /**
             * Finds child block for every entities in collections
             * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
             * @returns {BemDomCollection}
             */
            findChildBlocks: buildProxyMethodForMany('findChildBlocks'),

            /**
             * Finds the first parent block for every entities in collection
             * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
             * @returns {BemDomCollection}
             */
            findParentBlock: buildProxyMethodForOne('findParentBlock'),

            /**
             * Finds parent block for every entities in collections
             * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
             * @returns {BemDomCollection}
             */
            findParentBlocks: buildProxyMethodForMany('findParentBlocks'),

            /**
             * Finds first mixed bloc for every entities in collectionk
             * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
             * @returns {BemDomCollection}
             */
            findMixedBlock: buildProxyMethodForOne('findMixedBlock'),

            /**
             * Finds mixed block for every entities in collections
             * @param {Function|Object} Block Block class or description (block, modName, modVal) of the block to find
             * @returns {BemDomCollection}
             */
            findMixedBlocks: buildProxyMethodForMany('findMixedBlocks'),

            /**
             * Finds the first child elemen for every entities in collectiont
             * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
             * @param {Boolean} [strictMode=false]
             * @returns {BemDomCollection}
             */
            findChildElem: buildProxyMethodForOne('findChildElem'),

            /**
             * Finds child element for every entities in collections
             * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
             * @param {Boolean} [strictMode=false]
             * @returns {BemDomCollection}
             */
            findChildElems: buildProxyMethodForMany('findChildElems'),

            /**
             * Finds the first parent elemen for every entities in collectiont
             * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
             * @param {Boolean} [strictMode=false]
             * @returns {BemDomCollection}
             */
            findParentElem: buildProxyMethodForOne('findParentElem'),

            /**
             * Finds parent element for every entities in collections
             * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
             * @param {Boolean} [strictMode=false]
             * @returns {BemDomCollection}
             */
            findParentElems: buildProxyMethodForMany('findParentElems'),

            /**
             * Finds the first mixed elemen for every entities in collectiont
             * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
             * @returns {BemDomCollection}
             */
            findMixedElem: buildProxyMethodForOne('findMixedElem'),

            /**
             * Finds mixed element for every entities in collections
             * @param {Function|String|Object} Elem Element class or name or description elem, modName, modVal
             * @returns {BemDomCollection}
             */
            findMixedElems: buildProxyMethodForMany('findMixedElems'),
          });

      function collectionMapMethod(collection, methodName, args) {
        return collection.map(function(entity) {
          return entity[methodName].apply(entity, args);
        });
      }

      function buildProxyMethodForOne(methodName) {
        return function() {
          return new BemDomCollection(
              collectionMapMethod(this, methodName, arguments));
        };
      }

      function buildProxyMethodForMany(methodName) {
        return function() {
          var res = [];

          collectionMapMethod(this, methodName, arguments).
              forEach(function(collection) {
                collection.forEach(function(entity) {
                  res.push(entity);
                });
              });

          return new BemDomCollection(res);
        };
      }

      provide(BemDomCollection);

    });

/* end: ../../node_modules/bem-core/common.blocks/i-bem-dom/__collection/i-bem-dom__collection.js */
/* begin: ../../node_modules/bem-core/common.blocks/i-bem/__collection/i-bem__collection.js */
/**
 * @module i-bem__collection
 */
modules.define('i-bem__collection', ['inherit'], function(provide, inherit) {

  /**
   * @class BemCollection
   */
  var BemCollection = inherit(/** @lends BemCollection.prototype */{
    /**
     * @constructor
     * @param {Array} entities BEM entities
     */
    __constructor: function(entities) {
      var _entities = this._entities = [],
          uniq = {};
      (Array.isArray(entities) ? entities : arraySlice.call(arguments)).forEach(
          function(entity) {
            if (!uniq[entity._uniqId]) {
              uniq[entity._uniqId] = true;
              _entities.push(entity);
            }
          });
    },

    /**
     * Sets the modifier for entities in Collection.
     * @param {String} modName Modifier name
     * @param {String|Boolean} [modVal=true] Modifier value. If not of type String or Boolean, it is casted to String
     * @returns {Collection} this
     */
    setMod: buildForEachEntityMethodProxyFn('setMod'),

    /**
     * Removes the modifier from entities in Collection.
     * @param {String} modName Modifier name
     * @returns {Collection} this
     */
    delMod: buildForEachEntityMethodProxyFn('delMod'),

    /**
     * Sets a modifier for entities in Collection, depending on conditions.
     * If the condition parameter is passed: when true, modVal1 is set; when false, modVal2 is set.
     * If the condition parameter is not passed: modVal1 is set if modVal2 was set, or vice versa.
     * @param {String} modName Modifier name
     * @param {String} modVal1 First modifier value
     * @param {String} [modVal2] Second modifier value
     * @param {Boolean} [condition] Condition
     * @returns {Collection} this
     */
    toggleMod: buildForEachEntityMethodProxyFn('toggleMod'),

    /**
     * Checks whether every entity in Collection has a modifier.
     * @param {String} modName Modifier name
     * @param {String|Boolean} [modVal] Modifier value. If not of type String or Boolean, it is casted to String
     * @returns {Boolean}
     */
    everyHasMod: buildComplexProxyFn('every', 'hasMod'),

    /**
     * Checks whether some entities in Collection has a modifier.
     * @param {String} modName Modifier name
     * @param {String|Boolean} [modVal] Modifier value. If not of type String or Boolean, it is casted to String
     * @returns {Boolean}
     */
    someHasMod: buildComplexProxyFn('some', 'hasMod'),

    /**
     * Returns entity by index.
     * @param {Number} i Index
     * @returns {BemEntity}
     */
    get: function(i) {
      return this._entities[i];
    },

    /**
     * Calls callback once for each entity in collection.
     * @param {Function} fn Callback
     * @param {Object} ctx Callback context
     */
    forEach: buildEntitiesMethodProxyFn('forEach'),

    /**
     * Creates an array with the results of calling callback on every entity in collection.
     * @param {Function} fn Callback
     * @param {Object} ctx Callback context
     * @returns {Array}
     */
    map: buildEntitiesMethodProxyFn('map'),

    /**
     * Applies callback against an accumulator and each entity in collection (from left-to-right)
     * to reduce it to a single value.
     * @param {Function} fn Callback
     * @param {Object} [initial] Initial value
     * @returns {Array}
     */
    reduce: buildEntitiesMethodProxyFn('reduce'),

    /**
     * Applies callback against an accumulator and each entity in collection (from right-to-left)
     * to reduce it to a single value.
     * @param {Function} fn Callback
     * @param {Object} [initial] Initial value
     * @returns {Array}
     */
    reduceRight: buildEntitiesMethodProxyFn('reduceRight'),

    /**
     * Creates a new collection with all entities that pass the test implemented by the provided callback.
     * @param {Function} fn Callback
     * @param {Object} ctx Callback context
     * @returns {Collection}
     */
    filter: function() {
      return new this.__self(
          buildEntitiesMethodProxyFn('filter').apply(this, arguments));
    },

    /**
     * Tests whether some entities in the collection passes the test implemented by the provided callback.
     * @param {Function} fn Callback
     * @param {Object} ctx Callback context
     * @returns {Boolean}
     */
    some: buildEntitiesMethodProxyFn('some'),

    /**
     * Tests whether every entities in the collection passes the test implemented by the provided callback.
     * @param {Function} fn Callback
     * @param {Object} ctx Callback context
     * @returns {Boolean}
     */
    every: buildEntitiesMethodProxyFn('every'),

    /**
     * Returns a boolean asserting whether an entity is present in the collection.
     * @param {BemEntity} entity BEM entity
     * @returns {Boolean}
     */
    has: function(entity) {
      return this._entities.indexOf(entity) > -1;
    },

    /**
     * Returns an entity, if it satisfies the provided testing callback.
     * @param {Function} fn Callback
     * @param {Object} ctx Callback context
     * @returns {BemEntity}
     */
    find: function(fn, ctx) {
      ctx || (ctx = this);
      var entities = this._entities,
          i = 0,
          entity;

      while (entity = entities[i])
        if (fn.call(ctx, entities[i], i++, this))
          return entity;

      return null;
    },

    /**
     * Returns a new collection comprised of collection on which it is called joined with
     * the collection(s) and/or array(s) and/or entity(es) provided as arguments.
     * @param {?...(Collection|Array|BemEntity)} args
     * @returns {Collection}
     */
    concat: function() {
      var i = 0,
          l = arguments.length,
          arg,
          argsForConcat = [];

      while (i < l) {
        arg = arguments[i++];
        argsForConcat.push(
            arg instanceof BemCollection ? arg._entities : arg);
      }

      return new this.__self(arrayConcat.apply(this._entities, argsForConcat));
    },

    /**
     * Returns size of the collection.
     * @returns {Number}
     */
    size: function() {
      return this._entities.length;
    },

    /**
     * Converts the collection into array.
     * @returns {Array}
     */
    toArray: function() {
      return this._entities.slice();
    },
  });

  function buildForEachEntityMethodProxyFn(methodName) {
    return function() {
      var args = arguments;
      this._entities.forEach(function(entity) {
        entity[methodName].apply(entity, args);
      });
      return this;
    };
  }

  function buildEntitiesMethodProxyFn(methodName) {
    return function() {
      var entities = this._entities;
      return entities[methodName].apply(entities, arguments);
    };
  }

  function buildComplexProxyFn(arrayMethodName, entityMethodName) {
    return function() {
      var args = arguments;
      return this._entities[arrayMethodName](function(entity) {
        return entity[entityMethodName].apply(entity, args);
      });
    };
  }

  var arrayConcat = Array.prototype.concat,
      arraySlice = Array.prototype.slice;

  provide(BemCollection);

});

/* end: ../../node_modules/bem-core/common.blocks/i-bem/__collection/i-bem__collection.js */
/* begin: ../../node_modules/bem-core/common.blocks/i-bem-dom/__events/_type/i-bem-dom__events_type_bem.js */
/**
 * @module i-bem-dom__events_type_bem
 */
modules.define(
    'i-bem-dom__events_type_bem',
    [
      'i-bem-dom__events',
      'i-bem__internal',
      'inherit',
      'functions',
      'jquery',
      'identify',
      'events',
    ],
    function(
        provide,
        bemDomEvents,
        bemInternal,
        inherit,
        functions,
        $,
        identify,
        events) {

      var EVENT_PREFIX = '__bem__',
          MOD_CHANGE_EVENT = 'modchange',

          specialEvents = $.event.special,
          specialEventsStorage = {},

          createSpecialEvent = function(event) {
            return {
              setup: function() {
                specialEventsStorage[event] ||
                (specialEventsStorage[event] = true);
              },
              teardown: functions.noop,
            };
          },

          eventBuilder = function(e, params) {
            var event = EVENT_PREFIX + params.bindEntityCls.getEntityName() +
                (typeof e === 'object' ?
                    e instanceof events.Event ?
                        e.type :
                        bemInternal.buildModPostfix(e.modName, e.modVal) :
                    e);

            specialEvents[event] ||
            (specialEvents[event] = createSpecialEvent(event));

            return event;
          },

          /**
           * @class EventManagerFactory
           * @augments i-bem-dom__events:EventManagerFactory
           * @exports i-bem-dom__events_type_bem:EventManagerFactory
           */
          EventManagerFactory = inherit(bemDomEvents.EventManagerFactory,
              /** @lends EventManagerFactory.prototype */{
                /** @override */
                _createEventManager: function(ctx, params, isInstance) {
                  function wrapperFn(fn, fnCtx, fnId) {
                    return function(e, data, flags, originalEvent) {
                      if (flags.fns[fnId]) return;

                      var instance,
                          instanceDomElem;

                      if (isInstance) {
                        instance = ctx;
                        instanceDomElem = instance.domElem;
                      } else {
                        // TODO: we could optimize all these "closest" to a single traversing
                        instanceDomElem = $(e.target).
                            closest(params.ctxSelector);
                        instanceDomElem.length &&
                        (instance = instanceDomElem.bem(ctx));
                      }

                      if (instance &&
                          (!flags.propagationStoppedDomNode ||
                              !$.contains(instanceDomElem[0],
                                  flags.propagationStoppedDomNode))) {
                        originalEvent.data = e.data;
                        // TODO: do we really need both target and bemTarget?
                        originalEvent.bemTarget = originalEvent.target;
                        flags.fns[fnId] = true;
                        fn.call(fnCtx || instance, originalEvent, data);

                        if (originalEvent.isPropagationStopped()) {
                          e.stopPropagation();
                          flags.propagationStoppedDomNode = instanceDomElem[0];
                        }
                      }
                    };
                  }

                  return new this._eventManagerCls(params, wrapperFn,
                      eventBuilder);
                },
              });

      provide(/** @exports */ {
        /**
         * Emits BEM event
         * @augments i-bem-dom__events_type_bem
         * @param {BemDomEntity} ctx
         * @param {String|Object|events:Event} e Event name
         * @param {Object} [data]
         */
        emit: function(ctx, e, data) {
          var originalEvent;
          if (typeof e === 'string') {
            originalEvent = new events.Event(e, ctx);
          } else if (e.modName) {
            originalEvent = new events.Event(MOD_CHANGE_EVENT, ctx);
          } else if (!e.target) {
            e.target = ctx;
            originalEvent = e;
          }

          var event = eventBuilder(e, {bindEntityCls: ctx.__self});

          specialEventsStorage[event] &&
          ctx.domElem.trigger(event, [
            data,
            {fns: {}, propagationStoppedDomNode: null},
            originalEvent]);
        },

        EventManagerFactory: EventManagerFactory,
      });

    });

/* end: ../../node_modules/bem-core/common.blocks/i-bem-dom/__events/_type/i-bem-dom__events_type_bem.js */
/* begin: ../../node_modules/bem-core/common.blocks/events/events.vanilla.js */
/**
 * @module events
 */

modules.define(
    'events',
    ['identify', 'inherit', 'functions'],
    function(provide, identify, inherit, functions) {

      var undef,
          storageExpando = '__' + (+new Date) + 'storage',

          /**
           * @class Event
           * @exports events:Event
           */
          Event = inherit(/** @lends Event.prototype */{
            /**
             * @constructor
             * @param {String} type
             * @param {Object} target
             */
            __constructor: function(type, target) {
              /**
               * Type
               * @member {String}
               */
              this.type = type;

              /**
               * Target
               * @member {Object}
               */
              this.target = target;

              /**
               * Data
               * @member {*}
               */
              this.data = undef;

              this._isDefaultPrevented = false;
              this._isPropagationStopped = false;
            },

            /**
             * Prevents default action
             */
            preventDefault: function() {
              this._isDefaultPrevented = true;
            },

            /**
             * Returns whether is default action prevented
             * @returns {Boolean}
             */
            isDefaultPrevented: function() {
              return this._isDefaultPrevented;
            },

            /**
             * Stops propagation
             */
            stopPropagation: function() {
              this._isPropagationStopped = true;
            },

            /**
             * Returns whether is propagation stopped
             * @returns {Boolean}
             */
            isPropagationStopped: function() {
              return this._isPropagationStopped;
            },
          }),

          /**
           * @class Emitter
           * @exports events:Emitter
           */
          Emitter = inherit(/** @lends Emitter.prototype */{
            /**
             * Adds an event handler
             * @param {String} e Event type
             * @param {Object} [data] Additional data that the handler gets as e.data
             * @param {Function} fn Handler
             * @param {Object} [ctx] Handler context
             * @returns {Emitter} this
             */
            on: function(e, data, fn, ctx, _special) {
              if (typeof e === 'string') {
                if (functions.isFunction(data)) {
                  ctx = fn;
                  fn = data;
                  data = undef;
                }

                var id = identify(fn, ctx),
                    storage = this[storageExpando] ||
                        (this[storageExpando] = {}),
                    eventTypes = e.split(' '), eventType,
                    i = 0, list, item,
                    eventStorage;

                while (eventType = eventTypes[i++]) {
                  eventStorage = storage[eventType] ||
                      (storage[eventType] = {ids: {}, list: {}});
                  if (!(id in eventStorage.ids)) {
                    list = eventStorage.list;
                    item = {fn: fn, data: data, ctx: ctx, special: _special};
                    if (list.last) {
                      list.last.next = item;
                      item.prev = list.last;
                    } else {
                      list.first = item;
                    }
                    eventStorage.ids[id] = list.last = item;
                  }
                }
              } else {
                for (var key in e) {
                  e.hasOwnProperty(key) && this.on(key, e[key], data, _special);
                }
              }

              return this;
            },

            /**
             * Adds a one time handler for the event.
             * Handler is executed only the next time the event is fired, after which it is removed.
             * @param {String} e Event type
             * @param {Object} [data] Additional data that the handler gets as e.data
             * @param {Function} fn Handler
             * @param {Object} [ctx] Handler context
             * @returns {Emitter} this
             */
            once: function(e, data, fn, ctx) {
              return this.on(e, data, fn, ctx, {once: true});
            },

            /**
             * Removes event handler or handlers
             * @param {String} [e] Event type
             * @param {Function} [fn] Handler
             * @param {Object} [ctx] Handler context
             * @returns {Emitter} this
             */
            un: function(e, fn, ctx) {
              if (typeof e === 'string' || typeof e === 'undefined') {
                var storage = this[storageExpando];
                if (storage) {
                  if (e) { // if event type was passed
                    var eventTypes = e.split(' '),
                        i = 0, eventStorage;
                    while (e = eventTypes[i++]) {
                      if (eventStorage = storage[e]) {
                        if (fn) {  // if specific handler was passed
                          var id = identify(fn, ctx),
                              ids = eventStorage.ids;
                          if (id in ids) {
                            var list = eventStorage.list,
                                item = ids[id],
                                prev = item.prev,
                                next = item.next;

                            if (prev) {
                              prev.next = next;
                            } else if (item === list.first) {
                              list.first = next;
                            }

                            if (next) {
                              next.prev = prev;
                            } else if (item === list.last) {
                              list.last = prev;
                            }

                            delete ids[id];
                          }
                        } else {
                          delete this[storageExpando][e];
                        }
                      }
                    }
                  } else {
                    delete this[storageExpando];
                  }
                }
              } else {
                for (var key in e) {
                  e.hasOwnProperty(key) && this.un(key, e[key], fn);
                }
              }

              return this;
            },

            /**
             * Fires event handlers
             * @param {String|events:Event} e Event
             * @param {Object} [data] Additional data
             * @returns {Emitter} this
             */
            emit: function(e, data) {
              var storage = this[storageExpando],
                  eventInstantiated = false;

              if (storage) {
                var eventTypes = [typeof e === 'string' ? e : e.type, '*'],
                    i = 0, eventType, eventStorage;
                while (eventType = eventTypes[i++]) {
                  if (eventStorage = storage[eventType]) {
                    var item = eventStorage.list.first,
                        lastItem = eventStorage.list.last,
                        res;
                    while (item) {
                      if (!eventInstantiated) { // instantiate Event only on demand
                        eventInstantiated = true;
                        typeof e === 'string' && (e = new Event(e));
                        e.target || (e.target = this);
                      }

                      e.data = item.data;
                      res = item.fn.apply(item.ctx || this, arguments);
                      if (res === false) {
                        e.preventDefault();
                        e.stopPropagation();
                      }

                      item.special && item.special.once &&
                      this.un(e.type, item.fn, item.ctx);

                      if (item === lastItem) {
                        break;
                      }

                      item = item.next;
                    }
                  }
                }
              }

              return this;
            },
          });

      provide({
        Emitter: Emitter,
        Event: Event,
      });

    });

/* end: ../../node_modules/bem-core/common.blocks/events/events.vanilla.js */
/* begin: ../../node_modules/bem-core/common.blocks/i-bem-dom/__init/_auto/i-bem-dom__init_auto.js */
/**
 * Auto initialization on DOM ready
 */

modules.require(
    ['i-bem-dom__init', 'jquery', 'next-tick'],
    function(init, $, nextTick) {

      $(function() {
        nextTick(init);
      });

    });

/* end: ../../node_modules/bem-core/common.blocks/i-bem-dom/__init/_auto/i-bem-dom__init_auto.js */
/* begin: ../../5th.blocks/common.blocks/forms/forms.js */
/**
 * @module forms
 */
modules.define('forms',
    ['i-bem-dom', 'jquery', 'form', 'notification', 'modal'],
    function(provide, bemDom, $, Form, Notification, Modal) {
      /**
       * forms block
       */
      provide(bemDom.declBlock(this.name, /** @lends app.prototype */{

        onSetMod: {
          'js': {
            'inited': function() {
              this._notification = this.findMixedBlock(Notification);
              // this._forms        = this.findChildBlocks(Form);
              // this._events(this._forms).on('submit', this._onSubmit);

              //this._form.getFields()[1].setValidationMessage('required', 'Ololo!');
              //this._form.getFields()[0].setValidationMessages({
              //    required : 'FUCK!'
              //});

              //this._form.getFields()[2].setMod('disabled');
              //this._form.getFields()[0].setStatus('invalid');

              // You can bind to other form events
              // this._form.on('change', function(e, data) {
              //     console.log('changed form', data);
              // });

              // this._form.on('focus', function(e, data) {
              //     console.log('focused form', data);
              // });
            },
          },
        },

        _onSubmit: function(e, val) {
          var _form = e.bemTarget;

          _form.validate().then(function(fieldsStatuses) {
            if (_form.checkFields(fieldsStatuses)) {
              _form.getMessage().hide();
              console.log(val);

              _form.hasMod('no-ajax')
                  ? this._sendRequest(_form)
                  : this._sendAjaxRequest(_form);

            } else {
              // _form.setMessageVal(this._concatMessages(fieldsStatuses));
              // _form.getMessage().show();
              _form.getInvalidFields().then(function(invalidFields) {

                this._showinvalidFieldsMessages(invalidFields);

                invalidFields[0].getControl().setMod('focused');
              }.bind(this));
            }
          }.bind(this));
        },

        /**
         * Показ сообщений каждого неверно заполненного поля
         */
        _showinvalidFieldsMessages: function(invalidFields) {
          invalidFields.forEach(function(invalidField) {
            invalidField.getMessage().show();
          }, this);
        },

        /**
         * Вывод общего сообщения с ошибками
         */
        _concatMessages: function(fieldsStatuses) {
          console.log('fieldsStatuses', fieldsStatuses);

          var messages = [];
          for (var i = 0, l = fieldsStatuses.length; i < l; i++) {
            if (fieldsStatuses[i] !== null) {
              messages.push([
                fieldsStatuses[i]['field'],
                ': ',
                fieldsStatuses[i]['message'],
              ].join(''));
            }
          }
          return messages.join('<br>');
        },

        _sendRequest: function(form) {
          var values = form.getVal();

          if (form.domElem.attr('method') == 'GET') {

            var queryString = '';

            for (var key in values) {
              if (values.hasOwnProperty(key)) {
                var val = values[key];
                queryString += !queryString ? '?' : '&';
                queryString += key + '=' + val;
              }
            }

            window.location.href = '/search/search_do/' + queryString;
          }
        },

        _sendAjaxRequest: function(form) {
          var formData = new FormData(form.domElem[0]),
              parentModal = form.findParentBlock(Modal);

          form.setMod('state', 'request');

          /**
           * Для теста верстки
           * Показ модалки спасибки без отправки формы
           */
          if (location.hostname == 'localhost' ||
              location.pathname.indexOf('bundles') !== -1) {

            setTimeout(function() { // server request imitation

              // close own modal
              if (parentModal) {
                parentModal.delMod('visible');
                var goals = parentModal.params.goals;

                if (goals && goals.gtm) {
                  form.params.goals.gtm.position = goals.gtm.position;
                }
              }

              form.sendGoal();
              form.reset();
              form.success();

              // show thanks
              !form.hasMod('no-success-notification') &&
              this._notification.showInfo(form.params.notification);

              form.delMod('state', 'request');

            }.bind(this), 1000);

            return;
          }

          formData.append('user_type', 'user'); // Add anti-SPAM

          $.ajax({
            type: form.domElem.attr('method') || 'POST',
            url: form.domElem.attr('action'),
            data: formData,
            dataType: 'json',
            processData: false,
            contentType: false,

            success: function(data, textStatus, jqXHR) {
              // console.log(data, textStatus, jqXHR);

              form.delMod('state', 'request');

              if (data.success) {
                // close own modal
                if (parentModal) {
                  parentModal.delMod('visible');
                  var goals = parentModal.params.goals;

                  if (goals && goals.gtm) {
                    form.params.goals.gtm.position = goals.gtm.position;
                  }
                }

                form.sendGoal();
                form.reset();
                form.success(data);

                // show thanks
                !form.hasMod('no-success-notification') &&
                this._notification.showInfo(data.text ?
                    {title: data.success, text: data.text} :
                    form.params.notification,
                );
              } else {
                // show error
                this._notification.showInfo(data.text ?
                    {title: data.error, text: data.text} :
                    {title: 'Ошибка', text: data.error},
                );
              }
            }.bind(this),
            error: function(data, textStatus, jqXHR) {
              console.log(data, textStatus, jqXHR);

              form.delMod('state', 'request');

              this._notification.showInfo({
                title: 'Ошибка',
                text: 'При отправке произошла ошибка, обратитесь к администратору сайта или попробуте отправить форму снова',
              });
            }.bind(this),
          });
        },

        /**
         * Получение данных формы для передачи в Form_recipient
         */
        _onTransfer: function(e, values) {
          if (!this._formRecipient) this._formRecipient = this.findChildBlock(
              {block: Form, modName: 'recipient', modVal: true});
          this._formRecipient.setVal(values);
        },

      }, /** @lends forms */ {
        lazyInit: true,
        onInit: function() {
          var ptp = this.prototype;

          this._events(Form).
              on('submit', ptp._onSubmit).
              on('transfer', ptp._onTransfer);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/forms/forms.js */
/* begin: ../../5th.blocks/common.blocks/notification/notification.js */
modules.define('notification',
    ['i-bem-dom', 'jquery', 'modal', 'button', 'notification__modal'],
    function(provide, bemDom, $, Modal, Button, Notification__modal) {

      var DEFAULT_TITLE = 'Спасибо за&nbsp;обращение',
          DEFAULT_MESSAGE = 'В&nbsp;ближайшее время наш менеджер свяжется с&nbsp;вами.',
          DEFAULT_BUTTON = 'Закрыть';

      provide(bemDom.declBlock(this.name, {
        onSetMod: {
          'js': {
            'inited': function() {
              this._info = this.findChildElem('info').findMixedBlock(Modal);
              this._title = this.findChildElem('title');
              this._text = this.findChildElem('text');
              this._button = this.findChildElem('button');

              this._button &&
              (this._buttonText = this._button.findMixedBlock(Button).
                  findChildElem('text'));

              this._events(this.findChildElems(Notification__modal)).
                  on('visibleChange', this._onVisibleChange);
            },
          },
        },

        /**
         * @param {Object} e event
         * @param {Bool} modVal
         */
        _onVisibleChange: function(e, modVal) {
          this.switchScroll(modVal);
        },

        /**
         * Блокировки/разблокировка скролинга страницы
         * @param {Bool} modVal
         */
        switchScroll: function(modVal) {
          this.setMod('active', modVal);
        },

        /**
         * Показ инфо модалки
         * @param {Object} data
         * @param {String} data.title Заголовок
         * @param {String} data.text Текст
         */
        showInfo: function(data) {
          this._title.domElem.html(
              (data && data.title) ? data.title : DEFAULT_TITLE);
          this._text.domElem.html(
              (data && data.text) ? data.text : DEFAULT_MESSAGE);
          this._buttonText && this._buttonText.domElem.text(
              (data && data.button) ? data.button : DEFAULT_BUTTON);
          this._info.setMod('visible', true);
        },
      }, /** @lends notification */ {
        lazyInit: true,
      }));

    });

/* end: ../../5th.blocks/common.blocks/notification/notification.js */
/* begin: ../../node_modules/bem-components/common.blocks/popup/popup.js */
/**
 * @module popup
 */

modules.define(
    'popup',
    ['i-bem-dom'],
    function(provide, bemDom) {

      var ZINDEX_FACTOR = 1000,
          visiblePopupsZIndexes = {},
          undef;

      /**
       * @exports
       * @class popup
       * @bem
       *
       * @param {Number} [zIndexGroupLevel=0] z-index group level
       *
       * @bemmod visible Represents visible state
       */
      provide(bemDom.declBlock(this.name, /** @lends popup.prototype */{
        onSetMod: {
          'js': {
            'inited': function() {
              this._parentPopup = undef;
              this._zIndex = null;
              this._zIndexGroupLevel = null;
              this._isAttachedToScope = false;
            },

            '': function() {
              this.delMod('visible');
            },
          },

          'visible': {
            'true': function() {
              if (!this._isAttachedToScope) {
                bemDom.scope.append(this.domElem);
                this._isAttachedToScope = true;
              }

              this._captureZIndex().
                  _bindToParentPopup().
                  _domEvents().
                  on('pointerpress pointerclick', this._setPreventHideByClick);

              this.domElem.removeAttr('aria-hidden');
            },

            '': function() {
              this._releaseZIndex().
                  _unbindFromParentPopup().
                  _domEvents().
                  un('pointerpress pointerclick', this._setPreventHideByClick);

              this.domElem.attr('aria-hidden', true);
            },
          },
        },

        /**
         * Sets content
         * @param {String|jQuery} content
         * @returns {popup} this
         */
        setContent: function(content) {
          bemDom.update(this.domElem, content);
          return this;
        },

        _calcZIndexGroupLevel: function() {
          var res = this.params.zIndexGroupLevel,
              parentPopup = this._getParentPopup();

          parentPopup && (res += parentPopup._zIndexGroupLevel);

          return res;
        },

        _setPreventHideByClick: function() {
          var curPopup = this;
          do {
            curPopup._preventHideByClick = true;
          } while (curPopup = curPopup._getParentPopup());
        },

        _bindToParentPopup: function() {
          var parentPopup = this._getParentPopup();
          parentPopup &&
          this._events(parentPopup).
              on({modName: 'visible', modVal: ''}, this._onParentPopupHide,
                  this);

          return this;
        },

        _unbindFromParentPopup: function() {
          this._parentPopup && this._events(this._parentPopup).
              un({modName: 'visible', modVal: ''}, this._onParentPopupHide,
                  this);

          this._parentPopup = undef;

          return this;
        },

        _onParentPopupHide: function() {
          this.delMod('visible');
        },

        _getParentPopup: function() {
          return this._parentPopup;
        },

        _captureZIndex: function() {
          var level = this._zIndexGroupLevel === null ?
              this._zIndexGroupLevel = this._calcZIndexGroupLevel() :
              this._zIndexGroupLevel,
              zIndexes = visiblePopupsZIndexes[level] ||
                  (visiblePopupsZIndexes[level] = [
                    (level + 1) * ZINDEX_FACTOR]),
              prevZIndex = this._zIndex;

          this._zIndex = zIndexes[zIndexes.push(zIndexes[zIndexes.length - 1] +
              1) - 1];
          this._zIndex !== prevZIndex &&
          this.domElem.css('z-index', this._zIndex);

          return this;
        },

        _releaseZIndex: function() {
          var zIndexes = visiblePopupsZIndexes[this._zIndexGroupLevel];
          zIndexes.splice(zIndexes.indexOf(this._zIndex), 1);

          return this;
        },

        _recaptureZIndex: function() {
          this._releaseZIndex();
          this._zIndexGroupLevel = null;

          return this._captureZIndex();
        },

        _getDefaultParams: function() {
          return {
            zIndexGroupLevel: 0,
          };
        },
      }, /** @lends popup */{
        lazyInit: true,
      }));

    });

/* end: ../../node_modules/bem-components/common.blocks/popup/popup.js */
/* begin: ../../node_modules/bem-core/common.blocks/functions/__throttle/functions__throttle.vanilla.js */
/**
 * @module functions__throttle
 */

modules.define('functions__throttle', function(provide) {

  var global = this.global;

  provide(
      /**
       * Throttle given function
       * @exports
       * @param {Function} fn function to throttle
       * @param {Number} timeout throttle interval
       * @param {Boolean} [invokeAsap=true] invoke before first interval
       * @param {Object} [ctx] context of function invocation
       * @returns {Function} throttled function
       */
      function(fn, timeout, invokeAsap, ctx) {
        var typeofInvokeAsap = typeof invokeAsap;
        if (typeofInvokeAsap === 'undefined') {
          invokeAsap = true;
        } else if (arguments.length === 3 && typeofInvokeAsap !== 'boolean') {
          ctx = invokeAsap;
          invokeAsap = true;
        }

        var timer, args, needInvoke,
            wrapper = function() {
              if (needInvoke) {
                fn.apply(ctx, args);
                needInvoke = false;
                timer = global.setTimeout(wrapper, timeout);
              } else {
                timer = null;
              }
            };

        return function() {
          args = arguments;
          ctx || (ctx = this);
          needInvoke = true;

          if (!timer) {
            invokeAsap ?
                wrapper() :
                timer = global.setTimeout(wrapper, timeout);
          }
        };
      });

});

/* end: ../../node_modules/bem-core/common.blocks/functions/__throttle/functions__throttle.vanilla.js */
/* begin: ../../node_modules/bem-components/common.blocks/button/button.js */
/**
 * @module button
 */

modules.define(
    'button',
    ['i-bem-dom', 'control', 'jquery', 'dom', 'functions', 'keyboard__codes'],
    function(provide, bemDom, Control, $, dom, functions, keyCodes) {

      /**
       * @exports
       * @class button
       * @augments control
       * @bem
       */
      provide(
          bemDom.declBlock(this.name, Control, /** @lends button.prototype */{
            beforeSetMod: {
              'pressed': {
                'true': function() {
                  return !this.hasMod('disabled') || this.hasMod('togglable');
                },
              },

              'focused': {
                '': function() {
                  return !this._isPointerPressInProgress;
                },
              },
            },

            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);
                  this._isPointerPressInProgress = false;
                  this._focusedByPointer = false;
                },
              },

              'disabled': {
                'true': function() {
                  this.__base.apply(this, arguments);
                  this.hasMod('togglable') || this.delMod('pressed');
                  this.domElem.attr('aria-disabled', true);
                },
                '': function() {
                  this.__base.apply(this, arguments);
                  this.domElem.removeAttr('aria-disabled');
                },
              },

              'focused': {
                'true': function() {
                  this.__base.apply(this, arguments);
                  this._focusedByPointer || this.setMod('focused-hard');
                },

                '': function() {
                  this.__base.apply(this, arguments);
                  this.delMod('focused-hard');
                },
              },
            },

            /**
             * Returns text of the button
             * @returns {String}
             */
            getText: function() {
              return this._elem('text').domElem.text();
            },

            /**
             * Sets text to the button
             * @param {String} text
             * @returns {button} this
             */
            setText: function(text) {
              this._elem('text').domElem.text(text || '');
              return this;
            },

            _onFocus: function() {
              if (this._isPointerPressInProgress) return;

              this.__base.apply(this, arguments);
              this._domEvents('control').on('keydown', this._onKeyDown);
            },

            _onBlur: function() {
              this._domEvents('control').un('keydown', this._onKeyDown);
              this.__base.apply(this, arguments);
            },

            _onMouseDown: function(e) {
              e.preventDefault(); // NOTE: prevents button from being blurred at least in FF and Safari
              this._domEvents().un('mousedown', this._onMouseDown);
            },

            _onPointerPress: function() {
              this._domEvents().on('mousedown', this._onMouseDown);
              if (!this.hasMod('disabled')) {
                this._isPointerPressInProgress = true;
                this._domEvents(bemDom.doc).
                    on('pointerrelease', this._onPointerRelease);
                this.setMod('pressed');
              }
            },

            _onPointerRelease: function(e) {
              this._isPointerPressInProgress = false;
              this._domEvents(bemDom.doc).
                  un('pointerrelease', this._onPointerRelease);

              if (e.originalEvent.type === 'pointerup' &&
                  dom.contains(this.findMixedElem('control').domElem,
                      $(e.target))) {
                this._focusedByPointer = true;
                this._focus();
                this._focusedByPointer = false;
                this._domEvents().once('pointerclick', this._onPointerClick);
              } else {
                this._blur();
              }

              this.delMod('pressed');
            },

            _onPointerClick: function() {
              this._updateChecked()._emit('click');
            },

            _onKeyDown: function(e) {
              if (this.hasMod('disabled')) return;

              var keyCode = e.keyCode;
              if (keyCode === keyCodes.SPACE || keyCode === keyCodes.ENTER) {
                this._domEvents('control').
                    un('keydown', this._onKeyDown).
                    on('keyup', this._onKeyUp);

                this._updateChecked().setMod('pressed');
              }
            },

            _onKeyUp: function(e) {
              this._domEvents('control').
                  un('keyup', this._onKeyUp).
                  on('keydown', this._onKeyDown);

              this.delMod('pressed');

              e.keyCode === keyCodes.SPACE && this._doAction();

              this._emit('click');
            },

            _updateChecked: function() {
              this.hasMod('togglable') &&
              (this.hasMod('togglable', 'check') ?
                  this.toggleMod('checked') :
                  this.setMod('checked'));

              return this;
            },

            _doAction: functions.noop,
          }, /** @lends button */{
            lazyInit: true,
            onInit: function() {
              this._domEvents('control').
                  on('pointerpress', this.prototype._onPointerPress);
              return this.__base.apply(this, arguments);
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/button/button.js */
/* begin: ../../node_modules/bem-core/common.blocks/jquery/__event/_type/jquery__event_type_pointerclick.js */
modules.define('jquery', ['next-tick'], function(provide, nextTick, $) {

  var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
      event = $.event.special.pointerclick = {
        setup: function() {
          if (isIOS) {
            $(this).
                on('pointerdown', event.onPointerdown).
                on('pointerup', event.onPointerup).
                on('pointerleave pointercancel', event.onPointerleave);
          } else {
            $(this).on('click', event.handler);
          }
        },

        teardown: function() {
          if (isIOS) {
            $(this).
                off('pointerdown', event.onPointerdown).
                off('pointerup', event.onPointerup).
                off('pointerleave pointercancel', event.onPointerleave);
          } else {
            $(this).off('click', event.handler);
          }
        },

        handler: function(e) {
          if (!e.button) {
            var type = e.type;
            e.type = 'pointerclick';
            $.event.dispatch.apply(this, arguments);
            e.type = type;
          }
        },

        onPointerdown: function(e) {
          pointerdownEvent = e;
        },

        onPointerleave: function() {
          pointerdownEvent = null;
        },

        onPointerup: function(e) {
          if (!pointerdownEvent) return;

          if (!pointerDownUpInProgress) {
            nextTick(function() {
              pointerDownUpInProgress = false;
              pointerdownEvent = null;
            });
            pointerDownUpInProgress = true;
          }

          event.handler.apply(this, arguments);
        },
      },
      pointerDownUpInProgress = false,
      pointerdownEvent;

  provide($);

});

/* end: ../../node_modules/bem-core/common.blocks/jquery/__event/_type/jquery__event_type_pointerclick.js */
/* begin: ../../5th.blocks/common.blocks/jquery/__event/_type/jquery__event_type_pointerclick.js */
modules.define('jquery', ['next-tick'], function(provide, nextTick, $) {

  var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,
      event = $.event.special.pointerclick = {
        setup: function() {
          $(this).on('click', event.handler);
        },

        teardown: function() {
          $(this).off('click', event.handler);
        },

        handler: function(e) {
          if (!e.button) {
            var type = e.type;
            e.type = 'pointerclick';
            $.event.dispatch.apply(this, arguments);
            e.type = type;
          }
        },

        onPointerdown: function(e) {
          pointerdownEvent = e;
        },

        onPointerleave: function() {
          pointerdownEvent = null;
        },

        onPointerup: function(e) {
          if (!pointerdownEvent) return;

          if (!pointerDownUpInProgress) {
            nextTick(function() {
              pointerDownUpInProgress = false;
              pointerdownEvent = null;
            });
            pointerDownUpInProgress = true;
          }

          event.handler.apply(this, arguments);
        },
      },
      pointerDownUpInProgress = false,
      pointerdownEvent;

  provide($);

});

/* end: ../../5th.blocks/common.blocks/jquery/__event/_type/jquery__event_type_pointerclick.js */
/* begin: ../../node_modules/bem-core/common.blocks/jquery/__event/_type/jquery__event_type_pointernative.js */
;(function(global, factory) {

  if (typeof modules === 'object' && modules.isDefined('jquery')) {
    modules.define('jquery', function(provide, $) {
      factory(this.global, $);
      provide($);
    });
  } else if (typeof jQuery === 'function') {
    factory(global, jQuery);
  }

}(this, function(window, $) {

  var jqEvent = $.event;

// NOTE: Remove jQuery special fixes for pointerevents – we fix them ourself
  delete jqEvent.special.pointerenter;
  delete jqEvent.special.pointerleave;

  if (window.PointerEvent) {
    // Have native PointerEvent support, nothing to do than
    return;
  }

  /*!
 * Most of source code is taken from PointerEvents Polyfill
 * written by Polymer Team (https://github.com/Polymer/PointerEvents)
 * and licensed under the BSD License.
 */

  var doc = document,
      HAS_BITMAP_TYPE = window.MSPointerEvent &&
          typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number',
      undef;

  /*!
 * Returns a snapshot of the event, with writable properties.
 *
 * @param {Event} event An event that contains properties to copy.
 * @returns {Object} An object containing shallow copies of `inEvent`'s properties.
 */
  function cloneEvent(event) {
    var eventCopy = $.extend(new $.Event(), event);
    if (event.preventDefault) {
      eventCopy.preventDefault = function() {
        event.preventDefault();
      };
    }
    return eventCopy;
  }

  /*!
 * Dispatches the event to the target, taking event's bubbling into account.
 */
  function dispatchEvent(event, target) {
    return event.bubbles ?
        jqEvent.trigger(event, null, target) :
        jqEvent.dispatch.call(target, event);
  }

  var MOUSE_PROPS = {
        bubbles: false,
        cancelable: false,
        view: null,
        detail: null,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        metaKey: false,
        button: 0,
        relatedTarget: null,
        pageX: 0,
        pageY: 0,
      },
      mouseProps = Object.keys(MOUSE_PROPS),
      mousePropsLen = mouseProps.length,
      mouseDefaults = mouseProps.map(function(prop) {
        return MOUSE_PROPS[prop];
      });

  /*!
 * Pointer event constructor
 *
 * @class PointerEvent
 * @param {String} type
 * @param {Object} [params]
 * @returns {Event}
 * @constructor
 */
  function PointerEvent(type, params) {
    params || (params = {});

    var e = $.Event(type);

    // define inherited MouseEvent properties
    for (var i = 0, p; i < mousePropsLen; i++) {
      p = mouseProps[i];
      e[p] = params[p] || mouseDefaults[i];
    }

    e.buttons = params.buttons || 0;

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;
    if (params.pressure) {
      pressure = params.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // define the properties of the PointerEvent interface
    e.pointerId = params.pointerId || 0;
    e.width = params.width || 0;
    e.height = params.height || 0;
    e.pressure = pressure;
    e.tiltX = params.tiltX || 0;
    e.tiltY = params.tiltY || 0;
    e.pointerType = params.pointerType || '';
    e.hwTimestamp = params.hwTimestamp || 0;
    e.isPrimary = params.isPrimary || false;

    // add some common jQuery properties
    e.which = typeof params.which === 'undefined' ? 1 : params.which;

    return e;
  }

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undef) {
        return this['delete'](k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },

    has: function(k) {
      return this.array[k] !== undef;
    },

    'delete': function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },

    get: function(k) {
      return this.array[k];
    },

    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, ctx) {
      return this.array.forEach(function(v, k) {
        callback.call(ctx, v, k, this);
      }, this);
    },
  };

// jscs:disable requireMultipleVarDecl
  var PointerMap = window.Map && window.Map.prototype.forEach ?
      Map :
      SparseArrayMap,
      pointerMap = new PointerMap();

  var dispatcher = {
    eventMap: {},
    eventSourceList: [],

    /*!
     * Add a new event source that will generate pointer events
     */
    registerSource: function(name, source) {
      var newEvents = source.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          source[e] && (this.eventMap[e] = function() {
            source[e].apply(source, arguments);
          });
        }, this);
        this.eventSourceList.push(source);
      }
    },

    register: function(element) {
      var len = this.eventSourceList.length;
      for (var i = 0, es; (i < len) && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.register.call(es, element);
      }
    },

    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {
        // call eventsource register
        es.unregister.call(es, element);
      }
    },

    down: function(event) {
      event.bubbles = true;
      this.fireEvent('pointerdown', event);
    },

    move: function(event) {
      event.bubbles = true;
      this.fireEvent('pointermove', event);
    },

    up: function(event) {
      event.bubbles = true;
      this.fireEvent('pointerup', event);
    },

    enter: function(event) {
      event.bubbles = false;
      this.fireEvent('pointerenter', event);
    },

    leave: function(event) {
      event.bubbles = false;
      this.fireEvent('pointerleave', event);
    },

    over: function(event) {
      event.bubbles = true;
      this.fireEvent('pointerover', event);
    },

    out: function(event) {
      event.bubbles = true;
      this.fireEvent('pointerout', event);
    },

    cancel: function(event) {
      event.bubbles = true;
      this.fireEvent('pointercancel', event);
    },

    leaveOut: function(event) {
      this.out(event);
      this.enterLeave(event, this.leave);
    },

    enterOver: function(event) {
      this.over(event);
      this.enterLeave(event, this.enter);
    },

    enterLeave: function(event, fn) {
      var target = event.target,
          relatedTarget = event.relatedTarget;

      if (!this.contains(target, relatedTarget)) {
        while (target && target !== relatedTarget) {
          event.target = target;
          fn.call(this, event);

          target = target.parentNode;
        }
      }
    },

    contains: function(target, relatedTarget) {
      return target === relatedTarget || $.contains(target, relatedTarget);
    },

    // LISTENER LOGIC
    eventHandler: function(e) {
      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (e._handledByPE) {
        return;
      }

      var type = e.type, fn;
      (fn = this.eventMap && this.eventMap[type]) && fn(e);

      e._handledByPE = true;
    },

    /*!
     * Sets up event listeners
     */
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    /*!
     * Removes event listeners
     */
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },

    addEvent: function(target, eventName) {
      $(target).on(eventName, boundHandler);
    },

    removeEvent: function(target, eventName) {
      $(target).off(eventName, boundHandler);
    },

    getTarget: function(event) {
      return event._target;
    },

    /*!
     * Creates a new Event of type `type`, based on the information in `event`
     */
    makeEvent: function(type, event) {
      var e = new PointerEvent(type, event);
      if (event.preventDefault) {
        e.preventDefault = event.preventDefault;
      }

      e._target = e._target || event.target;

      return e;
    },

    /*!
     * Dispatches the event to its target
     */
    dispatchEvent: function(event) {
      var target = this.getTarget(event);
      if (target) {
        if (!event.target) {
          event.target = target;
        }

        return dispatchEvent(event, target);
      }
    },

    /*!
     * Makes and dispatch an event in one call
     */
    fireEvent: function(type, event) {
      var e = this.makeEvent(type, event);
      return this.dispatchEvent(e);
    },
  };

  function boundHandler() {
    dispatcher.eventHandler.apply(dispatcher, arguments);
  }

  var CLICK_COUNT_TIMEOUT = 200,
      // Radius around touchend that swallows mouse events
      MOUSE_DEDUP_DIST = 25,
      MOUSE_POINTER_ID = 1,
      // This should be long enough to ignore compat mouse events made by touch
      TOUCH_DEDUP_TIMEOUT = 2500,
      // A distance for which touchmove should fire pointercancel event
      TOUCHMOVE_HYSTERESIS = 20;

// handler block for native mouse events
  var mouseEvents = {
    POINTER_TYPE: 'mouse',
    events: [
      'mousedown',
      'mousemove',
      'mouseup',
      'mouseover',
      'mouseout',
    ],

    register: function(target) {
      dispatcher.listen(target, this.events);
    },

    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },

    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(event) {
      var lts = this.lastTouches,
          x = event.clientX,
          y = event.clientY;

      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= MOUSE_DEDUP_DIST && dy <= MOUSE_DEDUP_DIST) {
          return true;
        }
      }
    },

    prepareEvent: function(event) {
      var e = cloneEvent(event);
      e.pointerId = MOUSE_POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },

    mousedown: function(event) {
      if (!this.isEventSimulatedFromTouch(event)) {
        if (pointerMap.has(MOUSE_POINTER_ID)) {
          // http://crbug/149091
          this.cancel(event);
        }

        pointerMap.set(MOUSE_POINTER_ID, event);

        var e = this.prepareEvent(event);
        dispatcher.down(e);
      }
    },

    mousemove: function(event) {
      if (!this.isEventSimulatedFromTouch(event)) {
        var e = this.prepareEvent(event);
        dispatcher.move(e);
      }
    },

    mouseup: function(event) {
      if (!this.isEventSimulatedFromTouch(event)) {
        var p = pointerMap.get(MOUSE_POINTER_ID);
        if (p && p.button === event.button) {
          var e = this.prepareEvent(event);
          dispatcher.up(e);
          this.cleanupMouse();
        }
      }
    },

    mouseover: function(event) {
      if (!this.isEventSimulatedFromTouch(event)) {
        var e = this.prepareEvent(event);
        dispatcher.enterOver(e);
      }
    },

    mouseout: function(event) {
      if (!this.isEventSimulatedFromTouch(event)) {
        var e = this.prepareEvent(event);
        dispatcher.leaveOut(e);
      }
    },

    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanupMouse();
    },

    cleanupMouse: function() {
      pointerMap['delete'](MOUSE_POINTER_ID);
    },
  };

  var touchEvents = {
    events: [
      'touchstart',
      'touchmove',
      'touchend',
      'touchcancel',
    ],

    register: function(target) {
      dispatcher.listen(target, this.events);
    },

    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },

    POINTER_TYPE: 'touch',
    clickCount: 0,
    resetId: null,
    firstTouch: null,

    isPrimaryTouch: function(touch) {
      return this.firstTouch === touch.identifier;
    },

    /*!
     * Sets primary touch if there no pointers, or the only pointer is the mouse
     */
    setPrimaryTouch: function(touch) {
      if (pointerMap.size === 0 ||
          (pointerMap.size === 1 && pointerMap.has(MOUSE_POINTER_ID))) {
        this.firstTouch = touch.identifier;
        this.firstXY = {X: touch.clientX, Y: touch.clientY};
        this.scrolling = null;

        this.cancelResetClickCount();
      }
    },

    removePrimaryPointer: function(pointer) {
      if (pointer.isPrimary) {
        this.firstTouch = null;
        // TODO(@narqo): It seems that, flushing `firstXY` flag explicitly in `touchmove` handler is enough.
        // Original code from polymer doing `this.firstXY = null` on every `removePrimaryPointer` call, but looks
        // like it is harmful in some of our usecases.
        this.resetClickCount();
      }
    },

    resetClickCount: function() {
      var _this = this;
      this.resetId = setTimeout(function() {
        _this.clickCount = 0;
        _this.resetId = null;
      }, CLICK_COUNT_TIMEOUT);
    },

    cancelResetClickCount: function() {
      this.resetId && clearTimeout(this.resetId);
    },

    typeToButtons: function(type) {
      return type === 'touchstart' || type === 'touchmove' ? 1 : 0;
    },

    findTarget: function(event) {
      // Currently we don't interested in shadow dom handling
      return doc.elementFromPoint(event.clientX, event.clientY);
    },

    touchToPointer: function(touch) {
      var cte = this.currentTouchEvent,
          e = cloneEvent(touch);

      // Spec specifies that pointerId 1 is reserved for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      e.pointerId = touch.identifier + 2;
      e.target = this.findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = touch.webkitRadiusX || touch.radiusX || 0;
      e.height = touch.webkitRadiusY || touch.radiusY || 0;
      e.pressure = touch.mozPressure || touch.webkitForce || touch.force || 0.5;
      e.isPrimary = this.isPrimaryTouch(touch);
      e.pointerType = this.POINTER_TYPE;

      // forward touch preventDefaults
      var _this = this;
      e.preventDefault = function() {
        _this.scrolling = false;
        _this.firstXY = null;
        cte.preventDefault();
      };

      return e;
    },

    processTouches: function(event, fn) {
      var tl = event.originalEvent.changedTouches;
      this.currentTouchEvent = event;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        fn.call(this, this.touchToPointer(t));
      }
    },

    shouldScroll: function(touchEvent) {
      // return "true" for things to be much easier
      return true;
    },

    findTouch: function(touches, pointerId) {
      for (var i = 0, l = touches.length, t; i < l && (t = touches[i]); i++) {
        if (t.identifier === pointerId) {
          return true;
        }
      }
    },

    /*!
     * In some instances, a touchstart can happen without a touchend.
     * This leaves the pointermap in a broken state.
     * Therefore, on every touchstart, we remove the touches
     * that did not fire a touchend event.
     *
     * To keep state globally consistent, we fire a pointercancel
     * for this "abandoned" touch
     */
    vacuumTouches: function(touchEvent) {
      var touches = touchEvent.touches;
      // `pointermap.size` should be less than length of touches here, as the touchstart has not
      // been processed yet.
      if (pointerMap.size >= touches.length) {
        var d = [];

        pointerMap.forEach(function(pointer, pointerId) {
          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (pointerId === MOUSE_POINTER_ID ||
              this.findTouch(touches, pointerId - 2)) return;
          d.push(pointer.outEvent);
        }, this);

        d.forEach(this.cancelOut, this);
      }
    },

    /*!
     * Prevents synth mouse events from creating pointer events
     */
    dedupSynthMouse: function(touchEvent) {
      var lts = mouseEvents.lastTouches,
          t = touchEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = {x: t.clientX, y: t.clientY};
        lts.push(lt);

        setTimeout(function() {
          var i = lts.indexOf(lt);
          i > -1 && lts.splice(i, 1);
        }, TOUCH_DEDUP_TIMEOUT);
      }
    },

    touchstart: function(event) {
      var touchEvent = event.originalEvent;

      this.vacuumTouches(touchEvent);
      this.setPrimaryTouch(touchEvent.changedTouches[0]);
      this.dedupSynthMouse(touchEvent);

      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(event, this.overDown);
      }
    },

    touchmove: function(event) {
      var touchEvent = event.originalEvent;
      if (!this.scrolling) {
        if (this.scrolling === null && this.shouldScroll(touchEvent)) {
          this.scrolling = true;
        } else {
          event.preventDefault();
          this.processTouches(event, this.moveOverOut);
        }
      } else if (this.firstXY) {
        var firstXY = this.firstXY,
            touch = touchEvent.changedTouches[0],
            dx = touch.clientX - firstXY.X,
            dy = touch.clientY - firstXY.Y,
            dd = Math.sqrt(dx * dx + dy * dy);
        if (dd >= TOUCHMOVE_HYSTERESIS) {
          this.touchcancel(event);
          this.scrolling = true;
          this.firstXY = null;
        }
      }
    },

    touchend: function(event) {
      var touchEvent = event.originalEvent;
      this.dedupSynthMouse(touchEvent);
      this.processTouches(event, this.upOut);
    },

    touchcancel: function(event) {
      this.processTouches(event, this.cancelOut);
    },

    overDown: function(pEvent) {
      var target = pEvent.target;
      pointerMap.set(pEvent.pointerId, {
        target: target,
        outTarget: target,
        outEvent: pEvent,
      });
      dispatcher.over(pEvent);
      dispatcher.enter(pEvent);
      dispatcher.down(pEvent);
    },

    moveOverOut: function(pEvent) {
      var pointer = pointerMap.get(pEvent.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }

      dispatcher.move(pEvent);

      var outEvent = pointer.outEvent,
          outTarget = pointer.outTarget;

      if (outEvent && outTarget !== pEvent.target) {
        pEvent.relatedTarget = outTarget;
        outEvent.relatedTarget = pEvent.target;
        // recover from retargeting by shadow
        outEvent.target = outTarget;

        if (pEvent.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(pEvent);
        } else {
          // clean up case when finger leaves the screen
          pEvent.target = outTarget;
          pEvent.relatedTarget = null;
          this.cancelOut(pEvent);
        }
      }

      pointer.outEvent = pEvent;
      pointer.outTarget = pEvent.target;
    },

    upOut: function(pEvent) {
      dispatcher.up(pEvent);
      dispatcher.out(pEvent);
      dispatcher.leave(pEvent);

      this.cleanUpPointer(pEvent);
    },

    cancelOut: function(pEvent) {
      dispatcher.cancel(pEvent);
      dispatcher.out(pEvent);
      dispatcher.leave(pEvent);
      this.cleanUpPointer(pEvent);
    },

    cleanUpPointer: function(pEvent) {
      pointerMap['delete'](pEvent.pointerId);
      this.removePrimaryPointer(pEvent);
    },
  };

  var msEvents = {
    events: [
      'MSPointerDown',
      'MSPointerMove',
      'MSPointerUp',
      'MSPointerOut',
      'MSPointerOver',
      'MSPointerCancel',
    ],

    register: function(target) {
      dispatcher.listen(target, this.events);
    },

    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },

    POINTER_TYPES: [
      '',
      'unavailable',
      'touch',
      'pen',
      'mouse',
    ],

    prepareEvent: function(event) {
      var e = cloneEvent(event);
      HAS_BITMAP_TYPE &&
      (e.pointerType = this.POINTER_TYPES[event.pointerType]);
      return e;
    },

    MSPointerDown: function(event) {
      pointerMap.set(event.pointerId, event);
      var e = this.prepareEvent(event);
      dispatcher.down(e);
    },

    MSPointerMove: function(event) {
      var e = this.prepareEvent(event);
      dispatcher.move(e);
    },

    MSPointerUp: function(event) {
      var e = this.prepareEvent(event);
      dispatcher.up(e);
      this.cleanup(event.pointerId);
    },

    MSPointerOut: function(event) {
      var e = this.prepareEvent(event);
      dispatcher.leaveOut(e);
    },

    MSPointerOver: function(event) {
      var e = this.prepareEvent(event);
      dispatcher.enterOver(e);
    },

    MSPointerCancel: function(event) {
      var e = this.prepareEvent(event);
      dispatcher.cancel(e);
      this.cleanup(event.pointerId);
    },

    cleanup: function(id) {
      pointerMap['delete'](id);
    },
  };

  var navigator = window.navigator;
  if (navigator.msPointerEnabled) {
    dispatcher.registerSource('ms', msEvents);
  } else {
    dispatcher.registerSource('mouse', mouseEvents);
    if (typeof window.ontouchstart !== 'undefined') {
      dispatcher.registerSource('touch', touchEvents);
    }
  }

  dispatcher.register(doc);

}));

/* end: ../../node_modules/bem-core/common.blocks/jquery/__event/_type/jquery__event_type_pointernative.js */
/* begin: ../../node_modules/bem-core/common.blocks/keyboard/__codes/keyboard__codes.js */
/**
 * @module keyboard__codes
 */
modules.define('keyboard__codes', function(provide) {

  provide(/** @exports */{
    /** @type {Number} */
    BACKSPACE: 8,
    /** @type {Number} */
    TAB: 9,
    /** @type {Number} */
    ENTER: 13,
    /** @type {Number} */
    CAPS_LOCK: 20,
    /** @type {Number} */
    ESC: 27,
    /** @type {Number} */
    SPACE: 32,
    /** @type {Number} */
    PAGE_UP: 33,
    /** @type {Number} */
    PAGE_DOWN: 34,
    /** @type {Number} */
    END: 35,
    /** @type {Number} */
    HOME: 36,
    /** @type {Number} */
    LEFT: 37,
    /** @type {Number} */
    UP: 38,
    /** @type {Number} */
    RIGHT: 39,
    /** @type {Number} */
    DOWN: 40,
    /** @type {Number} */
    INSERT: 45,
    /** @type {Number} */
    DELETE: 46,
  });

});

/* end: ../../node_modules/bem-core/common.blocks/keyboard/__codes/keyboard__codes.js */
/* begin: ../../node_modules/bem-components/common.blocks/control/control.js */
/**
 * @module control
 */

modules.define(
    'control',
    ['i-bem-dom', 'dom', 'next-tick'],
    function(provide, bemDom, dom, nextTick) {

      /**
       * @exports
       * @class control
       * @abstract
       * @bem
       */
      provide(bemDom.declBlock(this.name, /** @lends control.prototype */{
        beforeSetMod: {
          'focused': {
            'true': function() {
              return !this.hasMod('disabled');
            },
          },
        },

        onSetMod: {
          'js': {
            'inited': function() {
              var controlDomElem = this._elem('control').domElem;

              this._focused = dom.containsFocus(controlDomElem);
              this._focused ?
                  // if control is already in focus, we need to force _onFocus
                  this._onFocus() :
                  // if block already has focused mod, we need to focus control
                  this.hasMod('focused') && this._focus();

              this._tabIndex = typeof this.params.tabIndex !== 'undefined' ?
                  this.params.tabIndex :
                  controlDomElem.attr('tabindex');

              if (this.hasMod('disabled') && this._tabIndex !== 'undefined')
                controlDomElem.removeAttr('tabindex');
            },
          },

          'focused': {
            'true': function() {
              this._focused || this._focus();
            },

            '': function() {
              this._focused && this._blur();
            },
          },

          'disabled': {
            'true': function() {
              this._elem('control').domElem.attr('disabled', true);
              this.delMod('focused');
              typeof this._tabIndex !== 'undefined' &&
              this._elem('control').domElem.removeAttr('tabindex');
            },

            '': function() {
              this._elem('control').domElem.removeAttr('disabled');
              typeof this._tabIndex !== 'undefined' &&
              this._elem('control').domElem.attr('tabindex', this._tabIndex);
            },
          },
        },

        /**
         * Returns name of control
         * @returns {String}
         */
        getName: function() {
          return this._elem('control').domElem.attr('name') || '';
        },

        /**
         * Returns control value
         * @returns {String}
         */
        getVal: function() {
          return this._elem('control').domElem.val();
        },

        _onFocus: function() {
          this._focused = true;
          this.setMod('focused');
        },

        _onBlur: function() {
          this._focused = false;
          this.delMod('focused');
        },

        _focus: function() {
          dom.isFocusable(this._elem('control').domElem) ?
              this._elem('control').domElem.focus() :
              this._onFocus(); // issues/1456
        },

        _blur: function() {
          // force both `blur` and `_onBlur` for FF which can have disabled element as `document.activeElement`
          this._elem('control').domElem.blur();
          this._onBlur();
        },
      }, /** @lends control */{
        lazyInit: true,
        onInit: function() {
          this._domEvents('control').on('focusin', function() {
            this._focused || this._onFocus(); // to prevent double call of _onFocus in case of init by focus
          }).on('focusout', this.prototype._onBlur);

          var focused = dom.getFocused();
          if (focused.hasClass(this._buildClassName('control'))) {
            var _this = this;
            nextTick(function() {
              if (focused[0] === dom.getFocused()[0]) {
                var block = focused.closest(_this._buildSelector());
                block && block.bem(_this);
              }
            });
          }
        },
      }));

    });

/* end: ../../node_modules/bem-components/common.blocks/control/control.js */
/* begin: ../../node_modules/bem-components/desktop.blocks/control/control.js */
/** @module control */

modules.define(
    'control', ['i-bem-dom'],
    function(provide, bemDom, Control) {

      provide(bemDom.declBlock(Control, {
        beforeSetMod: {
          'hovered': {
            'true': function() {
              return !this.hasMod('disabled');
            },
          },
        },

        onSetMod: {
          'disabled': {
            'true': function() {
              this.__base.apply(this, arguments);
              this.delMod('hovered');
            },
          },

          'hovered': {
            'true': function() {
              this._domEvents().on('mouseleave', this._onMouseLeave);
            },

            '': function() {
              this._domEvents().un('mouseleave', this._onMouseLeave);
            },
          },
        },

        _onMouseOver: function() {
          this.setMod('hovered');
        },

        _onMouseLeave: function() {
          this.delMod('hovered');
        },
      }, {
        onInit: function() {
          this._domEvents().on('mouseover', this.prototype._onMouseOver);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../node_modules/bem-components/desktop.blocks/control/control.js */
/* begin: ../../5th.blocks/common.blocks/control/control.js */
/**
 * @module control
 */

modules.define(
    'control',
    ['i-bem-dom', 'dom', 'next-tick'],
    function(provide, bemDom, dom, nextTick, Control) {

      /**
       * @exports
       * @class control
       * @abstract
       * @bem
       */
      provide(bemDom.declBlock(Control, {
        onSetMod: {
          'readonly': {
            'true': function() {
              this._elem('control').domElem.attr('readonly', true);
              this.delMod('focused');
              typeof this._tabIndex !== 'undefined' &&
              this._elem('control').domElem.removeAttr('tabindex');
            },

            '': function() {
              this._elem('control').domElem.removeAttr('readonly');
              typeof this._tabIndex !== 'undefined' &&
              this._elem('control').domElem.attr('tabindex', this._tabIndex);
            },
          },
        },

      }));

    });

/* end: ../../5th.blocks/common.blocks/control/control.js */
/* begin: ../../5th.blocks/common.blocks/notification/__modal/notification__modal.js */
modules.define('notification__modal', ['i-bem-dom', 'modal'],
    function(provide, bemDom, Modal) {

      provide(bemDom.declElem('notification', 'modal', {
        onSetMod: {
          'js': {
            'inited': function() {
              this._modal = this.findMixedBlock(Modal);
              this._events(this._modal).
                  on({modName: 'visible', modVal: '*'},
                      this._onModalVisibleChange);
            },
          },
        },

        _onModalVisibleChange: function() {
          this._emit('visibleChange', this._modal.hasMod('visible'));
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/notification/__modal/notification__modal.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form/form.browser.js */
/**
 * @module form
 */
modules.define('form',
    ['i-bem-dom', 'objects', 'form-field', 'button', 'vow', 'next-tick'],
    function(provide, bemDom, objects, FormField, Button, Vow, nextTick) {
      /**
       * Form declaration
       */
      provide(bemDom.declBlock(this.name, /** @lends form.prototype */{
        onSetMod: {
          'js': {
            'inited': function() {
              this._changeStorage = null;
              this.hasMod('disabled') && this._toggleDisableFields('disabled');

              this._initVal = this.getVal();
              this._status = this.getStatus();
            },
          },

          'disabled': this._toggleDisableFields,
        },
        /**
         * Toggle all fields disabled mod
         */
        _toggleDisableFields: function(modName, modVal) {
          this.getFields().forEach(function(field) {
            field.setMod(modName, modVal);
          });

          var btn = this.findChildBlock(
              {block: Button, modName: 'type', modVal: 'submit'});
          btn && btn.setMod(modName, modVal);
        },
        /**
         * Bind to fields events
         */
        _bindToFields: function(eventName, fn) {
          this.getFields().forEach(function(field) {
            field._events().on(eventName, fn, this);
          }.bind(this));
        },
        /**
         * Returns all fields inside form
         * @type {Array}
         */
        getFields: function() {
          return this.findChildBlocks(FormField);
        },
        /**
         * Returns field by name
         * Work only with simple names or with camelCase names
         * @param {String} name
         * @returns {Object}
         */
        getFieldByName: function(name) {
          return this.domElem.find('[data-name=' + name + ']').bem(FormField);
        },
        /**
         * Returns serialized form data
         * @returns {Object}
         */
        getVal: function() {
          return this.getFields().reduce(function(res, field) {
            var name = field.getName();
            if (name) res[name] = field.getVal();
            return res;
          }, {});
        },
        /**
         * Fills form fields with passed data
         * @param {Object} [val] - data (params.fillData by default)
         */
        setVal: function(val) {
          var storage = this._changeStorage = {};

          this.getFields().forEach(function(field) {
            field.setVal(val[field.getName()]);
          });

          nextTick(function() {
            if (!objects.isEmpty(storage)) this._emit('change', storage);
            this._changeStorage = null;
          });
        },
        /**
         * Field change event handler
         * @abstract
         * @private
         * @param {Event} event
         */
        _onFieldChange: function() {
          this._emit('change', this.getVal());
        },
        /**
         * Field focus event handler
         * @abstract
         * @private
         * @param {Event} event
         */
        _onFieldFocus: function() {
          this._emit('focus', this.getVal());
        },
        /**
         * onSubmit event handler
         *
         * @private
         * @param {Event} e
         */
        _onSubmit: function(e) {
          e.preventDefault();
          this._emit('submit', this.getVal());
        },
        /**
         * Get all invalid form-fields
         *
         * @public
         * @returns {Promise}
         */
        getInvalidFields: function() {
          var currentFields = this.getFields(),
              invalid = [];

          return Vow.all(currentFields.map(function(field) {
            return field.getStatus();
          })).then(function(fieldsStatuses) {
            for (var i = 0, l = fieldsStatuses.length; i < l; i++) {
              fieldsStatuses[i] !== null && invalid.push(currentFields.get(i));
            }
            return invalid;
          });
        },
        /**
         * Get form status
         *
         * @public
         * @returns {String|Boolean}
         */
        getStatus: function() {
          return this._status;
        },
        /**
         * Set form status
         *
         * @public
         * @returns {String|Boolean}
         */
        setStatus: function(status) {
          this._status = status;
          this._updateStatus(status);
          return this._status;
        },
        /**
         * Check form validation state
         *
         * @public
         * @returns {Promise}
         */
        validate: function() {
          var currentFields = this.getFields();
          return Vow.all(currentFields.map(function(field) {
            return field.validate();
          })).then(function(fieldsStatuses) {
            this._updateStatus(fieldsStatuses);
            return fieldsStatuses;
          }.bind(this));
        },
        /**
         * Update form modifier `invalid` according to current validity state.
         *
         * @protected
         */
        _updateStatus: function(fieldsStatuses) {
          var st;
          if (fieldsStatuses.length) {
            st = this.checkFields(fieldsStatuses);
          } else {
            st = fieldsStatuses;
          }

          this.toggleMod('invalid', true, !st);
          this._status = st;
        },

        checkFields: function(fieldsStatuses) {
          var st = true;
          for (var i = 0, l = fieldsStatuses.length; i < l; i++) {
            if (fieldsStatuses[i] !== null) {
              st = false;
            }
          }

          return st;
        },
      }, /** @lends form */{
        lazyInit: true,

        onInit: function() {
          var ptp = this.prototype;
          this._domEvents().on('submit', ptp._onSubmit);
          this._events(FormField).
              on('change', ptp._onFieldChange).
              on('focus', ptp._onFieldFocus);
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form/form.browser.js */
/* begin: ../../5th.blocks/common.blocks/form/form.js */
modules.define('form', ['i-bem-dom', 'button'],
    function(provide, bemDom, Button, Form) {

      /**
       * @exports
       * @class form
       */
      provide(bemDom.declBlock(Form, {

        onSetMod: {
          'js': {
            'inited': function() {
              this.__base.apply(this, arguments);
              this._buttonSubmit = this.findChildBlock(
                  {block: Button, modName: 'has-spin', modVal: true});
            },
          },

          'state': function(modName, modVal, oldModVal) {
            this._buttonSubmit &&
            this._setButtonRequestState(modVal == 'request');
          },
        },

        /**
         * @param {Bool} modVal
         */
        _setButtonRequestState: function(modVal) {
          this._buttonSubmit.setMod('disabled', modVal);
          this._buttonSubmit.setMod('spin-visible', modVal);
        },

        /**
         * Фиксирование целей метрик
         */
        sendGoal: function() {
          var goals = this.params.goals;

          if (!goals) return;

          if (goals.gtm) { // gooogle tag manager
            try { // for addblock
              dataLayer.push(goals.gtm);
            } catch (error) {
              console.log(error);
            }
          }
        },

        reset: function() {
          this.domElem.trigger('reset');
        },

        success: function(data) {
          this._emit('success', data);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/form/form.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/form-field.browser.js */
/**
 * @module form-field
 */
modules.define('form-field',
    ['i-bem', 'i-bem-dom', 'validation', 'label', 'functions'],
    function(provide, bem, bemDom, Validation, Label, functions) {
      /**
       * Field block
       */
      provide(bemDom.declBlock(this.name, /** @lends form-field.prototype */{
        onSetMod: {
          'js': {
            'inited': function() {
              this.checkHealth();

              this._messages = {};

              this.requireDirty();
              this._initVal = this.getVal();
              this._status = this.getStatus();
            },
          },

          'disabled': function(modName, modVal) {
            this.findChildBlock(Label).setMod(modName, modVal);
            this.getControl().setMod(modName, modVal);
          },
        },

        checkHealth: function() {
          !this.getControl() &&
          console.error('Control required for form-field', this);// jshint ignore:line
          !this.getName() && console.warn('Name required for form-field', this); // jshint ignore:line
        },

        getControl: functions.noop,

        /**
         * Returns field value
         * @returns {String}
         */
        getVal: function() {
          return this.getControl().getVal();
        },
        /**
         * Sets value
         * @param {*|String} val устанавливаемое значение
         * @param {Boolean} emitEvent
         */
        setVal: function(val, emitEvent) {
          emitEvent && this._emit('change', {
            field: this.getName() || this.getId(),
            val: val,
          });
          this.getControl().setVal(val);
        },
        /**
         * Control changed
         * @protected
         */
        _onControlChange: function(e, data) {
          /**
           * Input data change event
           *
           * @event FormField#change
           * @type {Object}
           */
          this._emit('change', data);
        },
        /**
         * Control focused
         * @protected
         */
        _onControlFocus: function(e, data) {
          this.setMod('focused', true);
          /**
           * Input focus event
           *
           * @event FormField#focus
           * @type {Object}
           */
          this._emit('focus', data);
        },
        /**
         * Control unfocused
         * @protected
         */
        _onControlBlur: function(e, data) {
          this.delMod('focused');
          /**
           * Input blur event
           *
           * @event FormField#blur
           * @type {Object}
           */
          this._emit('blur', data);
        },
        /**
         * Returns field name
         * @returns {String}
         * @public
         */
        getName: function() {
          return this.domElem.attr('data-name');
        },
        /**
         * Returns field id
         * @returns {String}
         * @public
         */
        getId: function() {
          return this.params.id;
        },
        /**
         * Get form-field validator instance
         *
         * @public
         * @returns {Object}
         */
        getValidator: function() {
          return this._validator || (this._validator = Validation.create());
        },
        /**
         * Get current form-field status
         *
         * @public
         * @returns {Promise}
         */
        getStatus: function() {
          return this.getValidator().check(String(this.getVal()));
        },
        /**
         * Set current form-field status
         *
         * @public
         * @param status
         * @returns {String|Boolean}
         */
        setStatus: function(status) {
          this._status = status;
          this._updateStatus(status);
          return this._status;
        },
        /**
         * Set validation messages in runtime
         * @param messages
         */
        setValidationMessages: function(messages) {
          Object.keys(messages).forEach(function(validator) {
            this.setValidationMessage(validator, messages[validator]);
          }.bind(this));
        },
        setValidationMessage: function(validator, message) {
          this._messages[validator] = this._messages[validator] || {};
          this._messages[validator] = message;
        },
        /**
         * Get validation messages
         * @returns {Object}
         */
        getValidationMessages: function() {
          var msgs = {};
          Object.keys(this._messages).forEach(function(validator) {
            msgs[validator] = validator;
          });
          return msgs;
        },
        getValidationMessage: function(validator) {
          return this._messages[validator] ? this._messages[validator] : null;
        },
        /**
         * Require dirty mechanic
         */
        requireDirty: function() {
          this._events().on('blur', function() {
            this._dirty = this._dirty || (this.getVal() !== this._initVal);
            this.toggleMod('dirty', true, this._dirty);
            this._dirty && this.validate();
          }.bind(this));
        },
        /**
         * Get all dirty fields
         * @returns {Array}
         */
        getDirty: function() {
          return !!this._dirty;
        },
        /**
         * Validate form-field
         * catch field with message
         *
         * @public
         * @returns {Promise}
         */
        validate: function() {
          return this.getStatus().then(function(error) {
            this._updateStatus(error);
            return error;
          }.bind(this));
        },
        /**
         * Update statuses on form-field and elements: control
         *
         * @protected
         */
        _updateStatus: function(status) {
          this.toggleMod('invalid', true, Boolean(status));
          this.getControl().toggleMod('invalid', true, Boolean(status));
          this._status = status;
        },
      }, /** @lends form-field */{
        lazyInit: true,
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/form-field.browser.js */
/* begin: ../../5th.blocks/common.blocks/form-field/form-field.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['i-bem-dom', 'label'],
    function(provide, bemDom, Label, FormField) {
      /**
       * Field block
       */
      provide(bemDom.declBlock(FormField, /** @lends form-field.prototype */{

        onSetMod: {
          'focused': function(modName, modVal, oldModVal) {
            this.__base.apply(this, arguments);

            this._toggleMessage();
          },

          'disabled': function(modName, modVal) {
            this._block(Label) && this._block(Label).setMod(modName, modVal);
            this.getControl().setMod(modName, modVal);
          },
        },

        _toggleMessage: function() {
          var message = this.getMessage();

          message && message[
              this.hasMod('invalid') ? 'show' : 'hide'
              ]();
        },

        _onControlChange: function(e) {
          this.__base.apply(this, arguments);
          this.validate();
          this._toggleMessage();
        },

        /**
         * Sets value
         * @param {*|String} val устанавливаемое значение
         * @param {Boolean} emitEvent
         */
        setVal: function(val, emitEvent) {
          emitEvent && this._emit('change', {
            field: this.getName() || this.getId(),
            val: val,
          });

          var control = this.getControl();

          // Exception for attach
          if (control.domElem.get(0).className.indexOf('attach') !== -1) return;

          control.setVal(val);
        },

        /**
         * debug override
         * @returns {Promise}
         */
        validate: function() {
          return this.__base.apply(this, arguments).then(function(error) {
            error && console.warn(error); // jshint ignore:line
            return error;
          });
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/form-field/form-field.browser.js */
/* begin: ../../node_modules/bem-forms/common.blocks/validation/validation.browser.js */
/**
 * @module validation
 */
modules.define('validation',
    ['vow'],
    function(provide, Vow) {
      /**
       * Validation container
       * @constructor
       */
      function Validation() {
        this._stack = [];
      }

      var ptp = Validation.prototype;
      ptp._stack = null;
      /**
       * push validator to stack
       *
       * @param {Function} validator
       * @returns {Object}
       */
      ptp.push = function(validator) {
        if (typeof validator !== 'function') {
          throw new Error('Expected function but instead saw ' +
              typeof validator);
        }
        this._stack.push(validator);
        return this;
      };
      /**
       * Runs all registered validators for a specified value
       * and returns the first error or null
       *
       * @param {*} value
       * @returns {Promise}
       */
      ptp.check = function(value) {
        return Vow.all(this._stack.map(function(validationFunction) {
          return new Vow.Promise(function(resolve, reject) {
            var validation = Vow.resolve(validationFunction(value));
            return validation.then(function(res) {
              res !== null ? reject(res) : resolve(null);
            });
          });
        })).then(function() {
          return null;
        }).fail(function(error) {
          return error;
        });
      };

      provide({
        /**
         * Static object creator
         *
         * @api
         * @returns {Object}
         */
        create: function() {
          var res = new Validation();
          if (arguments.length) {
            for (var i = 0, l = arguments.length; i < l; i++) {
              res.push(arguments[i]);
            }
          }
          return res;
        },
      });

    });

/* end: ../../node_modules/bem-forms/common.blocks/validation/validation.browser.js */
/* begin: ../../node_modules/bem-core/common.blocks/vow/vow.vanilla.js */
/**
 * @module vow
 * @author Filatov Dmitry <dfilatov@yandex-team.ru>
 * @version 0.4.17
 * @license
 * Dual licensed under the MIT and GPL licenses:
 *   * http://www.opensource.org/licenses/mit-license.php
 *   * http://www.gnu.org/licenses/gpl.html
 */

(function(global) {

  var undef,
      nextTick = (function() {
        var fns = [],
            enqueueFn = function(fn) {
              fns.push(fn);
              return fns.length === 1;
            },
            callFns = function() {
              var fnsToCall = fns, i = 0, len = fns.length;
              fns = [];
              while (i < len) {
                fnsToCall[i++]();
              }
            };

        if (typeof setImmediate === 'function') { // ie10, nodejs >= 0.10
          return function(fn) {
            enqueueFn(fn) && setImmediate(callFns);
          };
        }

        if (typeof process === 'object' && process.nextTick) { // nodejs < 0.10
          return function(fn) {
            enqueueFn(fn) && process.nextTick(callFns);
          };
        }

        var MutationObserver = global.MutationObserver ||
            global.WebKitMutationObserver; // modern browsers
        if (MutationObserver) {
          var num = 1,
              node = document.createTextNode('');

          new MutationObserver(callFns).observe(node, {characterData: true});

          return function(fn) {
            enqueueFn(fn) && (node.data = (num *= -1));
          };
        }

        if (global.postMessage) {
          var isPostMessageAsync = true;
          if (global.attachEvent) {
            var checkAsync = function() {
              isPostMessageAsync = false;
            };
            global.attachEvent('onmessage', checkAsync);
            global.postMessage('__checkAsync', '*');
            global.detachEvent('onmessage', checkAsync);
          }

          if (isPostMessageAsync) {
            var msg = '__promise' + Math.random() + '_' + new Date,
                onMessage = function(e) {
                  if (e.data === msg) {
                    e.stopPropagation && e.stopPropagation();
                    callFns();
                  }
                };

            global.addEventListener ?
                global.addEventListener('message', onMessage, true) :
                global.attachEvent('onmessage', onMessage);

            return function(fn) {
              enqueueFn(fn) && global.postMessage(msg, '*');
            };
          }
        }

        var doc = global.document;
        if ('onreadystatechange' in doc.createElement('script')) { // ie6-ie8
          var createScript = function() {
            var script = doc.createElement('script');
            script.onreadystatechange = function() {
              script.parentNode.removeChild(script);
              script = script.onreadystatechange = null;
              callFns();
            };
            (doc.documentElement || doc.body).appendChild(script);
          };

          return function(fn) {
            enqueueFn(fn) && createScript();
          };
        }

        return function(fn) { // old browsers
          enqueueFn(fn) && setTimeout(callFns, 0);
        };
      })(),
      throwException = function(e) {
        nextTick(function() {
          throw e;
        });
      },
      isFunction = function(obj) {
        return typeof obj === 'function';
      },
      isObject = function(obj) {
        return obj !== null && typeof obj === 'object';
      },
      toStr = Object.prototype.toString,
      isArray = Array.isArray || function(obj) {
        return toStr.call(obj) === '[object Array]';
      },
      getArrayKeys = function(arr) {
        var res = [],
            i = 0, len = arr.length;
        while (i < len) {
          res.push(i++);
        }
        return res;
      },
      getObjectKeys = Object.keys || function(obj) {
        var res = [];
        for (var i in obj) {
          obj.hasOwnProperty(i) && res.push(i);
        }
        return res;
      },
      defineCustomErrorType = function(name) {
        var res = function(message) {
          this.name = name;
          this.message = message;
        };

        res.prototype = new Error();

        return res;
      },
      wrapOnFulfilled = function(onFulfilled, idx) {
        return function(val) {
          onFulfilled.call(this, val, idx);
        };
      },
      emitUnhandledRejection = global.PromiseRejectionEvent ?
          function(reason, promise) {
            new global.PromiseRejectionEvent(
                'unhandledrejection',
                {
                  promise: promise,
                  reason: reason,
                });
          } :
          typeof process === 'object' && process.emit ?
              function(reason, promise) {
                process.emit('unhandledRejection', reason, promise);
              } :
              function() {
              };

  /**
   * @class Deferred
   * @exports vow:Deferred
   * @description
   * The `Deferred` class is used to encapsulate newly-created promise object along with functions that resolve, reject or notify it.
   */

  /**
   * @constructor
   * @description
   * You can use `vow.defer()` instead of using this constructor.
   *
   * `new vow.Deferred()` gives the same result as `vow.defer()`.
   */
  var Deferred = function() {
    this._promise = new Promise();
  };

  Deferred.prototype = /** @lends Deferred.prototype */{
    /**
     * Returns the corresponding promise.
     *
     * @returns {vow:Promise}
     */
    promise: function() {
      return this._promise;
    },

    /**
     * Resolves the corresponding promise with the given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.then(function(value) {
         *     // value is "'success'" here
         * });
     *
     * defer.resolve('success');
     * ```
     */
    resolve: function(value) {
      this._promise.isResolved() || this._promise._resolve(value);
    },

    /**
     * Rejects the corresponding promise with the given `reason`.
     *
     * @param {*} reason
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.fail(function(reason) {
         *     // reason is "'something is wrong'" here
         * });
     *
     * defer.reject('something is wrong');
     * ```
     */
    reject: function(reason) {
      if (this._promise.isResolved()) {
        return;
      }

      if (vow.isPromise(reason)) {
        reason = reason.then(function(val) {
          var defer = vow.defer();
          defer.reject(val);
          return defer.promise();
        });
        this._promise._resolve(reason);
      }
      else {
        this._promise._reject(reason);
      }
    },

    /**
     * Notifies the corresponding promise with the given `value`.
     *
     * @param {*} value
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promise = defer.promise();
     *
     * promise.progress(function(value) {
         *     // value is "'20%'", "'40%'" here
         * });
     *
     * defer.notify('20%');
     * defer.notify('40%');
     * ```
     */
    notify: function(value) {
      this._promise.isResolved() || this._promise._notify(value);
    },
  };

  var PROMISE_STATUS = {
    PENDING: 0,
    RESOLVED: 1,
    FULFILLED: 2,
    REJECTED: 3,
  };

  /**
   * @class Promise
   * @exports vow:Promise
   * @description
   * The `Promise` class is used when you want to give to the caller something to subscribe to,
   * but not the ability to resolve or reject the deferred.
   */

  /**
   * @constructor
   * @param {Function} resolver See https://github.com/domenic/promises-unwrapping/blob/master/README.md#the-promise-constructor for details.
   * @description
   * You should use this constructor directly only if you are going to use `vow` as DOM Promises implementation.
   * In other case you should use `vow.defer()` and `defer.promise()` methods.
   * @example
   * ```js
   * function fetchJSON(url) {
     *     return new vow.Promise(function(resolve, reject, notify) {
     *         var xhr = new XMLHttpRequest();
     *         xhr.open('GET', url);
     *         xhr.responseType = 'json';
     *         xhr.send();
     *         xhr.onload = function() {
     *             if(xhr.response) {
     *                 resolve(xhr.response);
     *             }
     *             else {
     *                 reject(new TypeError());
     *             }
     *         };
     *     });
     * }
   * ```
   */
  var Promise = function(resolver) {
    this._value = undef;
    this._status = PROMISE_STATUS.PENDING;
    this._shouldEmitUnhandledRejection = true;

    this._fulfilledCallbacks = [];
    this._rejectedCallbacks = [];
    this._progressCallbacks = [];

    if (resolver) { // NOTE: see https://github.com/domenic/promises-unwrapping/blob/master/README.md
      var _this = this,
          resolverFnLen = resolver.length;

      try {
        resolver(
            function(val) {
              _this.isResolved() || _this._resolve(val);
            },
            resolverFnLen > 1 ?
                function(reason) {
                  _this.isResolved() || _this._reject(reason);
                } :
                undef,
            resolverFnLen > 2 ?
                function(val) {
                  _this.isResolved() || _this._notify(val);
                } :
                undef);
      }
      catch (e) {
        this._reject(e);
      }
    }
  };

  Promise.prototype = /** @lends Promise.prototype */ {
    /**
     * Returns the value of the fulfilled promise or the reason in case of rejection.
     *
     * @returns {*}
     */
    valueOf: function() {
      return this._value;
    },

    /**
     * Returns `true` if the promise is resolved.
     *
     * @returns {Boolean}
     */
    isResolved: function() {
      return this._status !== PROMISE_STATUS.PENDING;
    },

    /**
     * Returns `true` if the promise is fulfilled.
     *
     * @returns {Boolean}
     */
    isFulfilled: function() {
      return this._status === PROMISE_STATUS.FULFILLED;
    },

    /**
     * Returns `true` if the promise is rejected.
     *
     * @returns {Boolean}
     */
    isRejected: function() {
      return this._status === PROMISE_STATUS.REJECTED;
    },

    /**
     * Adds reactions to the promise.
     *
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callbacks execution
     * @returns {vow:Promise} A new promise, see https://github.com/promises-aplus/promises-spec for details
     */
    then: function(onFulfilled, onRejected, onProgress, ctx) {
      this._shouldEmitUnhandledRejection = false;
      var defer = new Deferred();
      this._addCallbacks(defer, onFulfilled, onRejected, onProgress, ctx);
      return defer.promise();
    },

    /**
     * Adds only a rejection reaction. This method is a shorthand for `promise.then(undefined, onRejected)`.
     *
     * @param {Function} onRejected Callback that will be called with a provided 'reason' as argument after the promise has been rejected
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    'catch': function(onRejected, ctx) {
      return this.then(undef, onRejected, ctx);
    },

    /**
     * Adds only a rejection reaction. This method is a shorthand for `promise.then(null, onRejected)`. It's also an alias for `catch`.
     *
     * @param {Function} onRejected Callback to be called with the value after promise has been rejected
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    fail: function(onRejected, ctx) {
      return this.then(undef, onRejected, ctx);
    },

    /**
     * Adds a resolving reaction (for both fulfillment and rejection).
     *
     * @param {Function} onResolved Callback that will be invoked with the promise as an argument, after the promise has been resolved.
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    always: function(onResolved, ctx) {
      var _this = this,
          cb = function() {
            return onResolved.call(this, _this);
          };

      return this.then(cb, cb, ctx);
    },

    /**
     * Adds a progress reaction.
     *
     * @param {Function} onProgress Callback that will be called with a provided value when the promise has been notified
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    progress: function(onProgress, ctx) {
      return this.then(undef, undef, onProgress, ctx);
    },

    /**
     * Like `promise.then`, but "spreads" the array into a variadic value handler.
     * It is useful with the `vow.all` and the `vow.allResolved` methods.
     *
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Object} [ctx] Context of the callbacks execution
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise()]).spread(function(arg1, arg2) {
         *     // arg1 is "1", arg2 is "'two'" here
         * });
     *
     * defer1.resolve(1);
     * defer2.resolve('two');
     * ```
     */
    spread: function(onFulfilled, onRejected, ctx) {
      return this.then(
          function(val) {
            return onFulfilled.apply(this, val);
          },
          onRejected,
          ctx);
    },

    /**
     * Like `then`, but terminates a chain of promises.
     * If the promise has been rejected, this method throws it's "reason" as an exception in a future turn of the event loop.
     *
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callbacks execution
     *
     * @example
     * ```js
     * var defer = vow.defer();
     * defer.reject(Error('Internal error'));
     * defer.promise().done(); // exception to be thrown
     * ```
     */
    done: function(onFulfilled, onRejected, onProgress, ctx) {
      this.then(onFulfilled, onRejected, onProgress, ctx).fail(throwException);
    },

    /**
     * Returns a new promise that will be fulfilled in `delay` milliseconds if the promise is fulfilled,
     * or immediately rejected if the promise is rejected.
     *
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay: function(delay) {
      var timer,
          promise = this.then(function(val) {
            var defer = new Deferred();
            timer = setTimeout(
                function() {
                  defer.resolve(val);
                },
                delay);

            return defer.promise();
          });

      promise.always(function() {
        clearTimeout(timer);
      });

      return promise;
    },

    /**
     * Returns a new promise that will be rejected in `timeout` milliseconds
     * if the promise is not resolved beforehand.
     *
     * @param {Number} timeout
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer = vow.defer(),
     *     promiseWithTimeout1 = defer.promise().timeout(50),
     *     promiseWithTimeout2 = defer.promise().timeout(200);
     *
     * setTimeout(
     *     function() {
         *         defer.resolve('ok');
         *     },
     *     100);
     *
     * promiseWithTimeout1.fail(function(reason) {
         *     // promiseWithTimeout to be rejected in 50ms
         * });
     *
     * promiseWithTimeout2.then(function(value) {
         *     // promiseWithTimeout to be fulfilled with "'ok'" value
         * });
     * ```
     */
    timeout: function(timeout) {
      var defer = new Deferred(),
          timer = setTimeout(
              function() {
                defer.reject(new vow.TimedOutError('timed out'));
              },
              timeout);

      this.then(
          function(val) {
            defer.resolve(val);
          },
          function(reason) {
            defer.reject(reason);
          });

      defer.promise().always(function() {
        clearTimeout(timer);
      });

      return defer.promise();
    },

    _vow: true,

    _resolve: function(val) {
      if (this._status > PROMISE_STATUS.RESOLVED) {
        return;
      }

      if (val === this) {
        this._reject(TypeError('Can\'t resolve promise with itself'));
        return;
      }

      this._status = PROMISE_STATUS.RESOLVED;

      if (val && !!val._vow) { // shortpath for vow.Promise
        if (val.isFulfilled()) {
          this._fulfill(val.valueOf());
        }
        else if (val.isRejected()) {
          val._shouldEmitUnhandledRejection = false;
          this._reject(val.valueOf());
        }
        else {
          val.then(
              this._fulfill,
              this._reject,
              this._notify,
              this);
        }

        return;
      }

      if (isObject(val) || isFunction(val)) {
        var then;
        try {
          then = val.then;
        }
        catch (e) {
          this._reject(e);
          return;
        }

        if (isFunction(then)) {
          var _this = this,
              isResolved = false;

          try {
            then.call(
                val,
                function(val) {
                  if (isResolved) {
                    return;
                  }

                  isResolved = true;
                  _this._resolve(val);
                },
                function(err) {
                  if (isResolved) {
                    return;
                  }

                  isResolved = true;
                  _this._reject(err);
                },
                function(val) {
                  _this._notify(val);
                });
          }
          catch (e) {
            isResolved || this._reject(e);
          }

          return;
        }
      }

      this._fulfill(val);
    },

    _fulfill: function(val) {
      if (this._status > PROMISE_STATUS.RESOLVED) {
        return;
      }

      this._status = PROMISE_STATUS.FULFILLED;
      this._value = val;

      this._callCallbacks(this._fulfilledCallbacks, val);
      this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },

    _reject: function(reason) {
      if (this._status > PROMISE_STATUS.RESOLVED) {
        return;
      }

      this._status = PROMISE_STATUS.REJECTED;
      this._value = reason;

      this._callCallbacks(this._rejectedCallbacks, reason);

      if (!this._rejectedCallbacks.length) {
        var _this = this;
        nextTick(function() {
          if (_this._shouldEmitUnhandledRejection) {
            emitUnhandledRejection(reason, _this);
          }
        });
      }

      this._fulfilledCallbacks = this._rejectedCallbacks = this._progressCallbacks = undef;
    },

    _notify: function(val) {
      this._callCallbacks(this._progressCallbacks, val);
    },

    _addCallbacks: function(defer, onFulfilled, onRejected, onProgress, ctx) {
      if (onRejected && !isFunction(onRejected)) {
        ctx = onRejected;
        onRejected = undef;
      }
      else if (onProgress && !isFunction(onProgress)) {
        ctx = onProgress;
        onProgress = undef;
      }

      if (onRejected) {
        this._shouldEmitUnhandledRejection = false;
      }

      var cb;

      if (!this.isRejected()) {
        cb = {
          defer: defer,
          fn: isFunction(onFulfilled) ? onFulfilled : undef,
          ctx: ctx,
        };
        this.isFulfilled() ?
            this._callCallbacks([cb], this._value) :
            this._fulfilledCallbacks.push(cb);
      }

      if (!this.isFulfilled()) {
        cb = {defer: defer, fn: onRejected, ctx: ctx};
        this.isRejected() ?
            this._callCallbacks([cb], this._value) :
            this._rejectedCallbacks.push(cb);
      }

      if (this._status <= PROMISE_STATUS.RESOLVED) {
        this._progressCallbacks.push({defer: defer, fn: onProgress, ctx: ctx});
      }
    },

    _callCallbacks: function(callbacks, arg) {
      var len = callbacks.length;
      if (!len) {
        return;
      }

      var isResolved = this.isResolved(),
          isFulfilled = this.isFulfilled(),
          isRejected = this.isRejected();

      nextTick(function() {
        var i = 0, cb, defer, fn;
        while (i < len) {
          cb = callbacks[i++];
          defer = cb.defer;
          fn = cb.fn;

          if (fn) {
            var ctx = cb.ctx,
                res;
            try {
              res = ctx ? fn.call(ctx, arg) : fn(arg);
            }
            catch (e) {
              defer.reject(e);
              continue;
            }

            isFulfilled || isRejected ?
                defer.resolve(res) :
                defer.notify(res);
          }
          else if (isFulfilled) {
            defer.resolve(arg);
          }
          else if (isRejected) {
            defer.reject(arg);
          }
          else {
            defer.notify(arg);
          }
        }
      });
    },
  };

  /** @lends Promise */
  var staticMethods = {
    /**
     * Coerces the given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast: function(value) {
      return vow.cast(value);
    },

    /**
     * Returns a promise, that will be fulfilled only after all the items in `iterable` are fulfilled.
     * If any of the `iterable` items gets rejected, then the returned promise will be rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     */
    all: function(iterable) {
      return vow.all(iterable);
    },

    /**
     * Returns a promise, that will be fulfilled only when any of the items in `iterable` are fulfilled.
     * If any of the `iterable` items gets rejected, then the returned promise will be rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    race: function(iterable) {
      return vow.anyResolved(iterable);
    },

    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, the returned promise will have `value`'s state.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve: function(value) {
      return vow.resolve(value);
    },

    /**
     * Returns a promise that has already been rejected with the given `reason`.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject: function(reason) {
      return vow.reject(reason);
    },
  };

  for (var prop in staticMethods) {
    staticMethods.hasOwnProperty(prop) &&
    (Promise[prop] = staticMethods[prop]);
  }

  var vow = /** @exports vow */ {
    Deferred: Deferred,

    Promise: Promise,

    /**
     * Creates a new deferred. This method is a factory method for `vow:Deferred` class.
     * It's equivalent to `new vow.Deferred()`.
     *
     * @returns {vow:Deferred}
     */
    defer: function() {
      return new Deferred();
    },

    /**
     * Static equivalent to `promise.then`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callbacks execution
     * @returns {vow:Promise}
     */
    when: function(value, onFulfilled, onRejected, onProgress, ctx) {
      return vow.cast(value).then(onFulfilled, onRejected, onProgress, ctx);
    },

    /**
     * Static equivalent to `promise.fail`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onRejected Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    fail: function(value, onRejected, ctx) {
      return vow.when(value, undef, onRejected, ctx);
    },

    /**
     * Static equivalent to `promise.always`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onResolved Callback that will be invoked with the promise as an argument, after the promise has been resolved.
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    always: function(value, onResolved, ctx) {
      return vow.when(value).always(onResolved, ctx);
    },

    /**
     * Static equivalent to `promise.progress`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} onProgress Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callback execution
     * @returns {vow:Promise}
     */
    progress: function(value, onProgress, ctx) {
      return vow.when(value).progress(onProgress, ctx);
    },

    /**
     * Static equivalent to `promise.spread`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Object} [ctx] Context of the callbacks execution
     * @returns {vow:Promise}
     */
    spread: function(value, onFulfilled, onRejected, ctx) {
      return vow.when(value).spread(onFulfilled, onRejected, ctx);
    },

    /**
     * Static equivalent to `promise.done`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Function} [onFulfilled] Callback that will be invoked with a provided value after the promise has been fulfilled
     * @param {Function} [onRejected] Callback that will be invoked with a provided reason after the promise has been rejected
     * @param {Function} [onProgress] Callback that will be invoked with a provided value after the promise has been notified
     * @param {Object} [ctx] Context of the callbacks execution
     */
    done: function(value, onFulfilled, onRejected, onProgress, ctx) {
      vow.when(value).done(onFulfilled, onRejected, onProgress, ctx);
    },

    /**
     * Checks whether the given `value` is a promise-like object
     *
     * @param {*} value
     * @returns {Boolean}
     *
     * @example
     * ```js
     * vow.isPromise('something'); // returns false
     * vow.isPromise(vow.defer().promise()); // returns true
     * vow.isPromise({ then : function() { }); // returns true
         * ```
         */
    isPromise: function(value) {
      return isObject(value) && isFunction(value.then);
    },

    /**
     * Coerces the given `value` to a promise, or returns the `value` if it's already a promise.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    cast: function(value) {
      return value && !!value._vow ?
          value :
          vow.resolve(value);
    },

    /**
     * Static equivalent to `promise.valueOf`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @returns {*}
     */
    valueOf: function(value) {
      return value && isFunction(value.valueOf) ? value.valueOf() : value;
    },

    /**
     * Static equivalent to `promise.isFulfilled`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isFulfilled: function(value) {
      return value && isFunction(value.isFulfilled) ?
          value.isFulfilled() :
          true;
    },

    /**
     * Static equivalent to `promise.isRejected`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isRejected: function(value) {
      return value && isFunction(value.isRejected) ? value.isRejected() : false;
    },

    /**
     * Static equivalent to `promise.isResolved`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @returns {Boolean}
     */
    isResolved: function(value) {
      return value && isFunction(value.isResolved) ? value.isResolved() : true;
    },

    /**
     * Returns a promise that has already been resolved with the given `value`.
     * If `value` is a promise, the returned promise will have `value`'s state.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    resolve: function(value) {
      var res = vow.defer();
      res.resolve(value);
      return res.promise();
    },

    /**
     * Returns a promise that has already been fulfilled with the given `value`.
     * If `value` is a promise, the returned promise will be fulfilled with the fulfill/rejection value of `value`.
     *
     * @param {*} value
     * @returns {vow:Promise}
     */
    fulfill: function(value) {
      var defer = vow.defer(),
          promise = defer.promise();

      defer.resolve(value);

      return promise.isFulfilled() ?
          promise :
          promise.then(null, function(reason) {
            return reason;
          });
    },

    /**
     * Returns a promise that has already been rejected with the given `reason`.
     * If `reason` is a promise, the returned promise will be rejected with the fulfill/rejection value of `reason`.
     *
     * @param {*} reason
     * @returns {vow:Promise}
     */
    reject: function(reason) {
      var defer = vow.defer();
      defer.reject(reason);
      return defer.promise();
    },

    /**
     * Invokes the given function `fn` with arguments `args`
     *
     * @param {Function} fn
     * @param {...*} [args]
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var promise1 = vow.invoke(function(value) {
         *         return value;
         *     }, 'ok'),
     *     promise2 = vow.invoke(function() {
         *         throw Error();
         *     });
     *
     * promise1.isFulfilled(); // true
     * promise1.valueOf(); // 'ok'
     * promise2.isRejected(); // true
     * promise2.valueOf(); // instance of Error
     * ```
     */
    invoke: function(fn, args) {
      var len = Math.max(arguments.length - 1, 0),
          callArgs;
      if (len) { // optimization for V8
        callArgs = Array(len);
        var i = 0;
        while (i < len) {
          callArgs[i++] = arguments[i];
        }
      }

      try {
        return vow.resolve(callArgs ?
            fn.apply(global, callArgs) :
            fn.call(global));
      }
      catch (e) {
        return vow.reject(e);
      }
    },

    /**
     * Returns a promise, that will be fulfilled only after all the items in `iterable` are fulfilled.
     * If any of the `iterable` items gets rejected, the promise will be rejected.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * with array:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all([defer1.promise(), defer2.promise(), 3])
     *     .then(function(value) {
         *          // value is "[1, 2, 3]" here
         *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     *
     * @example
     * with object:
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.all({ p1 : defer1.promise(), p2 : defer2.promise(), p3 : 3 })
     *     .then(function(value) {
         *          // value is "{ p1 : 1, p2 : 2, p3 : 3 }" here
         *     });
     *
     * defer1.resolve(1);
     * defer2.resolve(2);
     * ```
     */
    all: function(iterable) {
      var defer = new Deferred(),
          isPromisesArray = isArray(iterable),
          keys = isPromisesArray ?
              getArrayKeys(iterable) :
              getObjectKeys(iterable),
          len = keys.length,
          res = isPromisesArray ? [] : {};

      if (!len) {
        defer.resolve(res);
        return defer.promise();
      }

      var i = len;
      vow._forEach(
          iterable,
          function(value, idx) {
            res[keys[idx]] = value;
            if (!--i) {
              defer.resolve(res);
            }
          },
          defer.reject,
          defer.notify,
          defer,
          keys);

      return defer.promise();
    },

    /**
     * Returns a promise, that will be fulfilled only after all the items in `iterable` are resolved.
     *
     * @param {Array|Object} iterable
     * @returns {vow:Promise}
     *
     * @example
     * ```js
     * var defer1 = vow.defer(),
     *     defer2 = vow.defer();
     *
     * vow.allResolved([defer1.promise(), defer2.promise()]).spread(function(promise1, promise2) {
         *     promise1.isRejected(); // returns true
         *     promise1.valueOf(); // returns "'error'"
         *     promise2.isFulfilled(); // returns true
         *     promise2.valueOf(); // returns "'ok'"
         * });
     *
     * defer1.reject('error');
     * defer2.resolve('ok');
     * ```
     */
    allResolved: function(iterable) {
      var defer = new Deferred(),
          isPromisesArray = isArray(iterable),
          keys = isPromisesArray ?
              getArrayKeys(iterable) :
              getObjectKeys(iterable),
          i = keys.length,
          res = isPromisesArray ? [] : {};

      if (!i) {
        defer.resolve(res);
        return defer.promise();
      }

      var onResolved = function() {
        --i || defer.resolve(iterable);
      };

      vow._forEach(
          iterable,
          onResolved,
          onResolved,
          defer.notify,
          defer,
          keys);

      return defer.promise();
    },

    allPatiently: function(iterable) {
      return vow.allResolved(iterable).then(function() {
        var isPromisesArray = isArray(iterable),
            keys = isPromisesArray ?
                getArrayKeys(iterable) :
                getObjectKeys(iterable),
            rejectedPromises, fulfilledPromises,
            len = keys.length, i = 0, key, promise;

        if (!len) {
          return isPromisesArray ? [] : {};
        }

        while (i < len) {
          key = keys[i++];
          promise = iterable[key];
          if (vow.isRejected(promise)) {
            rejectedPromises || (rejectedPromises = isPromisesArray ? [] : {});
            isPromisesArray ?
                rejectedPromises.push(promise.valueOf()) :
                rejectedPromises[key] = promise.valueOf();
          }
          else if (!rejectedPromises) {
            (fulfilledPromises || (fulfilledPromises = isPromisesArray ?
                [] :
                {}))[key] = vow.valueOf(promise);
          }
        }

        if (rejectedPromises) {
          throw rejectedPromises;
        }

        return fulfilledPromises;
      });
    },

    /**
     * Returns a promise, that will be fulfilled if any of the items in `iterable` is fulfilled.
     * If all of the `iterable` items get rejected, the promise will be rejected (with the reason of the first rejected item).
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    any: function(iterable) {
      var defer = new Deferred(),
          len = iterable.length;

      if (!len) {
        defer.reject(Error());
        return defer.promise();
      }

      var i = 0, reason;
      vow._forEach(
          iterable,
          defer.resolve,
          function(e) {
            i || (reason = e);
            ++i === len && defer.reject(reason);
          },
          defer.notify,
          defer);

      return defer.promise();
    },

    /**
     * Returns a promise, that will be fulfilled only when any of the items in `iterable` is fulfilled.
     * If any of the `iterable` items gets rejected, the promise will be rejected.
     *
     * @param {Array} iterable
     * @returns {vow:Promise}
     */
    anyResolved: function(iterable) {
      var defer = new Deferred(),
          len = iterable.length;

      if (!len) {
        defer.reject(Error());
        return defer.promise();
      }

      vow._forEach(
          iterable,
          defer.resolve,
          defer.reject,
          defer.notify,
          defer);

      return defer.promise();
    },

    /**
     * Static equivalent to `promise.delay`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Number} delay
     * @returns {vow:Promise}
     */
    delay: function(value, delay) {
      return vow.resolve(value).delay(delay);
    },

    /**
     * Static equivalent to `promise.timeout`.
     * If `value` is not a promise, then `value` is treated as a fulfilled promise.
     *
     * @param {*} value
     * @param {Number} timeout
     * @returns {vow:Promise}
     */
    timeout: function(value, timeout) {
      return vow.resolve(value).timeout(timeout);
    },

    _forEach: function(
        promises, onFulfilled, onRejected, onProgress, ctx, keys) {
      var len = keys ? keys.length : promises.length,
          i = 0;

      while (i < len) {
        vow.when(
            promises[keys ? keys[i] : i],
            wrapOnFulfilled(onFulfilled, i),
            onRejected,
            onProgress,
            ctx);
        ++i;
      }
    },

    TimedOutError: defineCustomErrorType('TimedOut'),
  };

  var defineAsGlobal = true;
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = vow;
    defineAsGlobal = false;
  }

  if (typeof modules === 'object' && isFunction(modules.define)) {
    modules.define('vow', function(provide) {
      provide(vow);
    });
    defineAsGlobal = false;
  }

  if (typeof define === 'function') {
    define(function(require, exports, module) {
      module.exports = vow;
    });
    defineAsGlobal = false;
  }

  defineAsGlobal && (global.vow = vow);

})(typeof window !== 'undefined' ? window : global);

/* end: ../../node_modules/bem-core/common.blocks/vow/vow.vanilla.js */
/* begin: ../../node_modules/bem-forms/common.blocks/label/label.browser.js */
modules.define('label', ['i-bem-dom'],
    function(provide, bemDom, Label) {
      /**
       * @exports
       * @class label
       * @bem
       */
      provide(bemDom.declBlock(this.name, {}));

    });

/* end: ../../node_modules/bem-forms/common.blocks/label/label.browser.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form/_message/form_message.browser.js */
/**
 * @module form
 */
modules.define('form', ['message'],
    function(provide, Message, Form) {
      /**
       * Base form__message class
       *
       * @exports
       * @class form
       * @bem
       */
      Form.declMod({modName: 'message', modVal: '*'},
          /** @lends form.prototype */{
            /**
             * Return instance of message block
             * @protected
             * @abstract
             */
            getMessage: function() {
              return this._message ||
                  (this._message = this.findChildElem('message').
                      findMixedBlock(Message));
            },
            /**
             * Return message value
             * @public
             * @abstract
             */
            getMessageVal: function() {
              return this.getMessage().getVal();
            },
            /**
             * Set message value
             * @public
             * @abstract
             */
            setMessageVal: function(val) {
              this.getMessage().setVal(val);
              this._emit('message-change');
              return this;
            },

            _updateStatus: function(fieldsStatuses) {
              this.__base.apply(this, arguments);

              if (!this.hasMod('message')) {
                console.warn('Message modifier required for form', this); // jshint ignore:line
                return;
              }

              var status = this._status;
              this.getMessage().toggleMod('invalid', true, Boolean(status));
              if (status && status.message) this.setMessageVal(status.message);
            },
          });

      provide(Form);

    });

/* end: ../../node_modules/bem-forms/common.blocks/form/_message/form_message.browser.js */
/* begin: ../../node_modules/bem-forms/common.blocks/message/message.browser.js */
/**
 * @module message
 */
modules.define('message',
    ['i-bem-dom'],
    function(provide, bemDom) {
      /**
       * Message block
       */
      provide(bemDom.declBlock(this.name, /** @lends message.prototype */{

        onSetMod: {
          'js': {
            'inited': function() {
              this._val = '';
            },
          },
        },
        /**
         * Get message value
         * @abstract
         */
        getVal: function() {
          return this._val;
        },
        /**
         * Set message value
         * @param {*|String} val
         * @abstract
         */
        setVal: function(val) {
          this._val = val;
        },
        /**
         * Show message
         */
        show: function() {
          this.setMod('showed');
        },
        /**
         * Hide message
         */
        hide: function() {
          this.delMod('showed');
        },
        /**
         * Toggle message visibility
         */
        toggle: function() {
          this.toggleMod('showed');
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/message/message.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/popup/_target/popup_target.js */
/**
 * @module popup
 */

modules.define(
    'popup',
    ['i-bem-dom', 'objects'],
    function(provide, bemDom, objects, Popup) {

      var VIEWPORT_ACCURACY_FACTOR = 0.99,
          DEFAULT_DIRECTIONS = [
            'bottom-left', 'bottom-center', 'bottom-right',
            'top-left', 'top-center', 'top-right',
            'right-top', 'right-center', 'right-bottom',
            'left-top', 'left-center', 'left-bottom',
          ],

          win = bemDom.win,
          undef;

      /**
       * @exports
       * @class popup
       * @bem
       *
       * @param {Number} [mainOffset=0] offset along the main direction
       * @param {Number} [secondaryOffset=0] offset along the secondary direction
       * @param {Number} [viewportOffset=0] offset from the viewport (window)
       * @param {Array[String]} [directions] allowed directions
       */
      provide(Popup.declMod({modName: 'target', modVal: '*'},
          /** @lends popup.prototype */{
            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);

                  this._lastDrawingCss = {
                    left: undef,
                    top: undef,
                    zIndex: undef,
                    display: undef,
                  };
                },
              },

              'visible': {
                'true': function() {
                  this.__base.apply(this, arguments);
                  this._domEvents(win).
                      on('scroll resize', this._onWinScrollAndResize);
                  this.redraw();
                },

                '': function() {
                  this.__base.apply(this, arguments);
                  this._domEvents(win).
                      un('scroll resize', this._onWinScrollAndResize);
                },
              },
            },

            /**
             * @override
             */
            setContent: function() {
              return this.__base.apply(this, arguments).redraw();
            },

            /**
             * Redraws popup
             * @returns {popup} this
             */
            redraw: function() {
              if (!this.hasMod('visible')) return this;

              var bestDrawingParams = this._calcBestDrawingParams();

              this.setMod('direction', bestDrawingParams.direction);

              var lastDrawingCss = this._lastDrawingCss,
                  needUpdateCss = false;

              objects.each(
                  this._calcDrawingCss(bestDrawingParams),
                  function(val, name) {
                    if (lastDrawingCss[name] !== val) {
                      lastDrawingCss[name] = val;
                      needUpdateCss = true;
                    }
                  });

              needUpdateCss && this.domElem.css(lastDrawingCss);

              return this;
            },

            _calcDrawingCss: function(drawingParams) {
              return {
                left: drawingParams.left,
                top: drawingParams.top,
              };
            },

            /**
             * Returns possible directions to draw with max available width and height.
             * @returns {Array}
             */
            calcPossibleDrawingParams: function() {
              var target = this._calcTargetDimensions(),
                  viewport = this._calcViewportDimensions(),
                  params = this.params,
                  mainOffset = params.mainOffset,
                  secondaryOffset = params.secondaryOffset,
                  viewportOffset = params.viewportOffset;

              return this.params.directions.map(function(direction) {
                var subRes = {
                  direction: direction,
                  width: 0,
                  height: 0,
                  left: 0,
                  top: 0,
                };

                if (this._checkMainDirection(direction, 'bottom')) {
                  subRes.top = target.top + target.height + mainOffset;
                  subRes.height = viewport.bottom - subRes.top - viewportOffset;
                } else if (this._checkMainDirection(direction, 'top')) {
                  subRes.height = target.top - viewport.top - mainOffset -
                      viewportOffset;
                  subRes.top = target.top - subRes.height - mainOffset;
                } else {
                  if (this._checkSecondaryDirection(direction, 'center')) {
                    subRes.height = viewport.bottom - viewport.top - 2 *
                        viewportOffset;
                    subRes.top = target.top + target.height / 2 -
                        subRes.height / 2;
                  } else if (this._checkSecondaryDirection(direction,
                      'bottom')) {
                    subRes.height = target.top + target.height - viewport.top -
                        secondaryOffset - viewportOffset;
                    subRes.top = target.top + target.height - subRes.height -
                        secondaryOffset;
                  } else if (this._checkSecondaryDirection(direction, 'top')) {
                    subRes.top = target.top + secondaryOffset;
                    subRes.height = viewport.bottom - subRes.top -
                        viewportOffset;
                  }

                  if (this._checkMainDirection(direction, 'left')) {
                    subRes.width = target.left - viewport.left - mainOffset -
                        viewportOffset;
                    subRes.left = target.left - subRes.width - mainOffset;
                  } else {
                    subRes.left = target.left + target.width + mainOffset;
                    subRes.width = viewport.right - subRes.left -
                        viewportOffset;
                  }
                }

                if (this._checkSecondaryDirection(direction, 'right')) {
                  subRes.width = target.left + target.width - viewport.left -
                      secondaryOffset - viewportOffset;
                  subRes.left = target.left + target.width - subRes.width -
                      secondaryOffset;
                } else if (this._checkSecondaryDirection(direction, 'left')) {
                  subRes.left = target.left + secondaryOffset;
                  subRes.width = viewport.right - subRes.left - viewportOffset;
                } else if (this._checkSecondaryDirection(direction, 'center')) {
                  if (this._checkMainDirection(direction, 'top', 'bottom')) {
                    subRes.width = viewport.right - viewport.left - 2 *
                        viewportOffset;
                    subRes.left = target.left + target.width / 2 -
                        subRes.width / 2;
                  }
                }

                return subRes;
              }, this);
            },

            _calcBestDrawingParams: function() {
              var popup = this._calcPopupDimensions(),
                  target = this._calcTargetDimensions(),
                  viewport = this._calcViewportDimensions(),
                  directions = this.params.directions,
                  i = 0,
                  direction,
                  pos,
                  viewportFactor,
                  bestDirection,
                  bestPos,
                  bestViewportFactor;

              while (direction = directions[i++]) {
                pos = this._calcPos(direction, target, popup);
                viewportFactor = this._calcViewportFactor(pos, viewport, popup);
                if (i === 1 ||
                    viewportFactor > bestViewportFactor ||
                    (!bestViewportFactor &&
                        this.hasMod('direction', direction))) {
                  bestDirection = direction;
                  bestViewportFactor = viewportFactor;
                  bestPos = pos;
                }
                if (bestViewportFactor > VIEWPORT_ACCURACY_FACTOR) break;
              }

              return {
                direction: bestDirection,
                left: bestPos.left,
                top: bestPos.top,
              };
            },

            _calcPopupDimensions: function() {
              var popupWidth = this.domElem.outerWidth(),
                  popupHeight = this.domElem.outerHeight();

              return {
                width: popupWidth,
                height: popupHeight,
                area: popupWidth * popupHeight,
              };
            },

            /**
             * @abstract
             * @protected
             * @returns {Object}
             */
            _calcTargetDimensions: function() {
            },

            _calcViewportDimensions: function() {
              var winTop = win.scrollTop(),
                  winLeft = win.scrollLeft(),
                  winWidth = win.width(),
                  winHeight = win.height();

              return {
                top: winTop,
                left: winLeft,
                bottom: winTop + winHeight,
                right: winLeft + winWidth,
              };
            },

            _calcPos: function(direction, target, popup) {
              var res = {},
                  mainOffset = this.params.mainOffset,
                  secondaryOffset = this.params.secondaryOffset;

              if (this._checkMainDirection(direction, 'bottom')) {
                res.top = target.top + target.height + mainOffset;
              } else if (this._checkMainDirection(direction, 'top')) {
                res.top = target.top - popup.height - mainOffset;
              } else if (this._checkMainDirection(direction, 'left')) {
                res.left = target.left - popup.width - mainOffset;
              } else if (this._checkMainDirection(direction, 'right')) {
                res.left = target.left + target.width + mainOffset;
              }

              if (this._checkSecondaryDirection(direction, 'right')) {
                res.left = target.left + target.width - popup.width -
                    secondaryOffset;
              } else if (this._checkSecondaryDirection(direction, 'left')) {
                res.left = target.left + secondaryOffset;
              } else if (this._checkSecondaryDirection(direction, 'bottom')) {
                res.top = target.top + target.height - popup.height -
                    secondaryOffset;
              } else if (this._checkSecondaryDirection(direction, 'top')) {
                res.top = target.top + secondaryOffset;
              } else if (this._checkSecondaryDirection(direction, 'center')) {
                if (this._checkMainDirection(direction, 'top', 'bottom')) {
                  res.left = target.left + target.width / 2 - popup.width / 2;
                } else if (this._checkMainDirection(direction, 'left',
                    'right')) {
                  res.top = target.top + target.height / 2 - popup.height / 2;
                }
              }

              return res;
            },

            _calcViewportFactor: function(pos, viewport, popup) {
              var viewportOffset = this.params.viewportOffset,
                  intersectionLeft = Math.max(pos.left, viewport.left +
                      viewportOffset),
                  intersectionRight = Math.min(pos.left +
                      popup.width, viewport.right - viewportOffset),
                  intersectionTop = Math.max(pos.top, viewport.top +
                      viewportOffset),
                  intersectionBottom = Math.min(pos.top +
                      popup.height, viewport.bottom - viewportOffset);

              return intersectionLeft < intersectionRight &&
              intersectionTop < intersectionBottom ? // has intersection
                  (intersectionRight - intersectionLeft) *
                  (intersectionBottom - intersectionTop) /
                  popup.area :
                  0;
            },

            _checkMainDirection: function(
                direction, mainDirection1, mainDirection2) {
              return !direction.indexOf(mainDirection1) ||
                  (mainDirection2 && !direction.indexOf(mainDirection2));
            },

            _checkSecondaryDirection: function(direction, secondaryDirection) {
              return ~direction.indexOf('-' + secondaryDirection);
            },

            _onWinScrollAndResize: function() {
              this.redraw();
            },

            _getDefaultParams: function() {
              return objects.extend(
                  this.__base.apply(this, arguments),
                  {
                    mainOffset: 0,
                    secondaryOffset: 0,
                    viewportOffset: 0,
                    directions: DEFAULT_DIRECTIONS,
                  });
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/popup/_target/popup_target.js */
/* begin: ../../node_modules/bem-components/common.blocks/z-index-group/z-index-group.js */
modules.define('z-index-group', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declBlock(this.name));

});

/* end: ../../node_modules/bem-components/common.blocks/z-index-group/z-index-group.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_message/form-field_message.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['message'],
    function(provide, Message, FormField) {
      /**
       * Base form-field__message class
       *
       * @exports
       * @class form-field
       * @bem
       */
      FormField.declMod({modName: 'message', modVal: '*'},
          /** @lends form-field.prototype */{
            /**
             * Return instance of message block
             * @public
             * @abstract
             */
            getMessage: function() {
              return this._message ||
                  (this._message = this.findChildElem('message').
                      findMixedBlock(Message));
            },
            /**
             * Return message value
             * @public
             * @abstract
             */
            getMessageVal: function() {
              return this.getMessage().getVal();
            },
            /**
             * Set message value
             * @public
             * @abstract
             */
            setMessageVal: function(val) {
              this.getMessage().setVal(val);
              this._emit('message-change');
              return this;
            },
            /**
             * Update statuses on form-field and elements: message
             *
             * @protected
             */
            _updateStatus: function() {
              this.__base.apply(this, arguments);

              if (!this.hasMod('message')) {
                console.warn('Message modifier required for form-field', this); // jshint ignore:line
                return;
              }

              var status = this._status;
              this.getMessage().toggleMod('invalid', true, Boolean(status));
              if (status && status.message) this.setMessageVal(status.message);
            },
          });

      provide(FormField);

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_message/form-field_message.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/input/input.js */
/**
 * @module input
 */

modules.define('input', ['i-bem-dom', 'control'],
    function(provide, bemDom, Control) {

      /**
       * @exports
       * @class input
       * @augments control
       * @bem
       */
      provide(
          bemDom.declBlock(this.name, Control, /** @lends input.prototype */{
            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);
                  this._val = this._elem('control').domElem.val();
                },
              },
            },

            /**
             * Returns control value
             * @returns {String}
             * @override
             */
            getVal: function() {
              return this._val;
            },

            /**
             * Sets control value
             * @param {String} val value
             * @param {Object} [data] additional data
             * @returns {input} this
             */
            setVal: function(val, data) {
              val = String(val);

              if (this._val !== val) {
                this._val = val;

                var control = this._elem('control');
                control.domElem.val() !== val && control.domElem.val(val);

                this._emit('change', data);
              }

              return this;
            },
          }, /** @lends input */{
            lazyInit: false,
            onInit: function() {
              this.__base.apply(this, arguments);
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/input/input.js */
/* begin: ../../node_modules/bem-components/desktop.blocks/input/input.js */
/**
 * @module input
 */

modules.define('input', ['i-bem-dom', 'tick', 'idle'],
    function(provide, bemDom, tick, idle, Input) {

      var instances = [],
          boundToTick,
          bindToTick = function() {
            boundToTick = true;
            tick.on('tick', update).start();
            idle.on({
              idle: function() {
                tick.un('tick', update);
              },
              wakeup: function() {
                tick.on('tick', update);
              },
            }).start();
          },
          update = function() {
            var instance, i = 0;
            while (instance = instances[i++]) {
              instance.setVal(instance._elem('control').domElem.val());
            }
          };

      /**
       * @exports
       * @class input
       * @bem
       */
      provide(bemDom.declBlock(Input, /** @lends input.prototype */{
        onSetMod: {
          'js': {
            'inited': function() {
              this.__base.apply(this, arguments);

              boundToTick || bindToTick();

              // сохраняем индекс в массиве инстансов чтобы потом быстро из него удалять
              this._instanceIndex = instances.push(this) - 1;
            },

            '': function() {
              this.__base.apply(this, arguments);

              // удаляем из общего массива instances
              instances.splice(this._instanceIndex, 1);
              // понижаем _instanceIndex всем тем кто был добавлен в instances после нас
              var i = this._instanceIndex, instance;
              while (instance = instances[i++]) --instance._instanceIndex;
            },
          },
        },

        /**
         * Нормализация установки фокуса для IE
         * @private
         * @override
         */
        _focus: function() {
          var input = this._elem('control').domElem[0];
          if (input.createTextRange && !input.selectionStart) {
            var range = input.createTextRange();
            range.move('character', input.value.length);
            range.select();
          } else {
            input.focus();
          }
        },
      }));

    });

/* end: ../../node_modules/bem-components/desktop.blocks/input/input.js */
/* begin: ../../5th.blocks/common.blocks/input/input.js */
modules.define('input', ['i-bem-dom'], function(provide, bemDom, Input) {

  var undef;

  provide(bemDom.declBlock(Input, {
    /**
     * Sets control value
     * @param {String} val value
     * @param {Object} [data] additional data
     * @returns {input} this
     */
    setVal: function(val, data) {
      var isValUndef = val === undef;

      isValUndef || (val = String(val));

      if (this._val !== val) {
        this._val = val;

        var control = this._elem('control');
        control.domElem.val() !== val && control.domElem.val(val);

        this._emit('change', data);
      }

      return this;
    },
  }));

});

/* end: ../../5th.blocks/common.blocks/input/input.js */
/* begin: ../../node_modules/bem-core/common.blocks/tick/tick.vanilla.js */
/**
 * @module tick
 * @description Helpers for polling anything
 */

modules.define('tick', ['inherit', 'events'],
    function(provide, inherit, events) {

      var TICK_INTERVAL = 50,
          global = this.global,

          /**
           * @class Tick
           * @augments events:Emitter
           */
          Tick = inherit(events.Emitter, /** @lends Tick.prototype */{
            /**
             * @constructor
             */
            __constructor: function() {
              this._timer = null;
              this._isStarted = false;
            },

            /**
             * Starts polling
             */
            start: function() {
              if (!this._isStarted) {
                this._isStarted = true;
                this._scheduleTick();
              }
            },

            /**
             * Stops polling
             */
            stop: function() {
              if (this._isStarted) {
                this._isStarted = false;
                global.clearTimeout(this._timer);
              }
            },

            _scheduleTick: function() {
              var _this = this;
              this._timer = global.setTimeout(
                  function() {
                    _this._onTick();
                  },
                  TICK_INTERVAL);
            },

            _onTick: function() {
              this.emit('tick');

              this._isStarted && this._scheduleTick();
            },
          });

      provide(
          /**
           * @exports
           * @type Tick
           */
          new Tick());

    });

/* end: ../../node_modules/bem-core/common.blocks/tick/tick.vanilla.js */
/* begin: ../../node_modules/bem-core/common.blocks/idle/idle.js */
/**
 * @module idle
 */

modules.define('idle', ['inherit', 'events', 'jquery'],
    function(provide, inherit, events, $) {

      var IDLE_TIMEOUT = 3000,
          USER_EVENTS = 'mousemove keydown click',
          /**
           * @class Idle
           * @augments events:Emitter
           */
          Idle = inherit(events.Emitter, /** @lends Idle.prototype */{
            /**
             * @constructor
             */
            __constructor: function() {
              this._timer = null;
              this._isStarted = false;
              this._isIdle = false;
            },

            /**
             * Starts monitoring of idle state
             */
            start: function() {
              if (!this._isStarted) {
                this._isStarted = true;
                this._startTimer();
                $(document).on(USER_EVENTS, $.proxy(this._onUserAction, this));
              }
            },

            /**
             * Stops monitoring of idle state
             */
            stop: function() {
              if (this._isStarted) {
                this._isStarted = false;
                this._stopTimer();
                $(document).off(USER_EVENTS, this._onUserAction);
              }
            },

            /**
             * Returns whether state is idle
             * @returns {Boolean}
             */
            isIdle: function() {
              return this._isIdle;
            },

            _onUserAction: function() {
              if (this._isIdle) {
                this._isIdle = false;
                this.emit('wakeup');
              }

              this._stopTimer();
              this._startTimer();
            },

            _startTimer: function() {
              var _this = this;
              this._timer = setTimeout(
                  function() {
                    _this._onTimeout();
                  },
                  IDLE_TIMEOUT);
            },

            _stopTimer: function() {
              this._timer && clearTimeout(this._timer);
            },

            _onTimeout: function() {
              this._isIdle = true;
              this.emit('idle');
            },
          });

      provide(
          /**
           * @exports
           * @type Idle
           */
          new Idle());

    });

/* end: ../../node_modules/bem-core/common.blocks/idle/idle.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_textarea.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['textarea'],
    function(provide, Textarea, FormField) {
      /**
       * Textarea field
       *
       * @exports
       * @class form-field
       * @bem
       */
      provide(FormField.declMod({modName: 'type', modVal: 'textarea'}, {

        getControl: function() {
          return this._control ||
              (this._control = this.findChildBlock(Textarea));
        },

      }, /** @lends form-field_type_textarea */{
        lazyInit: true,

        onInit: function() {
          var ptp = this.prototype;

          this.__base();
          this._events(Textarea).
              on('change', ptp._onControlChange).
              on({modName: 'focused', modVal: true}, ptp._onControlFocus).
              on({modName: 'focused', modVal: ''}, ptp._onControlBlur);
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_textarea.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/textarea/textarea.js */
/**
 * @module textarea
 */

modules.define('textarea', ['i-bem-dom', 'input'],
    function(provide, bemDom, Input) {

      /**
       * @exports
       * @class textarea
       * @augments input
       * @bem
       */
      provide(bemDom.declBlock(this.name, Input));

    });

/* end: ../../node_modules/bem-components/common.blocks/textarea/textarea.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_attach.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['attach'],
    function(provide, Attach, FormField) {
      /**
       * Attach field
       *
       * @exports
       * @class form-field
       * @bem
       */
      provide(FormField.declMod({modName: 'type', modVal: 'attach'}, {

        getControl: function() {
          return this._control || (this._control = this.findChildBlock(Attach));
        },

      }, /** @lends form-field_type_attach */{
        lazyInit: true,

        onInit: function() {
          var ptp = this.prototype;

          this.__base();
          this._events(Attach).
              on('change', ptp._onControlChange).
              on({modName: 'focused', modVal: true}, ptp._onControlFocus).
              on({modName: 'focused', modVal: ''}, ptp._onControlBlur);
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_attach.browser.js */
/* begin: ../../5th.blocks/common.blocks/icon/icon.js */
modules.define('icon', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declBlock(this.name, {
    onSetMod: {
      js: {
        inited: function() {

        },
      },
    },
  }));

});

/* end: ../../5th.blocks/common.blocks/icon/icon.js */
/* begin: ../../node_modules/bem-core/common.blocks/strings/__escape/strings__escape.vanilla.js */
/**
 * @module strings__escape
 * @description A set of string escaping functions
 */

modules.define('strings__escape', function(provide) {

  var symbols = {
        '"': '&quot;',
        '\'': '&apos;',
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
      },
      mapSymbol = function(s) {
        return symbols[s] || s;
      },
      buildEscape = function(regexp) {
        regexp = new RegExp(regexp, 'g');
        return function(str) {
          return ('' + str).replace(regexp, mapSymbol);
        };
      };

  provide(/** @exports */{
    /**
     * Escape string to use in XML
     * @type Function
     * @param {String} str
     * @returns {String}
     */
    xml: buildEscape('[&<>]'),

    /**
     * Escape string to use in HTML
     * @type Function
     * @param {String} str
     * @returns {String}
     */
    html: buildEscape('[&<>]'),

    /**
     * Escape string to use in attributes
     * @type Function
     * @param {String} str
     * @returns {String}
     */
    attr: buildEscape('["\'&<>]'),
  });

});

/* end: ../../node_modules/bem-core/common.blocks/strings/__escape/strings__escape.vanilla.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_checkbox.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['checkbox'],
    function(provide, Checkbox, FormField) {
      /**
       * Checkbox field
       *
       * @exports
       * @class form-field
       * @bem
       */
      provide(FormField.declMod({modName: 'type', modVal: 'checkbox'},
          /** @lends form-field_type_checkbox.prototype */{
            getControl: function() {
              return this._control ||
                  (this._control = this.findChildBlock(Checkbox));
            },
            /**
             * Returns field value if checked or empty string (?)
             * @returns {String}
             */
            getVal: function() {
              var control = this.getControl();
              return control.hasMod('checked') ? control.getVal() : '';
            },
            /**
             * Sets checked on if value is true or off if false
             * @param {String} val значение
             */
            setVal: function(val) {
              this.__base.apply(this, arguments);
              this.getControl().setMod('checked', !!val);
            },
            _onControlChange: function(e, data) {
              /**
               * Input data change event
               *
               * @event FormField#change
               * @type {Object}
               */
              this._emit('change', data);
            },
          }, /** @lends form-field_type_checkbox */{
            lazyInit: true,

            onInit: function() {
              var ptp = this.prototype;

              this.__base();
              this._events(Checkbox).
                  on({modName: 'checked', modVal: '*'}, ptp._onControlChange).
                  on({modName: 'focused', modVal: true}, ptp._onControlFocus).
                  on({modName: 'focused', modVal: ''}, ptp._onControlBlur);
            },
          }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_checkbox.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/checkbox/checkbox.js */
/**
 * @module checkbox
 */

modules.define('checkbox', ['i-bem-dom', 'control'],
    function(provide, bemDom, Control) {

      /**
       * @exports
       * @class checkbox
       * @augments control
       * @bem
       */
      provide(
          bemDom.declBlock(this.name, Control, /** @lends checkbox.prototype */{
            onSetMod: {
              'checked': {
                'true': function() {
                  this._elem('control').
                      domElem.
                      attr('checked', true).
                      prop('checked', true);
                },
                '': function() {
                  this._elem('control').
                      domElem.
                      removeAttr('checked').
                      prop('checked', false);
                },
              },
            },

            _onChange: function() {
              this.setMod('checked',
                  this._elem('control').domElem.prop('checked'));
            },
          }, /** @lends checkbox */{
            lazyInit: true,
            onInit: function() {
              this._domEvents('control').on('change', this.prototype._onChange);
              return this.__base.apply(this, arguments);
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/checkbox/checkbox.js */
/* begin: ../../node_modules/bem-forms/common.blocks/checkbox/checkbox.browser.js */
modules.define('checkbox', ['i-bem-dom'],
    function(provide, bemDom, Checkbox) {
      /**
       * @exports
       * @class checkbox
       * @augments control
       * @bem
       */
      provide(bemDom.declBlock(Checkbox, {
        /**
         * Emit change event
         * @private
         */
        _onChange: function() {
          this.__base.apply(this, arguments);
          this._emit('change');
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/checkbox/checkbox.browser.js */
/* begin: ../../5th.blocks/common.blocks/checkbox/checkbox.js */
modules.define('checkbox', ['i-bem-dom'], function(provide, bemDom, Checkbox) {

  provide(bemDom.declBlock(Checkbox, {
    /**
     * Sets control value
     * @param {String} val value
     * @param {Object} [data] additional data
     * @returns {input} this
     */
    setVal: function(val, data) {
      this.setMod('checked', val ? true : false);
      return this;
    },
  }));

});

/* end: ../../5th.blocks/common.blocks/checkbox/checkbox.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_checkbox-group.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['checkbox-group'],
    function(provide, CheckboxGroup, FormField) {
      /**
       * Checkbox-group field
       *
       * @exports
       * @class form-field
       * @bem
       */
      provide(FormField.declMod({modName: 'type', modVal: 'checkbox-group'}, {

        getControl: function() {
          return this._control ||
              (this._control = this.findChildBlock(CheckboxGroup));
        },

      }, /** @lends form-field_type_checkbox */{
        lazyInit: true,

        onInit: function() {
          var ptp = this.prototype;

          this.__base();
          this._events(CheckboxGroup).
              on('change', ptp._onControlChange).
              on({modName: 'focused', modVal: true}, ptp._onControlFocus).
              on({modName: 'focused', modVal: ''}, ptp._onControlBlur);
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_checkbox-group.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/checkbox-group/checkbox-group.js */
/**
 * @module checkbox-group
 */

modules.define(
    'checkbox-group',
    ['i-bem-dom', 'jquery', 'dom', 'checkbox'],
    function(provide, bemDom, $, dom, Checkbox) {

      var undef;
      /**
       * @exports
       * @class checkbox-group
       * @bem
       */
      provide(
          bemDom.declBlock(this.name, /** @lends checkbox-group.prototype */{
            beforeSetMod: {
              'focused': {
                'true': function() {
                  return !this.hasMod('disabled');
                },
              },
            },

            onSetMod: {
              'js': {
                'inited': function() {
                  this._inSetVal = false;
                  this._val = this._extractVal();
                  this._checkboxes = undef;
                },
              },

              'disabled': function(modName, modVal) {
                this.getCheckboxes().setMod(modName, modVal);
              },

              'focused': {
                'true': function() {
                  if (dom.containsFocus(this.domElem)) return;

                  var checkboxes = this.getCheckboxes(),
                      i = 0, checkbox;

                  while (checkbox = checkboxes.get(i++)) {
                    if (checkbox.setMod('focused').hasMod('focused')) // we need to be sure that checkbox has got focus
                      return;
                  }
                },

                '': function() {
                  var focusedCheckbox = this.findChildBlock({
                    block: Checkbox,
                    modName: 'focused',
                    modVal: true,
                  });

                  focusedCheckbox && focusedCheckbox.delMod('focused');
                },
              },
            },

            /**
             * Returns control value
             * @returns {String}
             */
            getVal: function() {
              return this._val;
            },

            /**
             * Sets control value
             * @param {Array[String]} val value
             * @param {Object} [data] additional data
             * @returns {checkbox-group} this
             */
            setVal: function(val, data) {
              val = val.map(String);

              var checkboxes = this.getCheckboxes(),
                  wasChanged = false,
                  notFoundValsCnt = val.length,
                  checkboxesCheckedModVals = checkboxes.map(function(checkbox) {
                    var isChecked = checkbox.hasMod('checked'),
                        hasEqVal = !!~val.indexOf(checkbox.getVal());

                    if (hasEqVal) {
                      --notFoundValsCnt;
                      isChecked || (wasChanged = true);
                    } else {
                      isChecked && (wasChanged = true);
                    }

                    return hasEqVal;
                  });

              if (wasChanged && !notFoundValsCnt) {
                this._inSetVal = true;
                checkboxes.forEach(function(checkbox, i) {
                  checkbox.setMod('checked', checkboxesCheckedModVals[i]);
                });
                this._inSetVal = false;
                this._val = val;
                this._emit('change', data);
              }

              return this;
            },

            /**
             * Returns name of control
             * @returns {String}
             */
            getName: function() {
              return this.getCheckboxes().get(0).getName();
            },

            /**
             * Returns checkboxes
             * @returns {Array[checkbox]}
             */
            getCheckboxes: function() {
              return this._checkboxes ||
                  (this._checkboxes = this.findChildBlocks(Checkbox));
            },

            _extractVal: function() {
              return this.getCheckboxes().filter(function(checkbox) {
                return checkbox.hasMod('checked');
              }).map(function(checkbox) {
                return checkbox.getVal();
              });
            },

            _onCheckboxCheck: function() {
              if (!this._inSetVal) {
                this._val = this._extractVal();
                this._emit('change');
              }
            },

            _onCheckboxFocus: function(e) {
              this.setMod('focused', e.target.getMod('focused'));
            },
          }, /** @lends checkbox-group */{
            lazyInit: true,
            onInit: function() {
              var ptp = this.prototype;
              this._events(Checkbox).
                  on({modName: 'checked', modVal: '*'}, ptp._onCheckboxCheck).
                  on({modName: 'focused', modVal: '*'}, ptp._onCheckboxFocus);
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/checkbox-group/checkbox-group.js */
/* begin: ../../5th.blocks/common.blocks/checkbox-group/checkbox-group.js */
/**
 * @module checkbox-group
 */

modules.define(
    'checkbox-group',
    ['i-bem-dom', 'jquery', 'dom', 'checkbox'],
    function(provide, bemDom, $, dom, Checkbox) {

      var undef;
      /**
       * @exports
       * @class checkbox-group
       * @bem
       */
      provide(
          bemDom.declBlock(this.name, /** @lends checkbox-group.prototype */{
            beforeSetMod: {
              'focused': {
                'true': function() {
                  return !this.hasMod('disabled');
                },
              },
            },

            onSetMod: {
              'js': {
                'inited': function() {
                  this._inSetVal = false;
                  this._val = this._extractVal();
                  this._checkboxes = undef;
                },
              },

              'disabled': function(modName, modVal) {
                this.getCheckboxes().setMod(modName, modVal);
              },

              'focused': {
                'true': function() {
                  if (dom.containsFocus(this.domElem)) return;

                  var checkboxes = this.getCheckboxes(),
                      i = 0, checkbox;

                  while (checkbox = checkboxes.get(i++)) {
                    if (checkbox.setMod('focused').hasMod('focused')) // we need to be sure that checkbox has got focus
                      return;
                  }
                },

                '': function() {
                  var focusedCheckbox = this.findChildBlock({
                    block: Checkbox,
                    modName: 'focused',
                    modVal: true,
                  });

                  focusedCheckbox && focusedCheckbox.delMod('focused');
                },
              },
            },

            /**
             * Returns control value
             * @returns {String}
             */
            getVal: function() {
              return this._val;
            },

            /**
             * Sets control value
             * @param {Array[String]} val value
             * @param {Object} [data] additional data
             * @returns {checkbox-group} this
             */
            setVal: function(val, data) {
              val = val.map(String);

              var checkboxes = this.getCheckboxes(),
                  wasChanged = false,
                  notFoundValsCnt = val.length,
                  checkboxesCheckedModVals = checkboxes.map(function(checkbox) {
                    var isChecked = checkbox.hasMod('checked'),
                        hasEqVal = !!~val.indexOf(checkbox.getVal());

                    if (hasEqVal) {
                      --notFoundValsCnt;
                      isChecked || (wasChanged = true);
                    } else {
                      isChecked && (wasChanged = true);
                    }

                    return hasEqVal;
                  });

              if (wasChanged && !notFoundValsCnt) {
                this._inSetVal = true;
                checkboxes.forEach(function(checkbox, i) {
                  checkbox.setMod('checked', checkboxesCheckedModVals[i]);
                });
                this._inSetVal = false;
                this._val = val;
                this._emit('change', data);
              }

              return this;
            },

            /**
             * Returns name of control
             * @returns {String}
             */
            getName: function() {
              return this.getCheckboxes().get(0).getName();
            },

            /**
             * Returns checkboxes
             * @returns {Array[checkbox]}
             */
            getCheckboxes: function() {
              return this._checkboxes ||
                  (this._checkboxes = this.findChildBlocks(Checkbox));
            },

            _extractVal: function() {
              return this.getCheckboxes().filter(function(checkbox) {
                return checkbox.hasMod('checked');
              }).map(function(checkbox) {
                return checkbox.getVal();
              });
            },

            _onCheckboxCheck: function() {
              if (!this._inSetVal) {
                this._val = this._extractVal();
                this._emit('change');
              }
            },

            _onCheckboxFocus: function(e) {
              this.setMod('focused', e.target.getMod('focused'));
            },
          }, /** @lends checkbox-group */{
            lazyInit: true,
            onInit: function() {
              var ptp = this.prototype;
              this._events(Checkbox).
                  on({modName: 'checked', modVal: '*'}, ptp._onCheckboxCheck).
                  on({modName: 'focused', modVal: '*'}, ptp._onCheckboxFocus);
            },
          }));

    });

/* end: ../../5th.blocks/common.blocks/checkbox-group/checkbox-group.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_radio.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['radio'],
    function(provide, Radio, FormField) {
      /**
       * Radio field
       *
       * @exports
       * @class form-field
       * @bem
       */
      provide(FormField.declMod({modName: 'type', modVal: 'radio'}, {

        getControl: function() {
          return this._control || (this._control = this.findChildBlock(Radio));
        },

      }, /** @lends form-field_type_radio */{
        lazyInit: true,

        onInit: function() {
          var ptp = this.prototype;

          this.__base();
          this._events(Radio).
              on('change', ptp._onControlChange).
              on({modName: 'focused', modVal: true}, ptp._onControlFocus).
              on({modName: 'focused', modVal: ''}, ptp._onControlBlur);
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_radio.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/radio/radio.js */
/**
 * @module radio
 */

modules.define(
    'radio',
    ['i-bem-dom', 'control'],
    function(provide, bemDom, Control) {

      /**
       * @exports
       * @class radio
       * @augments control
       * @bem
       */
      provide(
          bemDom.declBlock(this.name, Control, /** @lends radio.prototype */{
            onSetMod: {
              'checked': {
                'true': function() {
                  this._elem('control').
                      domElem.
                      attr('checked', true).
                      prop('checked', true);
                },
                '': function() {
                  this._elem('control').
                      domElem.
                      removeAttr('checked').
                      prop('checked', false);
                },
              },
            },

            _onChange: function() {
              this.hasMod('disabled') || this.setMod('checked');
            },
          }, /** @lends radio */{
            lazyInit: true,
            onInit: function() {
              this._domEvents().on('change', this.prototype._onChange);
              return this.__base.apply(this, arguments);
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/radio/radio.js */
/* begin: ../../node_modules/bem-forms/common.blocks/radio/radio.browser.js */
modules.define('radio', ['i-bem-dom'],
    function(provide, bemDom, Radio) {
      /**
       * @exports
       * @class radio
       * @augments control
       * @bem
       */
      provide(bemDom.declBlock(Radio, {
        /**
         * Emit change event
         * @private
         */
        _onChange: function() {
          this.__base.apply(this, arguments);
          this._emit('change');
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/radio/radio.browser.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_radio-group.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['radio-group'],
    function(provide, RadioGroup, FormField) {
      /**
       * Radio-group field
       *
       * @exports
       * @class form-field
       * @bem
       */
      provide(FormField.declMod({modName: 'type', modVal: 'radio-group'}, {

        getControl: function() {
          return this._control ||
              (this._control = this.findChildBlock(RadioGroup));
        },

      }, /** @lends form-field_type_radio-group */{
        lazyInit: true,

        onInit: function() {
          var ptp = this.prototype;

          this.__base();
          this._events(RadioGroup).
              on('change', ptp._onControlChange).
              on({modName: 'focused', modVal: true}, ptp._onControlFocus).
              on({modName: 'focused', modVal: ''}, ptp._onControlBlur);
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_radio-group.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/radio-group/radio-group.js */
/**
 * @module radio-group
 */

modules.define(
    'radio-group',
    ['i-bem-dom', 'jquery', 'dom', 'radio'],
    function(provide, bemDom, $, dom, Radio) {

      var undef;
      /**
       * @exports
       * @class radio-group
       * @bem
       */
      provide(bemDom.declBlock(this.name, /** @lends radio-group.prototype */{
        beforeSetMod: {
          'focused': {
            'true': function() {
              return !this.hasMod('disabled');
            },
          },
        },

        onSetMod: {
          'js': {
            'inited': function() {
              this._checkedRadio = this.findChildBlock({
                block: Radio,
                modName: 'checked',
                modVal: true,
              });

              this._inSetVal = false;
              this._val = this._checkedRadio ?
                  this._checkedRadio.getVal() :
                  undef;
              this._radios = undef;
            },
          },

          'disabled': function(modName, modVal) {
            this.getRadios().setMod(modName, modVal);
          },

          'focused': {
            'true': function() {
              if (dom.containsFocus(this.domElem)) return;

              var radios = this.getRadios(),
                  i = 0, radio;

              while (radio = radios.get(i++)) {
                if (radio.setMod('focused').hasMod('focused')) { // we need to be sure that radio has got focus
                  return;
                }
              }
            },

            '': function() {
              var focusedRadio = this.findChildBlock({
                block: Radio,
                modName: 'focused',
                modVal: true,
              });

              focusedRadio && focusedRadio.delMod('focused');
            },
          },
        },

        /**
         * Returns control value
         * @returns {String}
         */
        getVal: function() {
          return this._val;
        },

        /**
         * Sets control value
         * @param {String} val value
         * @param {Object} [data] additional data
         * @returns {radio-group} this
         */
        setVal: function(val, data) {
          var isValUndef = val === undef;

          isValUndef || (val = String(val));

          if (this._val !== val) {
            if (isValUndef) {
              this._val = undef;
              this._checkedRadio.delMod('checked');
              this._emit('change', data);
            } else {
              var radio = this._getRadioByVal(val);
              if (radio) {
                this._inSetVal = true;

                this._val !== undef &&
                this._getRadioByVal(this._val).delMod('checked');
                this._val = radio.getVal();
                radio.setMod('checked');

                this._inSetVal = false;
                this._emit('change', data);
              }
            }
          }

          return this;
        },

        /**
         * Returns name of control
         * @returns {String}
         */
        getName: function() {
          return this.getRadios().get(0).getName();
        },

        /**
         * Returns options
         * @returns {radio[]}
         */
        getRadios: function() {
          return this._radios || (this._radios = this.findChildBlocks(Radio));
        },

        _getRadioByVal: function(val) {
          var radios = this.getRadios(),
              i = 0, option;

          while (option = radios.get(i++)) {
            if (option.getVal() === val) {
              return option;
            }
          }
        },

        _onRadioCheck: function(e) {
          var radioVal = (this._checkedRadio = e.target).getVal();
          if (!this._inSetVal) {
            if (this._val === radioVal) {
              // on block init value set in constructor, we need remove old checked and emit "change" event
              this.getRadios().forEach(function(radio) {
                radio.getVal() !== radioVal && radio.delMod('checked');
              });
              this._emit('change');
            } else {
              this.setVal(radioVal);
            }
          }
        },

        _onRadioFocus: function(e) {
          this.setMod('focused', e.target.getMod('focused'));
        },
      }, /** @lends radio-group */{
        lazyInit: true,
        onInit: function() {
          var ptp = this.prototype;
          this._events(Radio).
              on({modName: 'checked', modVal: true}, ptp._onRadioCheck).
              on({modName: 'focused', modVal: '*'}, ptp._onRadioFocus);
        },
      }));

    });

/* end: ../../node_modules/bem-components/common.blocks/radio-group/radio-group.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_required/form-field_required.browser.js */
/**
 * @module form-field
 */
modules.define('form-field',
    ['validation_required'],
    function(provide, validation_required, FormField) {
      /**
       * Required form-field
       * @exports
       * @class form-field
       * @bem
       */
      FormField.declMod({modName: 'required', modVal: true},
          /** @lends form-field.prototype */{

            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);

                  this.params.required && this.setValidationMessages({
                    required: this.params.required.message,
                  });

                  this.getValidator().push(validation_required(this));
                },
              },
            },

          });

      provide(FormField);

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_required/form-field_required.browser.js */
/* begin: ../../node_modules/bem-forms/common.blocks/validation/_required/validation_required.browser.js */
/**
 * @module validation_required
 */
modules.define('validation_required',
    function(provide) {

      var DEFAULT_MESSAGE = 'Required field';
      provide(function(field) {
        return function(val) {
          return val ? null : {
            field: field.getName() || field.getId(),
            message: field.getValidationMessage('required') || DEFAULT_MESSAGE,
          };
        };
      });

    });

/* end: ../../node_modules/bem-forms/common.blocks/validation/_required/validation_required.browser.js */
/* begin: ../../5th.blocks/common.blocks/validation/_required/validation_required.js */
/**
 * @module validation_required
 */
modules.define('validation_required',
    function(provide) {

      var DEFAULT_MESSAGE = 'Required field';
      provide(function(field) {
        return function(val) {
          return val && val !== 'undefined' ? null : {
            field: field.getName() || field.getId(),
            message: field.getValidationMessage('required') || DEFAULT_MESSAGE,
          };
        };
      });

    });

/* end: ../../5th.blocks/common.blocks/validation/_required/validation_required.js */
/* begin: ../../node_modules/bem-forms/common.blocks/validation/_email/validation_email.browser.js */
/**
 * @module validation_email
 */
modules.define('validation_email',
    function(provide) {

      var DEFAULT_MESSAGE = 'Field requires email inside',
          EMAIL_RE = /^([0-9a-zA-Z]*[-._+])*[0-9a-zA-Z]+@[0-9a-zA-Z]+([-.][0-9a-zA-Z]+)*([0-9a-zA-Z]*[.])[a-zA-Z]{2,6}$/;

      provide(function(field) {
        return function(val) {
          return !val || EMAIL_RE.test(val) ? null : {
            field: field.getName() || field.getId(),
            message: field.getValidationMessage('email') || DEFAULT_MESSAGE,
          };
        };
      });

    });

/* end: ../../node_modules/bem-forms/common.blocks/validation/_email/validation_email.browser.js */
/* begin: ../../5th.blocks/common.blocks/validation/_email/validation_email.browser.js */
/**
 * @module validation_email
 */
modules.define('validation_email',
    function(provide) {

      var DEFAULT_MESSAGE = 'Введите корректный адрес',
          EMAIL_RE = /^([0-9a-zA-Z]*[-._+])*[0-9a-zA-Z]+@[0-9a-zA-Z]+([-.][0-9a-zA-Z]+)*([0-9a-zA-Z]*[.])[a-zA-Z]{2,6}$/;

      provide(function(field) {
        return function(val) {
          return !val || EMAIL_RE.test(val) ? null : {
            field: field.getName() || field.getId(),
            message: field.getValidationMessage('email') || DEFAULT_MESSAGE,
          };
        };
      });

    });

/* end: ../../5th.blocks/common.blocks/validation/_email/validation_email.browser.js */
/* begin: ../../5th.blocks/common.blocks/form-field/_validate/form-field_validate_pattern.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['validation_pattern', 'objects'],
    function(provide, validatePattern, objects, FormField) {
      /**
       * Pattern form-field validation
       * @exports
       * @class form-field
       * @bem
       */
      FormField.declMod({modName: 'validate', modVal: 'pattern'},
          /** @lends form-field.prototype */{

            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);

                  this.params.pattern && this.setValidationMessages({
                    pattern: this.params.pattern.message,
                  });

                  this.getValidator().push(validatePattern(this));
                },
              },
            },

          });

      provide(FormField);

    });

/* end: ../../5th.blocks/common.blocks/form-field/_validate/form-field_validate_pattern.browser.js */
/* begin: ../../node_modules/bem-forms/common.blocks/validation/_pattern/validation_pattern.browser.js */
/**
 * @module validation_pattern
 */
modules.define('validation_pattern',
    function(provide) {

      var DEFAULT_MESSAGE = 'Should match provided pattern "%s"';
      provide(function(field) {
        if (!field.params.pattern && !field.params.pattern.value) {
          return function() {
            return null;
          };
        }

        var re = new RegExp(field.params.value);
        return function(val) {
          return !val || re.test(val) ? null : {
            field: field.getName() || field.getId(),
            message: field.getValidationMessage('pattern') ||
            DEFAULT_MESSAGE.replace(/%s/g, field.params.value),
          };
        };

      });

    });

/* end: ../../node_modules/bem-forms/common.blocks/validation/_pattern/validation_pattern.browser.js */
/* begin: ../../5th.blocks/common.blocks/validation/_pattern/validation_pattern.browser.js */
/**
 * @module validation_pattern
 */
modules.define('validation_pattern',
    function(provide) {

      var DEFAULT_MESSAGE = 'Should match provided pattern "%s"';
      provide(function(field) {
        var pattern = field.params.pattern;

        if (!pattern && !pattern.value) {
          return function() {
            return null;
          };
        }

        var re = new RegExp(pattern.value);
        return function(val) {
          return !val || re.test(val) ? null : {
            field: field.getName() || field.getId(),
            message: field.getValidationMessage('pattern') ||
            DEFAULT_MESSAGE.replace(/%s/g, pattern.value),
          };
        };

      });

    });

/* end: ../../5th.blocks/common.blocks/validation/_pattern/validation_pattern.browser.js */
/* begin: ../../5th.blocks/common.blocks/form-field/_validate/form-field_validate_equal.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['jquery'],
    function(provide, $, FormField) {

      var DEFAULT_MESSAGE = 'It\'s not equal';

      /**
       * Equal form-field validation
       * @exports
       * @class form-field
       * @bem
       */
      FormField.declMod({modName: 'validate', modVal: 'equal'},
          /** @lends form-field.prototype */{

            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);

                  this.params.equal && this.setValidationMessages({
                    equal: this.params.equal.message,
                  });

                  this.getValidator().push(this._validateEqual(this));
                },
              },
            },

            _validateEqual: function(field) {
              var fieldForCompare = this._fieldForCompare ||
                  this._getFieldForCompare();
              return function(val) {
                if (!fieldForCompare) return null;
                return val === fieldForCompare.getVal() ? null : {
                  field: field.getName() || field.getId(),
                  message: field.getValidationMessage('equal') ||
                  DEFAULT_MESSAGE,
                };
              };
            },

            /**
             * @return {BemEntity}
             */
            _getFieldForCompare: function() {
              var equal = this.params.equal;

              if (!equal || !equal.field) return null;

              var field = this.domElem.closest('.form').find(equal.field);

              return field.length ? field.bem(FormField) : null;
            },

          });

      provide(FormField);

    });

/* end: ../../5th.blocks/common.blocks/form-field/_validate/form-field_validate_equal.browser.js */
/* begin: ../../5th.blocks/common.blocks/button/_has-spin/button_has-spin.js */
modules.define('button', ['i-bem-dom', 'spin'],
    function(provide, bemDom, Spin, Button) {

      provide(Button.declMod({modName: 'has-spin', modVal: true}, {
        onSetMod: {
          'js': {
            'inited': function() {
              this.__base.apply(this, arguments);
              this._spin = this.findChildBlock(Spin);
            },
          },

          'spin-visible': function(modName, modVal, oldModVal) {
            this._spin && this._spin.setMod('visible', modVal);
          },
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/button/_has-spin/button_has-spin.js */
/* begin: ../../node_modules/bem-components/common.blocks/spin/spin.js */
modules.define('spin', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declBlock(this.name));

});

/* end: ../../node_modules/bem-components/common.blocks/spin/spin.js */
/* begin: ../../5th.blocks/common.blocks/input-mask/input-mask.js */
modules.define('input-mask',
    ['i-bem-dom', 'jquery__inputmask', 'input', 'control'],
    function(provide, bemDom, $, Input, Control) {

      provide(bemDom.declBlock(this.name, {
        onSetMod: {
          'js': {
            'inited': function() {
              this._inputControl = this.findMixedBlock(Input)._elem('control');
              this._setMask();
            },
          },
        },

        _setMask: function() {

        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/input-mask/input-mask.js */
/* begin: ../../5th.blocks/common.blocks/jquery/__inputmask/jquery__inputmask.js */
modules.define('jquery__inputmask', ['jquery'], function(provide, $) {

  window.jQuery = jQuery = $;

  /* ../../node_modules/inputmask/dist/jquery.inputmask.bundle.js begin */
  /*!
* jquery.inputmask.bundle.js
* https://github.com/RobinHerbots/Inputmask
* Copyright (c) 2010 - 2018 Robin Herbots
* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
* Version: 4.0.2
*/

  (function(modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
      if (installedModules[moduleId]) {
        return installedModules[moduleId].exports;
      }
      var module = installedModules[moduleId] = {
        i: moduleId,
        l: false,
        exports: {},
      };
      modules[moduleId].call(module.exports, module, module.exports,
          __webpack_require__);
      module.l = true;
      return module.exports;
    }

    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.d = function(exports, name, getter) {
      if (!__webpack_require__.o(exports, name)) {
        Object.defineProperty(exports, name, {
          enumerable: true,
          get: getter,
        });
      }
    };
    __webpack_require__.r = function(exports) {
      if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module',
        });
      }
      Object.defineProperty(exports, '__esModule', {
        value: true,
      });
    };
    __webpack_require__.t = function(value, mode) {
      if (mode & 1) value = __webpack_require__(value);
      if (mode & 8) return value;
      if (mode & 4 && typeof value === 'object' && value &&
          value.__esModule) return value;
      var ns = Object.create(null);
      __webpack_require__.r(ns);
      Object.defineProperty(ns, 'default', {
        enumerable: true,
        value: value,
      });
      if (mode & 2 && typeof value !=
          'string') for (var key in value) __webpack_require__.d(ns, key,
          function(key) {
            return value[key];
          }.bind(null, key));
      return ns;
    };
    __webpack_require__.n = function(module) {
      var getter = module && module.__esModule ? function getDefault() {
        return module['default'];
      } : function getModuleExports() {
        return module;
      };
      __webpack_require__.d(getter, 'a', getter);
      return getter;
    };
    __webpack_require__.o = function(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };
    __webpack_require__.p = '';
    return __webpack_require__(__webpack_require__.s = 0);
  })([
    function(module, exports, __webpack_require__) {
      'use strict';
      __webpack_require__(1);
      __webpack_require__(7);
      __webpack_require__(8);
      var _inputmask = __webpack_require__(2);
      var _inputmask2 = _interopRequireDefault(_inputmask);
      var _inputmask3 = __webpack_require__(3);
      var _inputmask4 = _interopRequireDefault(_inputmask3);
      var _jquery = __webpack_require__(4);
      var _jquery2 = _interopRequireDefault(_jquery);

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
          default: obj,
        };
      }

      if (_inputmask4.default === _jquery2.default) {
        __webpack_require__(9);
      }
      window.Inputmask = _inputmask2.default;
    }, function(module, exports, __webpack_require__) {
      'use strict';
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' &&
      typeof Symbol.iterator === 'symbol' ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === 'function' &&
        obj.constructor === Symbol && obj !== Symbol.prototype ?
            'symbol' :
            typeof obj;
      };
      (function(factory) {
        if (true) {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = factory,
              __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
              'function' ?
                  __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports,
                      __WEBPACK_AMD_DEFINE_ARRAY__) :
                  __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(function(Inputmask) {
        Inputmask.extendDefinitions({
          A: {
            validator: '[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]',
            casing: 'upper',
          },
          '&': {
            validator: '[0-9A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]',
            casing: 'upper',
          },
          '#': {
            validator: '[0-9A-Fa-f]',
            casing: 'upper',
          },
        });
        Inputmask.extendAliases({
          cssunit: {
            regex: '[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)',
          },
          url: {
            regex: '(https?|ftp)//.*',
            autoUnmask: false,
          },
          ip: {
            mask: 'i[i[i]].i[i[i]].i[i[i]].i[i[i]]',
            definitions: {
              i: {
                validator: function validator(
                    chrs, maskset, pos, strict, opts) {
                  if (pos - 1 > -1 && maskset.buffer[pos - 1] !== '.') {
                    chrs = maskset.buffer[pos - 1] + chrs;
                    if (pos - 2 > -1 && maskset.buffer[pos - 2] !== '.') {
                      chrs = maskset.buffer[pos - 2] + chrs;
                    } else chrs = '0' + chrs;
                  } else chrs = '00' + chrs;
                  return new RegExp('25[0-5]|2[0-4][0-9]|[01][0-9][0-9]').test(
                      chrs);
                },
              },
            },
            onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
              return maskedValue;
            },
            inputmode: 'numeric',
          },
          email: {
            mask: '*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]',
            greedy: false,
            casing: 'lower',
            onBeforePaste: function onBeforePaste(pastedValue, opts) {
              pastedValue = pastedValue.toLowerCase();
              return pastedValue.replace('mailto:', '');
            },
            definitions: {
              '*': {
                validator: '[0-9\uff11-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5!#$%&\'*+/=?^_`{|}~-]',
              },
              '-': {
                validator: '[0-9A-Za-z-]',
              },
            },
            onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
              return maskedValue;
            },
            inputmode: 'email',
          },
          mac: {
            mask: '##:##:##:##:##:##',
          },
          vin: {
            mask: 'V{13}9{4}',
            definitions: {
              V: {
                validator: '[A-HJ-NPR-Za-hj-npr-z\\d]',
                casing: 'upper',
              },
            },
            clearIncomplete: true,
            autoUnmask: true,
          },
        });
        return Inputmask;
      });
    }, function(module, exports, __webpack_require__) {
      'use strict';
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' &&
      typeof Symbol.iterator === 'symbol' ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === 'function' &&
        obj.constructor === Symbol && obj !== Symbol.prototype ?
            'symbol' :
            typeof obj;
      };
      (function(factory) {
        if (true) {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(3),
            __webpack_require__(5),
            __webpack_require__(6)],
              __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
          'function' ?
              __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__) :
              __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(function($, window, document, undefined) {
        var ua = navigator.userAgent,
            mobile = isInputEventSupported('touchstart'),
            iemobile = /iemobile/i.test(ua),
            iphone = /iphone/i.test(ua) && !iemobile;

        function Inputmask(alias, options, internal) {
          if (!(this instanceof Inputmask)) {
            return new Inputmask(alias, options, internal);
          }
          this.el = undefined;
          this.events = {};
          this.maskset = undefined;
          this.refreshValue = false;
          if (internal !== true) {
            if ($.isPlainObject(alias)) {
              options = alias;
            } else {
              options = options || {};
              if (alias) options.alias = alias;
            }
            this.opts = $.extend(true, {}, this.defaults, options);
            this.noMasksCache = options && options.definitions !== undefined;
            this.userOptions = options || {};
            this.isRTL = this.opts.numericInput;
            resolveAlias(this.opts.alias, options, this.opts);
          }
        }

        Inputmask.prototype = {
          dataAttribute: 'data-inputmask',
          defaults: {
            placeholder: '_',
            optionalmarker: ['[', ']'],
            quantifiermarker: ['{', '}'],
            groupmarker: ['(', ')'],
            alternatormarker: '|',
            escapeChar: '\\',
            mask: null,
            regex: null,
            oncomplete: $.noop,
            onincomplete: $.noop,
            oncleared: $.noop,
            repeat: 0,
            greedy: false,
            autoUnmask: false,
            removeMaskOnSubmit: false,
            clearMaskOnLostFocus: true,
            insertMode: true,
            clearIncomplete: false,
            alias: null,
            onKeyDown: $.noop,
            onBeforeMask: null,
            onBeforePaste: function onBeforePaste(pastedValue, opts) {
              return $.isFunction(opts.onBeforeMask) ?
                  opts.onBeforeMask.call(this, pastedValue, opts) :
                  pastedValue;
            },
            onBeforeWrite: null,
            onUnMask: null,
            showMaskOnFocus: true,
            showMaskOnHover: true,
            onKeyValidation: $.noop,
            skipOptionalPartCharacter: ' ',
            numericInput: false,
            rightAlign: false,
            undoOnEscape: true,
            radixPoint: '',
            _radixDance: false,
            groupSeparator: '',
            keepStatic: null,
            positionCaretOnTab: true,
            tabThrough: false,
            supportsInputType: ['text', 'tel', 'password', 'search'],
            ignorables: [
              8,
              9,
              13,
              19,
              27,
              33,
              34,
              35,
              36,
              37,
              38,
              39,
              40,
              45,
              46,
              93,
              112,
              113,
              114,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              122,
              123,
              0,
              229],
            isComplete: null,
            preValidation: null,
            postValidation: null,
            staticDefinitionSymbol: undefined,
            jitMasking: false,
            nullable: true,
            inputEventOnly: false,
            noValuePatching: false,
            positionCaretOnClick: 'lvp',
            casing: null,
            inputmode: 'verbatim',
            colorMask: false,
            disablePredictiveText: false,
            importDataAttributes: true,
          },
          definitions: {
            9: {
              validator: '[0-9\uff11-\uff19]',
              definitionSymbol: '*',
            },
            a: {
              validator: '[A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]',
              definitionSymbol: '*',
            },
            '*': {
              validator: '[0-9\uff11-\uff19A-Za-z\u0410-\u044f\u0401\u0451\xc0-\xff\xb5]',
            },
          },
          aliases: {},
          masksCache: {},
          mask: function mask(elems) {
            var that = this;

            function importAttributeOptions(
                npt, opts, userOptions, dataAttribute) {
              if (opts.importDataAttributes === true) {
                var importOption = function importOption(option, optionData) {
                  optionData = optionData !== undefined ?
                      optionData :
                      npt.getAttribute(dataAttribute + '-' + option);
                  if (optionData !== null) {
                    if (typeof optionData === 'string') {
                      if (option.indexOf('on') ===
                          0) optionData = window[optionData]; else if (optionData ===
                          'false') optionData = false; else if (optionData ===
                          'true') optionData = true;
                    }
                    userOptions[option] = optionData;
                  }
                };
                var attrOptions = npt.getAttribute(dataAttribute), option,
                    dataoptions, optionData, p;
                if (attrOptions && attrOptions !== '') {
                  attrOptions = attrOptions.replace(/'/g, '"');
                  dataoptions = JSON.parse('{' + attrOptions + '}');
                }
                if (dataoptions) {
                  optionData = undefined;
                  for (p in dataoptions) {
                    if (p.toLowerCase() === 'alias') {
                      optionData = dataoptions[p];
                      break;
                    }
                  }
                }
                importOption('alias', optionData);
                if (userOptions.alias) {
                  resolveAlias(userOptions.alias, userOptions, opts);
                }
                for (option in opts) {
                  if (dataoptions) {
                    optionData = undefined;
                    for (p in dataoptions) {
                      if (p.toLowerCase() === option.toLowerCase()) {
                        optionData = dataoptions[p];
                        break;
                      }
                    }
                  }
                  importOption(option, optionData);
                }
              }
              $.extend(true, opts, userOptions);
              if (npt.dir === 'rtl' || opts.rightAlign) {
                npt.style.textAlign = 'right';
              }
              if (npt.dir === 'rtl' || opts.numericInput) {
                npt.dir = 'ltr';
                npt.removeAttribute('dir');
                opts.isRTL = true;
              }
              return Object.keys(userOptions).length;
            }

            if (typeof elems === 'string') {
              elems = document.getElementById(elems) ||
                  document.querySelectorAll(elems);
            }
            elems = elems.nodeName ? [elems] : elems;
            $.each(elems, function(ndx, el) {
              var scopedOpts = $.extend(true, {}, that.opts);
              if (importAttributeOptions(el, scopedOpts,
                  $.extend(true, {}, that.userOptions), that.dataAttribute)) {
                var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
                if (maskset !== undefined) {
                  if (el.inputmask !== undefined) {
                    el.inputmask.opts.autoUnmask = true;
                    el.inputmask.remove();
                  }
                  el.inputmask = new Inputmask(undefined, undefined, true);
                  el.inputmask.opts = scopedOpts;
                  el.inputmask.noMasksCache = that.noMasksCache;
                  el.inputmask.userOptions = $.extend(true, {},
                      that.userOptions);
                  el.inputmask.isRTL = scopedOpts.isRTL ||
                      scopedOpts.numericInput;
                  el.inputmask.el = el;
                  el.inputmask.maskset = maskset;
                  $.data(el, '_inputmask_opts', scopedOpts);
                  maskScope.call(el.inputmask, {
                    action: 'mask',
                  });
                }
              }
            });
            return elems && elems[0] ? elems[0].inputmask || this : this;
          },
          option: function option(options, noremask) {
            if (typeof options === 'string') {
              return this.opts[options];
            } else if ((typeof options === 'undefined' ?
                'undefined' :
                _typeof(options)) === 'object') {
              $.extend(this.userOptions, options);
              if (this.el && noremask !== true) {
                this.mask(this.el);
              }
              return this;
            }
          },
          unmaskedvalue: function unmaskedvalue(value) {
            this.maskset = this.maskset ||
                generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
              action: 'unmaskedvalue',
              value: value,
            });
          },
          remove: function remove() {
            return maskScope.call(this, {
              action: 'remove',
            });
          },
          getemptymask: function getemptymask() {
            this.maskset = this.maskset ||
                generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
              action: 'getemptymask',
            });
          },
          hasMaskedValue: function hasMaskedValue() {
            return !this.opts.autoUnmask;
          },
          isComplete: function isComplete() {
            this.maskset = this.maskset ||
                generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
              action: 'isComplete',
            });
          },
          getmetadata: function getmetadata() {
            this.maskset = this.maskset ||
                generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
              action: 'getmetadata',
            });
          },
          isValid: function isValid(value) {
            this.maskset = this.maskset ||
                generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
              action: 'isValid',
              value: value,
            });
          },
          format: function format(value, metadata) {
            this.maskset = this.maskset ||
                generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
              action: 'format',
              value: value,
              metadata: metadata,
            });
          },
          setValue: function setValue(value) {
            if (this.el) {
              $(this.el).trigger('setvalue', [value]);
            }
          },
          analyseMask: function analyseMask(mask, regexMask, opts) {
            var tokenizer = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?(?:\|[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g,
                regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
                escaped = false, currentToken = new MaskToken(), match, m,
                openenings = [], maskTokens = [], openingToken,
                currentOpeningToken, alternator, lastMatch, groupToken;

            function MaskToken(
                isGroup, isOptional, isQuantifier, isAlternator) {
              this.matches = [];
              this.openGroup = isGroup || false;
              this.alternatorGroup = false;
              this.isGroup = isGroup || false;
              this.isOptional = isOptional || false;
              this.isQuantifier = isQuantifier || false;
              this.isAlternator = isAlternator || false;
              this.quantifier = {
                min: 1,
                max: 1,
              };
            }

            function insertTestDefinition(mtoken, element, position) {
              position = position !== undefined ?
                  position :
                  mtoken.matches.length;
              var prevMatch = mtoken.matches[position - 1];
              if (regexMask) {
                if (element.indexOf('[') === 0 || escaped &&
                    /\\d|\\s|\\w]/i.test(element) || element === '.') {
                  mtoken.matches.splice(position++, 0, {
                    fn: new RegExp(element, opts.casing ? 'i' : ''),
                    optionality: false,
                    newBlockMarker: prevMatch === undefined ?
                        'master' :
                        prevMatch.def !== element,
                    casing: null,
                    def: element,
                    placeholder: undefined,
                    nativeDef: element,
                  });
                } else {
                  if (escaped) element = element[element.length - 1];
                  $.each(element.split(''), function(ndx, lmnt) {
                    prevMatch = mtoken.matches[position - 1];
                    mtoken.matches.splice(position++, 0, {
                      fn: null,
                      optionality: false,
                      newBlockMarker: prevMatch === undefined ?
                          'master' :
                          prevMatch.def !== lmnt && prevMatch.fn !== null,
                      casing: null,
                      def: opts.staticDefinitionSymbol || lmnt,
                      placeholder: opts.staticDefinitionSymbol !== undefined ?
                          lmnt :
                          undefined,
                      nativeDef: (escaped ? '\'' : '') + lmnt,
                    });
                  });
                }
                escaped = false;
              } else {
                var maskdef = (opts.definitions ?
                    opts.definitions[element] :
                    undefined) || Inputmask.prototype.definitions[element];
                if (maskdef && !escaped) {
                  mtoken.matches.splice(position++, 0, {
                    fn: maskdef.validator ?
                        typeof maskdef.validator == 'string' ?
                            new RegExp(maskdef.validator,
                                opts.casing ? 'i' : '') :
                            new function() {
                              this.test = maskdef.validator;
                            }() :
                        new RegExp('.'),
                    optionality: false,
                    newBlockMarker: prevMatch === undefined ?
                        'master' :
                        prevMatch.def !== (maskdef.definitionSymbol || element),
                    casing: maskdef.casing,
                    def: maskdef.definitionSymbol || element,
                    placeholder: maskdef.placeholder,
                    nativeDef: element,
                  });
                } else {
                  mtoken.matches.splice(position++, 0, {
                    fn: null,
                    optionality: false,
                    newBlockMarker: prevMatch === undefined ?
                        'master' :
                        prevMatch.def !== element && prevMatch.fn !== null,
                    casing: null,
                    def: opts.staticDefinitionSymbol || element,
                    placeholder: opts.staticDefinitionSymbol !== undefined ?
                        element :
                        undefined,
                    nativeDef: (escaped ? '\'' : '') + element,
                  });
                  escaped = false;
                }
              }
            }

            function verifyGroupMarker(maskToken) {
              if (maskToken && maskToken.matches) {
                $.each(maskToken.matches, function(ndx, token) {
                  var nextToken = maskToken.matches[ndx + 1];
                  if ((nextToken === undefined || nextToken.matches ===
                      undefined || nextToken.isQuantifier === false) && token &&
                      token.isGroup) {
                    token.isGroup = false;
                    if (!regexMask) {
                      insertTestDefinition(token, opts.groupmarker[0], 0);
                      if (token.openGroup !== true) {
                        insertTestDefinition(token, opts.groupmarker[1]);
                      }
                    }
                  }
                  verifyGroupMarker(token);
                });
              }
            }

            function defaultCase() {
              if (openenings.length > 0) {
                currentOpeningToken = openenings[openenings.length - 1];
                insertTestDefinition(currentOpeningToken, m);
                if (currentOpeningToken.isAlternator) {
                  alternator = openenings.pop();
                  for (var mndx = 0; mndx < alternator.matches.length; mndx++) {
                    if (alternator.matches[mndx].isGroup) alternator.matches[mndx].isGroup = false;
                  }
                  if (openenings.length > 0) {
                    currentOpeningToken = openenings[openenings.length - 1];
                    currentOpeningToken.matches.push(alternator);
                  } else {
                    currentToken.matches.push(alternator);
                  }
                }
              } else {
                insertTestDefinition(currentToken, m);
              }
            }

            function reverseTokens(maskToken) {
              function reverseStatic(st) {
                if (st ===
                    opts.optionalmarker[0]) st = opts.optionalmarker[1]; else if (st ===
                    opts.optionalmarker[1]) st = opts.optionalmarker[0]; else if (st ===
                    opts.groupmarker[0]) st = opts.groupmarker[1]; else if (st ===
                    opts.groupmarker[1]) st = opts.groupmarker[0];
                return st;
              }

              maskToken.matches = maskToken.matches.reverse();
              for (var match in maskToken.matches) {
                if (maskToken.matches.hasOwnProperty(match)) {
                  var intMatch = parseInt(match);
                  if (maskToken.matches[match].isQuantifier &&
                      maskToken.matches[intMatch + 1] &&
                      maskToken.matches[intMatch + 1].isGroup) {
                    var qt = maskToken.matches[match];
                    maskToken.matches.splice(match, 1);
                    maskToken.matches.splice(intMatch + 1, 0, qt);
                  }
                  if (maskToken.matches[match].matches !== undefined) {
                    maskToken.matches[match] = reverseTokens(
                        maskToken.matches[match]);
                  } else {
                    maskToken.matches[match] = reverseStatic(
                        maskToken.matches[match]);
                  }
                }
              }
              return maskToken;
            }

            function groupify(matches) {
              var groupToken = new MaskToken(true);
              groupToken.openGroup = false;
              groupToken.matches = matches;
              return groupToken;
            }

            if (regexMask) {
              opts.optionalmarker[0] = undefined;
              opts.optionalmarker[1] = undefined;
            }
            while (match = regexMask ?
                regexTokenizer.exec(mask) :
                tokenizer.exec(mask)) {
              m = match[0];
              if (regexMask) {
                switch (m.charAt(0)) {
                  case '?':
                    m = '{0,1}';
                    break;

                  case '+':
                  case '*':
                    m = '{' + m + '}';
                    break;
                }
              }
              if (escaped) {
                defaultCase();
                continue;
              }
              switch (m.charAt(0)) {
                case '(?=':
                  break;

                case '(?!':
                  break;

                case '(?<=':
                  break;

                case '(?<!':
                  break;

                case opts.escapeChar:
                  escaped = true;
                  if (regexMask) {
                    defaultCase();
                  }
                  break;

                case opts.optionalmarker[1]:
                case opts.groupmarker[1]:
                  openingToken = openenings.pop();
                  openingToken.openGroup = false;
                  if (openingToken !== undefined) {
                    if (openenings.length > 0) {
                      currentOpeningToken = openenings[openenings.length - 1];
                      currentOpeningToken.matches.push(openingToken);
                      if (currentOpeningToken.isAlternator) {
                        alternator = openenings.pop();
                        for (var mndx = 0; mndx <
                        alternator.matches.length; mndx++) {
                          alternator.matches[mndx].isGroup = false;
                          alternator.matches[mndx].alternatorGroup = false;
                        }
                        if (openenings.length > 0) {
                          currentOpeningToken = openenings[openenings.length -
                          1];
                          currentOpeningToken.matches.push(alternator);
                        } else {
                          currentToken.matches.push(alternator);
                        }
                      }
                    } else {
                      currentToken.matches.push(openingToken);
                    }
                  } else defaultCase();
                  break;

                case opts.optionalmarker[0]:
                  openenings.push(new MaskToken(false, true));
                  break;

                case opts.groupmarker[0]:
                  openenings.push(new MaskToken(true));
                  break;

                case opts.quantifiermarker[0]:
                  var quantifier = new MaskToken(false, false, true);
                  m = m.replace(/[{}]/g, '');
                  var mqj = m.split('|'), mq = mqj[0].split(','),
                      mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                      mq1 = mq.length === 1 ?
                          mq0 :
                          isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
                  if (mq0 === '*' || mq0 === '+') {
                    mq0 = mq1 === '*' ? 0 : 1;
                  }
                  quantifier.quantifier = {
                    min: mq0,
                    max: mq1,
                    jit: mqj[1],
                  };
                  var matches = openenings.length > 0 ?
                      openenings[openenings.length - 1].matches :
                      currentToken.matches;
                  match = matches.pop();
                  if (match.isAlternator) {
                    matches.push(match);
                    matches = match.matches;
                    var groupToken = new MaskToken(true);
                    var tmpMatch = matches.pop();
                    matches.push(groupToken);
                    matches = groupToken.matches;
                    match = tmpMatch;
                  }
                  if (!match.isGroup) {
                    match = groupify([match]);
                  }
                  matches.push(match);
                  matches.push(quantifier);
                  break;

                case opts.alternatormarker:
                  var groupQuantifier = function groupQuantifier(matches) {
                    var lastMatch = matches.pop();
                    if (lastMatch.isQuantifier) {
                      lastMatch = groupify([matches.pop(), lastMatch]);
                    }
                    return lastMatch;
                  };
                  if (openenings.length > 0) {
                    currentOpeningToken = openenings[openenings.length - 1];
                    var subToken = currentOpeningToken.matches[currentOpeningToken.matches.length -
                    1];
                    if (currentOpeningToken.openGroup &&
                        (subToken.matches === undefined || subToken.isGroup ===
                            false && subToken.isAlternator === false)) {
                      lastMatch = openenings.pop();
                    } else {
                      lastMatch = groupQuantifier(currentOpeningToken.matches);
                    }
                  } else {
                    lastMatch = groupQuantifier(currentToken.matches);
                  }
                  if (lastMatch.isAlternator) {
                    openenings.push(lastMatch);
                  } else {
                    if (lastMatch.alternatorGroup) {
                      alternator = openenings.pop();
                      lastMatch.alternatorGroup = false;
                    } else {
                      alternator = new MaskToken(false, false, false, true);
                    }
                    alternator.matches.push(lastMatch);
                    openenings.push(alternator);
                    if (lastMatch.openGroup) {
                      lastMatch.openGroup = false;
                      var alternatorGroup = new MaskToken(true);
                      alternatorGroup.alternatorGroup = true;
                      openenings.push(alternatorGroup);
                    }
                  }
                  break;

                default:
                  defaultCase();
              }
            }
            while (openenings.length > 0) {
              openingToken = openenings.pop();
              currentToken.matches.push(openingToken);
            }
            if (currentToken.matches.length > 0) {
              verifyGroupMarker(currentToken);
              maskTokens.push(currentToken);
            }
            if (opts.numericInput || opts.isRTL) {
              reverseTokens(maskTokens[0]);
            }
            return maskTokens;
          },
        };
        Inputmask.extendDefaults = function(options) {
          $.extend(true, Inputmask.prototype.defaults, options);
        };
        Inputmask.extendDefinitions = function(definition) {
          $.extend(true, Inputmask.prototype.definitions, definition);
        };
        Inputmask.extendAliases = function(alias) {
          $.extend(true, Inputmask.prototype.aliases, alias);
        };
        Inputmask.format = function(value, options, metadata) {
          return Inputmask(options).format(value, metadata);
        };
        Inputmask.unmask = function(value, options) {
          return Inputmask(options).unmaskedvalue(value);
        };
        Inputmask.isValid = function(value, options) {
          return Inputmask(options).isValid(value);
        };
        Inputmask.remove = function(elems) {
          if (typeof elems === 'string') {
            elems = document.getElementById(elems) ||
                document.querySelectorAll(elems);
          }
          elems = elems.nodeName ? [elems] : elems;
          $.each(elems, function(ndx, el) {
            if (el.inputmask) el.inputmask.remove();
          });
        };
        Inputmask.setValue = function(elems, value) {
          if (typeof elems === 'string') {
            elems = document.getElementById(elems) ||
                document.querySelectorAll(elems);
          }
          elems = elems.nodeName ? [elems] : elems;
          $.each(elems, function(ndx, el) {
            if (el.inputmask) el.inputmask.setValue(value); else $(el).
                trigger('setvalue', [value]);
          });
        };
        Inputmask.escapeRegex = function(str) {
          var specials = [
            '/',
            '.',
            '*',
            '+',
            '?',
            '|',
            '(',
            ')',
            '[',
            ']',
            '{',
            '}',
            '\\',
            '$',
            '^'];
          return str.replace(
              new RegExp('(\\' + specials.join('|\\') + ')', 'gim'), '\\$1');
        };
        Inputmask.keyCode = {
          BACKSPACE: 8,
          BACKSPACE_SAFARI: 127,
          DELETE: 46,
          DOWN: 40,
          END: 35,
          ENTER: 13,
          ESCAPE: 27,
          HOME: 36,
          INSERT: 45,
          LEFT: 37,
          PAGE_DOWN: 34,
          PAGE_UP: 33,
          RIGHT: 39,
          SPACE: 32,
          TAB: 9,
          UP: 38,
          X: 88,
          CONTROL: 17,
        };
        Inputmask.dependencyLib = $;

        function resolveAlias(aliasStr, options, opts) {
          var aliasDefinition = Inputmask.prototype.aliases[aliasStr];
          if (aliasDefinition) {
            if (aliasDefinition.alias) resolveAlias(aliasDefinition.alias,
                undefined, opts);
            $.extend(true, opts, aliasDefinition);
            $.extend(true, opts, options);
            return true;
          } else if (opts.mask === null) {
            opts.mask = aliasStr;
          }
          return false;
        }

        function generateMaskSet(opts, nocache) {
          function generateMask(mask, metadata, opts) {
            var regexMask = false;
            if (mask === null || mask === '') {
              regexMask = opts.regex !== null;
              if (regexMask) {
                mask = opts.regex;
                mask = mask.replace(/^(\^)(.*)(\$)$/, '$2');
              } else {
                regexMask = true;
                mask = '.*';
              }
            }
            if (mask.length === 1 && opts.greedy === false && opts.repeat !==
                0) {
              opts.placeholder = '';
            }
            if (opts.repeat > 0 || opts.repeat === '*' || opts.repeat === '+') {
              var repeatStart = opts.repeat === '*' ?
                  0 :
                  opts.repeat === '+' ? 1 : opts.repeat;
              mask = opts.groupmarker[0] + mask + opts.groupmarker[1] +
                  opts.quantifiermarker[0] + repeatStart + ',' + opts.repeat +
                  opts.quantifiermarker[1];
            }
            var masksetDefinition, maskdefKey = regexMask ?
                'regex_' + opts.regex :
                opts.numericInput ? mask.split('').reverse().join('') : mask;
            if (Inputmask.prototype.masksCache[maskdefKey] === undefined ||
                nocache === true) {
              masksetDefinition = {
                mask: mask,
                maskToken: Inputmask.prototype.analyseMask(mask, regexMask,
                    opts),
                validPositions: {},
                _buffer: undefined,
                buffer: undefined,
                tests: {},
                excludes: {},
                metadata: metadata,
                maskLength: undefined,
              };
              if (nocache !== true) {
                Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition;
                masksetDefinition = $.extend(true, {},
                    Inputmask.prototype.masksCache[maskdefKey]);
              }
            } else masksetDefinition = $.extend(true, {},
                Inputmask.prototype.masksCache[maskdefKey]);
            return masksetDefinition;
          }

          var ms;
          if ($.isFunction(opts.mask)) {
            opts.mask = opts.mask(opts);
          }
          if ($.isArray(opts.mask)) {
            if (opts.mask.length > 1) {
              if (opts.keepStatic === null) {
                opts.keepStatic = 'auto';
                for (var i = 0; i < opts.mask.length; i++) {
                  if (opts.mask[i].charAt(0) !== opts.mask[0].charAt(0)) {
                    opts.keepStatic = true;
                    break;
                  }
                }
              }
              var altMask = opts.groupmarker[0];
              $.each(opts.isRTL ? opts.mask.reverse() : opts.mask,
                  function(ndx, msk) {
                    if (altMask.length > 1) {
                      altMask += opts.groupmarker[1] + opts.alternatormarker +
                          opts.groupmarker[0];
                    }
                    if (msk.mask !== undefined && !$.isFunction(msk.mask)) {
                      altMask += msk.mask;
                    } else {
                      altMask += msk;
                    }
                  });
              altMask += opts.groupmarker[1];
              return generateMask(altMask, opts.mask, opts);
            } else opts.mask = opts.mask.pop();
          }
          if (opts.mask && opts.mask.mask !== undefined &&
              !$.isFunction(opts.mask.mask)) {
            ms = generateMask(opts.mask.mask, opts.mask, opts);
          } else {
            ms = generateMask(opts.mask, opts.mask, opts);
          }
          return ms;
        }

        function isInputEventSupported(eventName) {
          var el = document.createElement('input'), evName = 'on' + eventName,
              isSupported = evName in el;
          if (!isSupported) {
            el.setAttribute(evName, 'return;');
            isSupported = typeof el[evName] === 'function';
          }
          el = null;
          return isSupported;
        }

        function maskScope(actionObj, maskset, opts) {
          maskset = maskset || this.maskset;
          opts = opts || this.opts;
          var inputmask = this, el = this.el, isRTL = this.isRTL, undoValue,
              $el, skipKeyPressEvent = false, skipInputEvent = false,
              ignorable = false, maxLength, mouseEnter = false, colorMask,
              originalPlaceholder;

          function getMaskTemplate(
              baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {
            var greedy = opts.greedy;
            if (clearOptionalTail) opts.greedy = false;
            minimalPos = minimalPos || 0;
            var maskTemplate = [], ndxIntlzr, pos = 0, test, testPos,
                lvp = getLastValidPosition();
            do {
              if (baseOnInput === true && getMaskSet().validPositions[pos]) {
                testPos = clearOptionalTail &&
                getMaskSet().validPositions[pos].match.optionality === true &&
                getMaskSet().validPositions[pos + 1] === undefined &&
                (getMaskSet().validPositions[pos].generatedInput === true ||
                    getMaskSet().validPositions[pos].input ==
                    opts.skipOptionalPartCharacter && pos > 0) ?
                    determineTestTemplate(pos,
                        getTests(pos, ndxIntlzr, pos - 1)) :
                    getMaskSet().validPositions[pos];
                test = testPos.match;
                ndxIntlzr = testPos.locator.slice();
                maskTemplate.push(includeMode === true ?
                    testPos.input :
                    includeMode === false ?
                        test.nativeDef :
                        getPlaceholder(pos, test));
              } else {
                testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                test = testPos.match;
                ndxIntlzr = testPos.locator.slice();
                var jitMasking = noJit === true ?
                    false :
                    opts.jitMasking !== false ? opts.jitMasking : test.jit;
                if (jitMasking === false || jitMasking === undefined ||
                    typeof jitMasking === 'number' && isFinite(jitMasking) &&
                    jitMasking > pos) {
                  maskTemplate.push(includeMode === false ?
                      test.nativeDef :
                      getPlaceholder(pos, test));
                }
              }
              if (opts.keepStatic === 'auto') {
                if (test.newBlockMarker && test.fn !== null) {
                  opts.keepStatic = pos - 1;
                }
              }
              pos++;
            } while ((maxLength === undefined || pos < maxLength) &&
            (test.fn !== null || test.def !== '') || minimalPos > pos);
            if (maskTemplate[maskTemplate.length - 1] === '') {
              maskTemplate.pop();
            }
            if (includeMode !== false || getMaskSet().maskLength ===
                undefined) getMaskSet().maskLength = pos - 1;
            opts.greedy = greedy;
            return maskTemplate;
          }

          function getMaskSet() {
            return maskset;
          }

          function resetMaskSet(soft) {
            var maskset = getMaskSet();
            maskset.buffer = undefined;
            if (soft !== true) {
              maskset.validPositions = {};
              maskset.p = 0;
            }
          }

          function getLastValidPosition(closestTo, strict, validPositions) {
            var before = -1, after = -1,
                valids = validPositions || getMaskSet().validPositions;
            if (closestTo === undefined) closestTo = -1;
            for (var posNdx in valids) {
              var psNdx = parseInt(posNdx);
              if (valids[psNdx] &&
                  (strict || valids[psNdx].generatedInput !== true)) {
                if (psNdx <= closestTo) before = psNdx;
                if (psNdx >= closestTo) after = psNdx;
              }
            }
            return before === -1 || before == closestTo ?
                after :
                after == -1 ?
                    before :
                    closestTo - before < after - closestTo ? before : after;
          }

          function getDecisionTaker(tst) {
            var decisionTaker = tst.locator[tst.alternation];
            if (typeof decisionTaker == 'string' && decisionTaker.length > 0) {
              decisionTaker = decisionTaker.split(',')[0];
            }
            return decisionTaker !== undefined ? decisionTaker.toString() : '';
          }

          function getLocator(tst, align) {
            var locator = (tst.alternation != undefined ?
                tst.mloc[getDecisionTaker(tst)] :
                tst.locator).join('');
            if (locator !== '') while (locator.length < align) {
              locator += '0';
            }
            return locator;
          }

          function determineTestTemplate(pos, tests) {
            pos = pos > 0 ? pos - 1 : 0;
            var altTest = getTest(pos), targetLocator = getLocator(altTest),
                tstLocator, closest, bestMatch;
            for (var ndx = 0; ndx < tests.length; ndx++) {
              var tst = tests[ndx];
              tstLocator = getLocator(tst, targetLocator.length);
              var distance = Math.abs(tstLocator - targetLocator);
              if (closest === undefined || tstLocator !== '' && distance <
                  closest || bestMatch && bestMatch.match.optionality &&
                  bestMatch.match.newBlockMarker === 'master' &&
                  (!tst.match.optionality || !tst.match.newBlockMarker) ||
                  bestMatch && bestMatch.match.optionalQuantifier &&
                  !tst.match.optionalQuantifier) {
                closest = distance;
                bestMatch = tst;
              }
            }
            return bestMatch;
          }

          function getTestTemplate(pos, ndxIntlzr, tstPs) {
            return getMaskSet().validPositions[pos] ||
                determineTestTemplate(pos,
                    getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr,
                        tstPs));
          }

          function getTest(pos, tests) {
            if (getMaskSet().validPositions[pos]) {
              return getMaskSet().validPositions[pos];
            }
            return (tests || getTests(pos))[0];
          }

          function positionCanMatchDefinition(pos, def) {
            var valid = false, tests = getTests(pos);
            for (var tndx = 0; tndx < tests.length; tndx++) {
              if (tests[tndx].match && tests[tndx].match.def === def) {
                valid = true;
                break;
              }
            }
            return valid;
          }

          function getTests(pos, ndxIntlzr, tstPs) {
            var maskTokens = getMaskSet().maskToken,
                testPos = ndxIntlzr ? tstPs : 0,
                ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],
                matches = [], insertStop = false, latestMatch,
                cacheDependency = ndxIntlzr ? ndxIntlzr.join('') : '',
                offset = 0;

            function resolveTestFromToken(
                maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
              function handleMatch(match, loopNdx, quantifierRecurse) {
                function isFirstMatch(latestMatch, tokenGroup) {
                  var firstMatch = $.inArray(latestMatch,
                      tokenGroup.matches) === 0;
                  if (!firstMatch) {
                    $.each(tokenGroup.matches, function(ndx, match) {
                      if (match.isQuantifier ===
                          true) firstMatch = isFirstMatch(latestMatch,
                          tokenGroup.matches[ndx -
                          1]); else if (match.hasOwnProperty(
                          'matches')) firstMatch = isFirstMatch(latestMatch,
                          match);
                      if (firstMatch) return false;
                    });
                  }
                  return firstMatch;
                }

                function resolveNdxInitializer(
                    pos, alternateNdx, targetAlternation) {
                  var bestMatch, indexPos;
                  if (getMaskSet().tests[pos] ||
                      getMaskSet().validPositions[pos]) {
                    $.each(getMaskSet().tests[pos] ||
                        [getMaskSet().validPositions[pos]],
                        function(ndx, lmnt) {
                          if (lmnt.mloc[alternateNdx]) {
                            bestMatch = lmnt;
                            return false;
                          }
                          var alternation = targetAlternation !== undefined ?
                              targetAlternation :
                              lmnt.alternation,
                              ndxPos = lmnt.locator[alternation] !== undefined ?
                                  lmnt.locator[alternation].toString().
                                      indexOf(alternateNdx) :
                                  -1;
                          if ((indexPos === undefined || ndxPos < indexPos) &&
                              ndxPos !== -1) {
                            bestMatch = lmnt;
                            indexPos = ndxPos;
                          }
                        });
                  }
                  if (bestMatch) {
                    var bestMatchAltIndex = bestMatch.locator[bestMatch.alternation];
                    var locator = bestMatch.mloc[alternateNdx] ||
                        bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;
                    return locator.slice((targetAlternation !== undefined ?
                        targetAlternation :
                        bestMatch.alternation) + 1);
                  } else {
                    return targetAlternation !== undefined ?
                        resolveNdxInitializer(pos, alternateNdx) :
                        undefined;
                  }
                }

                function isSubsetOf(source, target) {
                  function expand(pattern) {
                    var expanded = [], start, end;
                    for (var i = 0, l = pattern.length; i < l; i++) {
                      if (pattern.charAt(i) === '-') {
                        end = pattern.charCodeAt(i + 1);
                        while (++start < end) {
                          expanded.push(String.fromCharCode(start));
                        }
                      } else {
                        start = pattern.charCodeAt(i);
                        expanded.push(pattern.charAt(i));
                      }
                    }
                    return expanded.join('');
                  }

                  if (opts.regex && source.match.fn !== null &&
                      target.match.fn !== null) {
                    return expand(target.match.def.replace(/[\[\]]/g, '')).
                            indexOf(
                                expand(source.match.def.replace(/[\[\]]/g, ''))) !==
                        -1;
                  }
                  return source.match.def === target.match.nativeDef;
                }

                function staticCanMatchDefinition(source, target) {
                  var sloc = source.locator.slice(source.alternation).join(''),
                      tloc = target.locator.slice(target.alternation).join(''),
                      canMatch = sloc == tloc,
                      canMatch = canMatch && source.match.fn === null &&
                      target.match.fn !== null ?
                          target.match.fn.test(source.match.def, getMaskSet(),
                              pos, false, opts, false) :
                          false;
                  return canMatch;
                }

                function setMergeLocators(targetMatch, altMatch) {
                  if (altMatch === undefined || targetMatch.alternation ===
                      altMatch.alternation &&
                      targetMatch.locator[targetMatch.alternation].toString().
                          indexOf(altMatch.locator[altMatch.alternation]) ===
                      -1) {
                    targetMatch.mloc = targetMatch.mloc || {};
                    var locNdx = targetMatch.locator[targetMatch.alternation];
                    if (locNdx ===
                        undefined) targetMatch.alternation = undefined; else {
                      if (typeof locNdx === 'string') locNdx = locNdx.split(
                          ',')[0];
                      if (targetMatch.mloc[locNdx] ===
                          undefined) targetMatch.mloc[locNdx] = targetMatch.locator.slice();
                      if (altMatch !== undefined) {
                        for (var ndx in altMatch.mloc) {
                          if (typeof ndx === 'string') ndx = ndx.split(',')[0];
                          if (targetMatch.mloc[ndx] ===
                              undefined) targetMatch.mloc[ndx] = altMatch.mloc[ndx];
                        }
                        targetMatch.locator[targetMatch.alternation] = Object.keys(
                            targetMatch.mloc).join(',');
                      }
                      return true;
                    }
                  }
                  return false;
                }

                if (testPos > 500 && quantifierRecurse !== undefined) {
                  throw 'Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. ' +
                  getMaskSet().mask;
                }
                if (testPos === pos && match.matches === undefined) {
                  matches.push({
                    match: match,
                    locator: loopNdx.reverse(),
                    cd: cacheDependency,
                    mloc: {},
                  });
                  return true;
                } else if (match.matches !== undefined) {
                  if (match.isGroup && quantifierRecurse !== match) {
                    match = handleMatch(
                        maskToken.matches[$.inArray(match, maskToken.matches) +
                        1], loopNdx, quantifierRecurse);
                    if (match) return true;
                  } else if (match.isOptional) {
                    var optionalToken = match;
                    match = resolveTestFromToken(match, ndxInitializer, loopNdx,
                        quantifierRecurse);
                    if (match) {
                      $.each(matches, function(ndx, mtch) {
                        mtch.match.optionality = true;
                      });
                      latestMatch = matches[matches.length - 1].match;
                      if (quantifierRecurse === undefined &&
                          isFirstMatch(latestMatch, optionalToken)) {
                        insertStop = true;
                        testPos = pos;
                      } else return true;
                    }
                  } else if (match.isAlternator) {
                    var alternateToken = match, malternateMatches = [],
                        maltMatches, currentMatches = matches.slice(),
                        loopNdxCnt = loopNdx.length;
                    var altIndex = ndxInitializer.length > 0 ?
                        ndxInitializer.shift() :
                        -1;
                    if (altIndex === -1 || typeof altIndex === 'string') {
                      var currentPos = testPos,
                          ndxInitializerClone = ndxInitializer.slice(),
                          altIndexArr = [], amndx;
                      if (typeof altIndex == 'string') {
                        altIndexArr = altIndex.split(',');
                      } else {
                        for (amndx = 0; amndx <
                        alternateToken.matches.length; amndx++) {
                          altIndexArr.push(amndx.toString());
                        }
                      }
                      if (getMaskSet().excludes[pos]) {
                        var altIndexArrClone = altIndexArr.slice();
                        for (var i = 0, el = getMaskSet().excludes[pos].length; i <
                        el; i++) {
                          altIndexArr.splice(altIndexArr.indexOf(
                              getMaskSet().excludes[pos][i].toString()), 1);
                        }
                        if (altIndexArr.length === 0) {
                          getMaskSet().excludes[pos] = undefined;
                          altIndexArr = altIndexArrClone;
                        }
                      }
                      if (opts.keepStatic === true ||
                          isFinite(parseInt(opts.keepStatic)) && currentPos >=
                          opts.keepStatic) altIndexArr = altIndexArr.slice(0,
                          1);
                      var unMatchedAlternation = false;
                      for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
                        amndx = parseInt(altIndexArr[ndx]);
                        matches = [];
                        ndxInitializer = typeof altIndex === 'string' ?
                            resolveNdxInitializer(testPos, amndx, loopNdxCnt) ||
                            ndxInitializerClone.slice() :
                            ndxInitializerClone.slice();
                        if (alternateToken.matches[amndx] &&
                            handleMatch(alternateToken.matches[amndx],
                                [amndx].concat(loopNdx),
                                quantifierRecurse)) match = true; else if (ndx ===
                            0) {
                          unMatchedAlternation = true;
                        }
                        maltMatches = matches.slice();
                        testPos = currentPos;
                        matches = [];
                        for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
                          var altMatch = maltMatches[ndx1], dropMatch = false;
                          altMatch.match.jit = altMatch.match.jit ||
                              unMatchedAlternation;
                          altMatch.alternation = altMatch.alternation ||
                              loopNdxCnt;
                          setMergeLocators(altMatch);
                          for (var ndx2 = 0; ndx2 <
                          malternateMatches.length; ndx2++) {
                            var altMatch2 = malternateMatches[ndx2];
                            if (typeof altIndex !== 'string' ||
                                altMatch.alternation !== undefined && $.inArray(
                                    altMatch.locator[altMatch.alternation].toString(),
                                    altIndexArr) !== -1) {
                              if (altMatch.match.nativeDef ===
                                  altMatch2.match.nativeDef) {
                                dropMatch = true;
                                setMergeLocators(altMatch2, altMatch);
                                break;
                              } else if (isSubsetOf(altMatch, altMatch2)) {
                                if (setMergeLocators(altMatch, altMatch2)) {
                                  dropMatch = true;
                                  malternateMatches.splice(
                                      malternateMatches.indexOf(altMatch2), 0,
                                      altMatch);
                                }
                                break;
                              } else if (isSubsetOf(altMatch2, altMatch)) {
                                setMergeLocators(altMatch2, altMatch);
                                break;
                              } else if (staticCanMatchDefinition(altMatch,
                                  altMatch2)) {
                                if (setMergeLocators(altMatch, altMatch2)) {
                                  dropMatch = true;
                                  malternateMatches.splice(
                                      malternateMatches.indexOf(altMatch2), 0,
                                      altMatch);
                                }
                                break;
                              }
                            }
                          }
                          if (!dropMatch) {
                            malternateMatches.push(altMatch);
                          }
                        }
                      }
                      matches = currentMatches.concat(malternateMatches);
                      testPos = pos;
                      insertStop = matches.length > 0;
                      match = malternateMatches.length > 0;
                      ndxInitializer = ndxInitializerClone.slice();
                    } else match = handleMatch(alternateToken.matches[altIndex] ||
                        maskToken.matches[altIndex], [altIndex].concat(loopNdx),
                        quantifierRecurse);
                    if (match) return true;
                  } else if (match.isQuantifier && quantifierRecurse !==
                      maskToken.matches[$.inArray(match, maskToken.matches) -
                      1]) {
                    var qt = match;
                    for (var qndx = ndxInitializer.length > 0 ?
                        ndxInitializer.shift() :
                        0; qndx < (isNaN(qt.quantifier.max) ?
                        qndx + 1 :
                        qt.quantifier.max) && testPos <= pos; qndx++) {
                      var tokenGroup = maskToken.matches[$.inArray(qt,
                          maskToken.matches) - 1];
                      match = handleMatch(tokenGroup, [qndx].concat(loopNdx),
                          tokenGroup);
                      if (match) {
                        latestMatch = matches[matches.length - 1].match;
                        latestMatch.optionalQuantifier = qndx >
                            qt.quantifier.min - 1;
                        latestMatch.jit = (qndx || 1) *
                            tokenGroup.matches.indexOf(latestMatch) >=
                            qt.quantifier.jit;
                        if (latestMatch.optionalQuantifier &&
                            isFirstMatch(latestMatch, tokenGroup)) {
                          insertStop = true;
                          testPos = pos;
                          break;
                        }
                        if (latestMatch.jit &&
                            !latestMatch.optionalQuantifier) {
                          offset = tokenGroup.matches.indexOf(latestMatch);
                          testPos = pos;
                          insertStop = true;
                          break;
                        }
                        return true;
                      }
                    }
                  } else {
                    match = resolveTestFromToken(match, ndxInitializer, loopNdx,
                        quantifierRecurse);
                    if (match) return true;
                  }
                } else {
                  testPos++;
                }
              }

              for (var tndx = ndxInitializer.length > 0 ?
                  ndxInitializer.shift() :
                  0; tndx < maskToken.matches.length; tndx = tndx + 1 +
                  offset) {
                offset = 0;
                if (maskToken.matches[tndx].isQuantifier !== true) {
                  var match = handleMatch(maskToken.matches[tndx],
                      [tndx].concat(loopNdx), quantifierRecurse);
                  if (match && testPos === pos) {
                    return match;
                  } else if (testPos > pos) {
                    break;
                  }
                }
              }
            }

            function mergeLocators(pos, tests) {
              var locator = [];
              if (!$.isArray(tests)) tests = [tests];
              if (tests.length > 0) {
                if (tests[0].alternation === undefined) {
                  locator = determineTestTemplate(pos, tests.slice()).
                      locator.
                      slice();
                  if (locator.length === 0) locator = tests[0].locator.slice();
                } else {
                  $.each(tests, function(ndx, tst) {
                    if (tst.def !== '') {
                      if (locator.length ===
                          0) locator = tst.locator.slice(); else {
                        for (var i = 0; i < locator.length; i++) {
                          if (tst.locator[i] &&
                              locator[i].toString().indexOf(tst.locator[i]) ===
                              -1) {
                            locator[i] += ',' + tst.locator[i];
                          }
                        }
                      }
                    }
                  });
                }
              }
              return locator;
            }

            if (pos > -1) {
              if (ndxIntlzr === undefined) {
                var previousPos = pos - 1, test;
                while ((test = getMaskSet().validPositions[previousPos] ||
                    getMaskSet().tests[previousPos]) === undefined &&
                previousPos > -1) {
                  previousPos--;
                }
                if (test !== undefined && previousPos > -1) {
                  ndxInitializer = mergeLocators(previousPos, test);
                  cacheDependency = ndxInitializer.join('');
                  testPos = previousPos;
                }
              }
              if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd ===
                  cacheDependency) {
                return getMaskSet().tests[pos];
              }
              for (var mtndx = ndxInitializer.shift(); mtndx <
              maskTokens.length; mtndx++) {
                var match = resolveTestFromToken(maskTokens[mtndx],
                    ndxInitializer, [mtndx]);
                if (match && testPos === pos || testPos > pos) {
                  break;
                }
              }
            }
            if (matches.length === 0 || insertStop) {
              matches.push({
                match: {
                  fn: null,
                  optionality: false,
                  casing: null,
                  def: '',
                  placeholder: '',
                },
                locator: [],
                mloc: {},
                cd: cacheDependency,
              });
            }
            if (ndxIntlzr !== undefined && getMaskSet().tests[pos]) {
              return $.extend(true, [], matches);
            }
            getMaskSet().tests[pos] = $.extend(true, [], matches);
            return getMaskSet().tests[pos];
          }

          function getBufferTemplate() {
            if (getMaskSet()._buffer === undefined) {
              getMaskSet()._buffer = getMaskTemplate(false, 1);
              if (getMaskSet().buffer ===
                  undefined) getMaskSet().buffer = getMaskSet()._buffer.slice();
            }
            return getMaskSet()._buffer;
          }

          function getBuffer(noCache) {
            if (getMaskSet().buffer === undefined || noCache === true) {
              getMaskSet().buffer = getMaskTemplate(true,
                  getLastValidPosition(), true);
            }
            return getMaskSet().buffer;
          }

          function refreshFromBuffer(start, end, buffer) {
            var i, p;
            if (start === true) {
              resetMaskSet();
              start = 0;
              end = buffer.length;
            } else {
              for (i = start; i < end; i++) {
                delete getMaskSet().validPositions[i];
              }
            }
            p = start;
            for (i = start; i < end; i++) {
              resetMaskSet(true);
              if (buffer[i] !== opts.skipOptionalPartCharacter) {
                var valResult = isValid(p, buffer[i], true, true);
                if (valResult !== false) {
                  resetMaskSet(true);
                  p = valResult.caret !== undefined ?
                      valResult.caret :
                      valResult.pos + 1;
                }
              }
            }
          }

          function casing(elem, test, pos) {
            switch (opts.casing || test.casing) {
              case 'upper':
                elem = elem.toUpperCase();
                break;

              case 'lower':
                elem = elem.toLowerCase();
                break;

              case 'title':
                var posBefore = getMaskSet().validPositions[pos - 1];
                if (pos === 0 || posBefore && posBefore.input ===
                    String.fromCharCode(Inputmask.keyCode.SPACE)) {
                  elem = elem.toUpperCase();
                } else {
                  elem = elem.toLowerCase();
                }
                break;

              default:
                if ($.isFunction(opts.casing)) {
                  var args = Array.prototype.slice.call(arguments);
                  args.push(getMaskSet().validPositions);
                  elem = opts.casing.apply(this, args);
                }
            }
            return elem;
          }

          function checkAlternationMatch(altArr1, altArr2, na) {
            var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),
                isMatch = false, naArr = na !== undefined ? na.split(',') : [],
                naNdx;
            for (var i = 0; i < naArr.length; i++) {
              if ((naNdx = altArr1.indexOf(naArr[i])) !== -1) {
                altArr1.splice(naNdx, 1);
              }
            }
            for (var alndx = 0; alndx < altArr1.length; alndx++) {
              if ($.inArray(altArr1[alndx], altArrC) !== -1) {
                isMatch = true;
                break;
              }
            }
            return isMatch;
          }

          function alternate(pos, c, strict, fromSetValid, rAltPos) {
            var validPsClone = $.extend(true, {}, getMaskSet().validPositions),
                lastAlt, alternation, isValidRslt = false, altPos, prevAltPos,
                i, validPos, decisionPos, lAltPos = rAltPos !== undefined ?
                rAltPos :
                getLastValidPosition();
            if (lAltPos === -1 && rAltPos === undefined) {
              lastAlt = 0;
              prevAltPos = getTest(lastAlt);
              alternation = prevAltPos.alternation;
            } else {
              for (; lAltPos >= 0; lAltPos--) {
                altPos = getMaskSet().validPositions[lAltPos];
                if (altPos && altPos.alternation !== undefined) {
                  if (prevAltPos && prevAltPos.locator[altPos.alternation] !==
                      altPos.locator[altPos.alternation]) {
                    break;
                  }
                  lastAlt = lAltPos;
                  alternation = getMaskSet().validPositions[lastAlt].alternation;
                  prevAltPos = altPos;
                }
              }
            }
            if (alternation !== undefined) {
              decisionPos = parseInt(lastAlt);
              getMaskSet().excludes[decisionPos] = getMaskSet().excludes[decisionPos] ||
                  [];
              if (pos !== true) {
                getMaskSet().excludes[decisionPos].push(
                    getDecisionTaker(prevAltPos));
              }
              var validInputsClone = [], staticInputsBeforePos = 0;
              for (i = decisionPos; i <
              getLastValidPosition(undefined, true) + 1; i++) {
                validPos = getMaskSet().validPositions[i];
                if (validPos && validPos.generatedInput !== true) {
                  validInputsClone.push(validPos.input);
                } else if (i < pos) staticInputsBeforePos++;
                delete getMaskSet().validPositions[i];
              }
              while (getMaskSet().excludes[decisionPos] &&
              getMaskSet().excludes[decisionPos].length < 10) {
                var posOffset = staticInputsBeforePos * -1,
                    validInputs = validInputsClone.slice();
                getMaskSet().tests[decisionPos] = undefined;
                resetMaskSet(true);
                isValidRslt = true;
                while (validInputs.length > 0) {
                  var input = validInputs.shift();
                  if (!(isValidRslt = isValid(getLastValidPosition(undefined,
                      true) + 1, input, false, fromSetValid, true))) {
                    break;
                  }
                }
                if (isValidRslt && c !== undefined) {
                  var targetLvp = getLastValidPosition(pos) + 1;
                  for (i = decisionPos; i < getLastValidPosition() + 1; i++) {
                    validPos = getMaskSet().validPositions[i];
                    if ((validPos === undefined || validPos.match.fn == null) &&
                        i < pos + posOffset) {
                      posOffset++;
                    }
                  }
                  pos = pos + posOffset;
                  isValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c,
                      strict, fromSetValid, true);
                }
                if (!isValidRslt) {
                  resetMaskSet();
                  prevAltPos = getTest(decisionPos);
                  getMaskSet().validPositions = $.extend(true, {},
                      validPsClone);
                  if (getMaskSet().excludes[decisionPos]) {
                    var decisionTaker = getDecisionTaker(prevAltPos);
                    if (getMaskSet().excludes[decisionPos].indexOf(
                        decisionTaker) !== -1) {
                      isValidRslt = alternate(pos, c, strict,
                          fromSetValid, decisionPos - 1);
                      break;
                    }
                    getMaskSet().excludes[decisionPos].push(decisionTaker);
                    for (i = decisionPos; i <
                    getLastValidPosition(undefined, true) + 1; i++) {
                      delete getMaskSet().validPositions[i];
                    }
                  } else {
                    isValidRslt = alternate(pos, c, strict,
                        fromSetValid, decisionPos - 1);
                    break;
                  }
                } else break;
              }
            }
            getMaskSet().excludes[decisionPos] = undefined;
            return isValidRslt;
          }

          function isValid(
              pos, c, strict, fromSetValid, fromAlternate, validateOnly) {
            function isSelection(posObj) {
              return isRTL ?
                  posObj.begin - posObj.end > 1 || posObj.begin - posObj.end ===
                  1 :
                  posObj.end - posObj.begin > 1 || posObj.end - posObj.begin ===
                  1;
            }

            strict = strict === true;
            var maskPos = pos;
            if (pos.begin !== undefined) {
              maskPos = isRTL ? pos.end : pos.begin;
            }

            function _isValid(position, c, strict) {
              var rslt = false;
              $.each(getTests(position), function(ndx, tst) {
                var test = tst.match;
                getBuffer(true);
                rslt = test.fn != null ?
                    test.fn.test(c, getMaskSet(), position, strict, opts,
                        isSelection(pos)) :
                    (c === test.def || c === opts.skipOptionalPartCharacter) &&
                    test.def !== '' ? {
                      c: getPlaceholder(position, test, true) || test.def,
                      pos: position,
                    } : false;
                if (rslt !== false) {
                  var elem = rslt.c !== undefined ? rslt.c : c,
                      validatedPos = position;
                  elem = elem === opts.skipOptionalPartCharacter &&
                  test.fn === null ?
                      getPlaceholder(position, test, true) || test.def :
                      elem;
                  if (rslt.remove !== undefined) {
                    if (!$.isArray(rslt.remove)) rslt.remove = [rslt.remove];
                    $.each(rslt.remove.sort(function(a, b) {
                      return b - a;
                    }), function(ndx, lmnt) {
                      revalidateMask({
                        begin: lmnt,
                        end: lmnt + 1,
                      });
                    });
                  }
                  if (rslt.insert !== undefined) {
                    if (!$.isArray(rslt.insert)) rslt.insert = [rslt.insert];
                    $.each(rslt.insert.sort(function(a, b) {
                      return a - b;
                    }), function(ndx, lmnt) {
                      isValid(lmnt.pos, lmnt.c, true, fromSetValid);
                    });
                  }
                  if (rslt !== true && rslt.pos !== undefined && rslt.pos !==
                      position) {
                    validatedPos = rslt.pos;
                  }
                  if (rslt !== true && rslt.pos === undefined && rslt.c ===
                      undefined) {
                    return false;
                  }
                  if (!revalidateMask(pos, $.extend({}, tst, {
                    input: casing(elem, test, validatedPos),
                  }), fromSetValid, validatedPos)) {
                    rslt = false;
                  }
                  return false;
                }
              });
              return rslt;
            }

            var result = true, positionsClone = $.extend(true, {},
                getMaskSet().validPositions);
            if ($.isFunction(opts.preValidation) && !strict && fromSetValid !==
                true && validateOnly !== true) {
              result = opts.preValidation(getBuffer(), maskPos, c,
                  isSelection(pos), opts, getMaskSet());
            }
            if (result === true) {
              trackbackPositions(undefined, maskPos, true);
              if (maxLength === undefined || maskPos < maxLength) {
                result = _isValid(maskPos, c, strict);
                if ((!strict || fromSetValid === true) && result === false &&
                    validateOnly !== true) {
                  var currentPosValid = getMaskSet().validPositions[maskPos];
                  if (currentPosValid && currentPosValid.match.fn === null &&
                      (currentPosValid.match.def === c || c ===
                          opts.skipOptionalPartCharacter)) {
                    result = {
                      caret: seekNext(maskPos),
                    };
                  } else if ((opts.insertMode ||
                      getMaskSet().validPositions[seekNext(maskPos)] ===
                      undefined) && !isMask(maskPos, true)) {
                    for (var nPos = maskPos + 1, snPos = seekNext(
                        maskPos); nPos <= snPos; nPos++) {
                      result = _isValid(nPos, c, strict);
                      if (result !== false) {
                        result = trackbackPositions(maskPos,
                            result.pos !== undefined ? result.pos : nPos) ||
                            result;
                        maskPos = nPos;
                        break;
                      }
                    }
                  }
                }
              }
              if (result === false && opts.keepStatic !== false &&
                  (opts.regex == null || isComplete(getBuffer())) && !strict &&
                  fromAlternate !== true) {
                result = alternate(maskPos, c, strict, fromSetValid);
              }
              if (result === true) {
                result = {
                  pos: maskPos,
                };
              }
            }
            if ($.isFunction(opts.postValidation) && result !== false &&
                !strict && fromSetValid !== true && validateOnly !== true) {
              var postResult = opts.postValidation(getBuffer(true),
                  pos.begin !== undefined ? isRTL ? pos.end : pos.begin : pos,
                  result, opts);
              if (postResult !== undefined) {
                if (postResult.refreshFromBuffer && postResult.buffer) {
                  var refresh = postResult.refreshFromBuffer;
                  refreshFromBuffer(refresh === true ? refresh : refresh.start,
                      refresh.end, postResult.buffer);
                }
                result = postResult === true ? result : postResult;
              }
            }
            if (result && result.pos === undefined) {
              result.pos = maskPos;
            }
            if (result === false || validateOnly === true) {
              resetMaskSet(true);
              getMaskSet().validPositions = $.extend(true, {}, positionsClone);
            }
            return result;
          }

          function trackbackPositions(originalPos, newPos, fillOnly) {
            var result;
            if (originalPos === undefined) {
              for (originalPos = newPos - 1; originalPos > 0; originalPos--) {
                if (getMaskSet().validPositions[originalPos]) break;
              }
            }
            for (var ps = originalPos; ps < newPos; ps++) {
              if (getMaskSet().validPositions[ps] === undefined &&
                  !isMask(ps, true)) {
                var vp = ps == 0 ?
                    getTest(ps) :
                    getMaskSet().validPositions[ps - 1];
                if (vp) {
                  var tests = getTests(ps).slice();
                  if (tests[tests.length - 1].match.def === '') tests.pop();
                  var bestMatch = determineTestTemplate(ps, tests);
                  bestMatch = $.extend({}, bestMatch, {
                    input: getPlaceholder(ps, bestMatch.match, true) ||
                    bestMatch.match.def,
                  });
                  bestMatch.generatedInput = true;
                  revalidateMask(ps, bestMatch, true);
                  if (fillOnly !== true) {
                    var cvpInput = getMaskSet().validPositions[newPos].input;
                    getMaskSet().validPositions[newPos] = undefined;
                    result = isValid(newPos, cvpInput, true, true);
                  }
                }
              }
            }
            return result;
          }

          function revalidateMask(pos, validTest, fromSetValid, validatedPos) {
            function IsEnclosedStatic(pos, valids, selection) {
              var posMatch = valids[pos];
              if (posMatch !== undefined &&
                  (posMatch.match.fn === null && posMatch.match.optionality !==
                      true || posMatch.input === opts.radixPoint)) {
                var prevMatch = selection.begin <= pos - 1 ?
                    valids[pos - 1] && valids[pos - 1].match.fn === null &&
                    valids[pos - 1] :
                    valids[pos - 1], nextMatch = selection.end > pos + 1 ?
                    valids[pos + 1] && valids[pos + 1].match.fn === null &&
                    valids[pos + 1] :
                    valids[pos + 1];
                return prevMatch && nextMatch;
              }
              return false;
            }

            var begin = pos.begin !== undefined ? pos.begin : pos,
                end = pos.end !== undefined ? pos.end : pos;
            if (pos.begin > pos.end) {
              begin = pos.end;
              end = pos.begin;
            }
            validatedPos = validatedPos !== undefined ? validatedPos : begin;
            if (begin !== end || opts.insertMode &&
                getMaskSet().validPositions[validatedPos] !== undefined &&
                fromSetValid === undefined) {
              var positionsClone = $.extend(true, {},
                  getMaskSet().validPositions),
                  lvp = getLastValidPosition(undefined, true), i;
              getMaskSet().p = begin;
              for (i = lvp; i >= begin; i--) {
                if (getMaskSet().validPositions[i] &&
                    getMaskSet().validPositions[i].match.nativeDef === '+') {
                  opts.isNegative = false;
                }
                delete getMaskSet().validPositions[i];
              }
              var valid = true, j = validatedPos,
                  vps = getMaskSet().validPositions, needsValidation = false,
                  posMatch = j, i = j;
              if (validTest) {
                getMaskSet().validPositions[validatedPos] = $.extend(true, {},
                    validTest);
                posMatch++;
                j++;
                if (begin < end) i++;
              }
              for (; i <= lvp; i++) {
                var t = positionsClone[i];
                if (t !== undefined &&
                    (i >= end || i >= begin && t.generatedInput !== true &&
                        IsEnclosedStatic(i, positionsClone, {
                          begin: begin,
                          end: end,
                        }))) {
                  while (getTest(posMatch).match.def !== '') {
                    if (needsValidation === false && positionsClone[posMatch] &&
                        positionsClone[posMatch].match.nativeDef ===
                        t.match.nativeDef) {
                      getMaskSet().validPositions[posMatch] = $.extend(true, {},
                          positionsClone[posMatch]);
                      getMaskSet().validPositions[posMatch].input = t.input;
                      trackbackPositions(undefined, posMatch, true);
                      j = posMatch + 1;
                      valid = true;
                    } else if (positionCanMatchDefinition(posMatch,
                        t.match.def)) {
                      var result = isValid(posMatch, t.input, true, true);
                      valid = result !== false;
                      j = result.caret || result.insert ?
                          getLastValidPosition() :
                          posMatch + 1;
                      needsValidation = true;
                    } else {
                      valid = t.generatedInput === true || t.input ===
                          opts.radixPoint && opts.numericInput === true;
                    }
                    if (valid) break;
                    if (!valid && posMatch > end && isMask(posMatch, true) &&
                        (t.match.fn !== null || posMatch >
                            getMaskSet().maskLength)) {
                      break;
                    }
                    posMatch++;
                  }
                  if (getTest(posMatch).match.def == '') valid = false;
                  posMatch = j;
                }
                if (!valid) break;
              }
              if (!valid) {
                getMaskSet().validPositions = $.extend(true, {},
                    positionsClone);
                resetMaskSet(true);
                return false;
              }
            } else if (validTest) {
              getMaskSet().validPositions[validatedPos] = $.extend(true, {},
                  validTest);
            }
            resetMaskSet(true);
            return true;
          }

          function isMask(pos, strict) {
            var test = getTestTemplate(pos).match;
            if (test.def === '') test = getTest(pos).match;
            if (test.fn != null) {
              return test.fn;
            }
            if (strict !== true && pos > -1) {
              var tests = getTests(pos);
              return tests.length > 1 +
                  (tests[tests.length - 1].match.def === '' ? 1 : 0);
            }
            return false;
          }

          function seekNext(pos, newBlock) {
            var position = pos + 1;
            while (getTest(position).match.def !== '' && (newBlock === true &&
                (getTest(position).match.newBlockMarker !== true ||
                    !isMask(position)) || newBlock !== true &&
                !isMask(position))) {
              position++;
            }
            return position;
          }

          function seekPrevious(pos, newBlock) {
            var position = pos, tests;
            if (position <= 0) return 0;
            while (--position > 0 &&
            (newBlock === true && getTest(position).match.newBlockMarker !==
                true || newBlock !== true && !isMask(position) &&
                (tests = getTests(position),
                tests.length < 2 ||
                tests.length === 2 && tests[1].match.def === ''))) {
            }
            return position;
          }

          function getBufferElement(position) {
            return getMaskSet().validPositions[position] === undefined ?
                getPlaceholder(position) :
                getMaskSet().validPositions[position].input;
          }

          function writeBuffer(input, buffer, caretPos, event, triggerEvents) {
            if (event && $.isFunction(opts.onBeforeWrite)) {
              var result = opts.onBeforeWrite.call(inputmask, event, buffer,
                  caretPos, opts);
              if (result) {
                if (result.refreshFromBuffer) {
                  var refresh = result.refreshFromBuffer;
                  refreshFromBuffer(refresh === true ? refresh : refresh.start,
                      refresh.end, result.buffer || buffer);
                  buffer = getBuffer(true);
                }
                if (caretPos !== undefined) caretPos = result.caret !==
                undefined ? result.caret : caretPos;
              }
            }
            if (input !== undefined) {
              input.inputmask._valueSet(buffer.join(''));
              if (caretPos !== undefined &&
                  (event === undefined || event.type !== 'blur')) {
                caret(input, caretPos);
              } else renderColorMask(input, caretPos, buffer.length === 0);
              if (triggerEvents === true) {
                var $input = $(input), nptVal = input.inputmask._valueGet();
                skipInputEvent = true;
                $input.trigger('input');
                setTimeout(function() {
                  if (nptVal === getBufferTemplate().join('')) {
                    $input.trigger('cleared');
                  } else if (isComplete(buffer) === true) {
                    $input.trigger('complete');
                  }
                }, 0);
              }
            }
          }

          function getPlaceholder(pos, test, returnPL) {
            test = test || getTest(pos).match;
            if (test.placeholder !== undefined || returnPL === true) {
              return $.isFunction(test.placeholder) ?
                  test.placeholder(opts) :
                  test.placeholder;
            } else if (test.fn === null) {
              if (pos > -1 && getMaskSet().validPositions[pos] === undefined) {
                var tests = getTests(pos), staticAlternations = [], prevTest;
                if (tests.length > 1 +
                    (tests[tests.length - 1].match.def === '' ? 1 : 0)) {
                  for (var i = 0; i < tests.length; i++) {
                    if (tests[i].match.optionality !== true &&
                        tests[i].match.optionalQuantifier !== true &&
                        (tests[i].match.fn === null || prevTest === undefined ||
                            tests[i].match.fn.test(prevTest.match.def,
                                getMaskSet(), pos, true, opts) !== false)) {
                      staticAlternations.push(tests[i]);
                      if (tests[i].match.fn === null) prevTest = tests[i];
                      if (staticAlternations.length > 1) {
                        if (/[0-9a-bA-Z]/.test(
                            staticAlternations[0].match.def)) {
                          return opts.placeholder.charAt(pos %
                              opts.placeholder.length);
                        }
                      }
                    }
                  }
                }
              }
              return test.def;
            }
            return opts.placeholder.charAt(pos % opts.placeholder.length);
          }

          var EventRuler = {
            on: function on(input, eventName, eventHandler) {
              var ev = function ev(e) {
                var that = this;
                if (that.inputmask === undefined && this.nodeName !== 'FORM') {
                  var imOpts = $.data(that, '_inputmask_opts');
                  if (imOpts) new Inputmask(imOpts).mask(
                      that); else EventRuler.off(that);
                } else if (e.type !== 'setvalue' && this.nodeName !== 'FORM' &&
                    (that.disabled || that.readOnly &&
                        !(e.type === 'keydown' && e.ctrlKey && e.keyCode ===
                            67 || opts.tabThrough === false && e.keyCode ===
                            Inputmask.keyCode.TAB))) {
                  e.preventDefault();
                } else {
                  switch (e.type) {
                    case 'input':
                      if (skipInputEvent === true) {
                        skipInputEvent = false;
                        return e.preventDefault();
                      }
                      if (mobile) {
                        var args = arguments;
                        setTimeout(function() {
                          eventHandler.apply(that, args);
                          caret(that, that.inputmask.caretPos, undefined, true);
                        }, 0);
                        return false;
                      }
                      break;

                    case 'keydown':
                      skipKeyPressEvent = false;
                      skipInputEvent = false;
                      break;

                    case 'keypress':
                      if (skipKeyPressEvent === true) {
                        return e.preventDefault();
                      }
                      skipKeyPressEvent = true;
                      break;

                    case 'click':
                      if (iemobile || iphone) {
                        var args = arguments;
                        setTimeout(function() {
                          eventHandler.apply(that, args);
                        }, 0);
                        return false;
                      }
                      break;
                  }
                  var returnVal = eventHandler.apply(that, arguments);
                  if (returnVal === false) {
                    e.preventDefault();
                    e.stopPropagation();
                  }
                  return returnVal;
                }
              };
              input.inputmask.events[eventName] = input.inputmask.events[eventName] ||
                  [];
              input.inputmask.events[eventName].push(ev);
              if ($.inArray(eventName, ['submit', 'reset']) !== -1) {
                if (input.form !== null) $(input.form).on(eventName, ev);
              } else {
                $(input).on(eventName, ev);
              }
            },
            off: function off(input, event) {
              if (input.inputmask && input.inputmask.events) {
                var events;
                if (event) {
                  events = [];
                  events[event] = input.inputmask.events[event];
                } else {
                  events = input.inputmask.events;
                }
                $.each(events, function(eventName, evArr) {
                  while (evArr.length > 0) {
                    var ev = evArr.pop();
                    if ($.inArray(eventName, ['submit', 'reset']) !== -1) {
                      if (input.form !== null) $(input.form).off(eventName, ev);
                    } else {
                      $(input).off(eventName, ev);
                    }
                  }
                  delete input.inputmask.events[eventName];
                });
              }
            },
          };
          var EventHandlers = {
            keydownEvent: function keydownEvent(e) {
              var input = this, $input = $(input), k = e.keyCode,
                  pos = caret(input);
              if (k === Inputmask.keyCode.BACKSPACE || k ===
                  Inputmask.keyCode.DELETE || iphone && k ===
                  Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k ===
                  Inputmask.keyCode.X && !isInputEventSupported('cut')) {
                e.preventDefault();
                handleRemove(input, k, pos);
                writeBuffer(input, getBuffer(true), getMaskSet().p,
                    e, input.inputmask._valueGet() !== getBuffer().join(''));
              } else if (k === Inputmask.keyCode.END || k ===
                  Inputmask.keyCode.PAGE_DOWN) {
                e.preventDefault();
                var caretPos = seekNext(getLastValidPosition());
                caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, true);
              } else if (k === Inputmask.keyCode.HOME && !e.shiftKey || k ===
                  Inputmask.keyCode.PAGE_UP) {
                e.preventDefault();
                caret(input, 0, e.shiftKey ? pos.begin : 0, true);
              } else if ((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE ||
                  k === 90 && e.ctrlKey) && e.altKey !== true) {
                checkVal(input, true, false, undoValue.split(''));
                $input.trigger('click');
              } else if (k === Inputmask.keyCode.INSERT &&
                  !(e.shiftKey || e.ctrlKey)) {
                opts.insertMode = !opts.insertMode;
                input.setAttribute('im-insert', opts.insertMode);
              } else if (opts.tabThrough === true && k ===
                  Inputmask.keyCode.TAB) {
                if (e.shiftKey === true) {
                  if (getTest(pos.begin).match.fn === null) {
                    pos.begin = seekNext(pos.begin);
                  }
                  pos.end = seekPrevious(pos.begin, true);
                  pos.begin = seekPrevious(pos.end, true);
                } else {
                  pos.begin = seekNext(pos.begin, true);
                  pos.end = seekNext(pos.begin, true);
                  if (pos.end < getMaskSet().maskLength) pos.end--;
                }
                if (pos.begin < getMaskSet().maskLength) {
                  e.preventDefault();
                  caret(input, pos.begin, pos.end);
                }
              }
              opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin,
                  opts);
              ignorable = $.inArray(k, opts.ignorables) !== -1;
            },
            keypressEvent: function keypressEvent(
                e, checkval, writeOut, strict, ndx) {
              var input = this, $input = $(input),
                  k = e.which || e.charCode || e.keyCode;
              if (checkval !== true && !(e.ctrlKey && e.altKey) &&
                  (e.ctrlKey || e.metaKey || ignorable)) {
                if (k === Inputmask.keyCode.ENTER && undoValue !==
                    getBuffer().join('')) {
                  undoValue = getBuffer().join('');
                  setTimeout(function() {
                    $input.trigger('change');
                  }, 0);
                }
                return true;
              } else {
                if (k) {
                  if (k === 46 && e.shiftKey === false && opts.radixPoint !==
                      '') k = opts.radixPoint.charCodeAt(0);
                  var pos = checkval ? {
                        begin: ndx,
                        end: ndx,
                      } : caret(input), forwardPosition, c = String.fromCharCode(k),
                      offset = 0;
                  if (opts._radixDance && opts.numericInput) {
                    var caretPos = getBuffer().
                        indexOf(opts.radixPoint.charAt(0)) + 1;
                    if (pos.begin <= caretPos) {
                      if (k === opts.radixPoint.charCodeAt(0)) offset = 1;
                      pos.begin -= 1;
                      pos.end -= 1;
                    }
                  }
                  getMaskSet().writeOutBuffer = true;
                  var valResult = isValid(pos, c, strict);
                  if (valResult !== false) {
                    resetMaskSet(true);
                    forwardPosition = valResult.caret !== undefined ?
                        valResult.caret :
                        seekNext(valResult.pos.begin ?
                            valResult.pos.begin :
                            valResult.pos);
                    getMaskSet().p = forwardPosition;
                  }
                  forwardPosition = (opts.numericInput &&
                  valResult.caret === undefined ?
                      seekPrevious(forwardPosition) :
                      forwardPosition) + offset;
                  if (writeOut !== false) {
                    setTimeout(function() {
                      opts.onKeyValidation.call(input, k, valResult, opts);
                    }, 0);
                    if (getMaskSet().writeOutBuffer && valResult !== false) {
                      var buffer = getBuffer();
                      writeBuffer(input, buffer, forwardPosition,
                          e, checkval !== true);
                    }
                  }
                  e.preventDefault();
                  if (checkval) {
                    if (valResult !==
                        false) valResult.forwardPosition = forwardPosition;
                    return valResult;
                  }
                }
              }
            },
            pasteEvent: function pasteEvent(e) {
              var input = this, ev = e.originalEvent || e, $input = $(input),
                  inputValue = input.inputmask._valueGet(true),
                  caretPos = caret(input), tempValue;
              if (isRTL) {
                tempValue = caretPos.end;
                caretPos.end = caretPos.begin;
                caretPos.begin = tempValue;
              }
              var valueBeforeCaret = inputValue.substr(0, caretPos.begin),
                  valueAfterCaret = inputValue.substr(caretPos.end,
                      inputValue.length);
              if (valueBeforeCaret === (isRTL ?
                  getBufferTemplate().reverse() :
                  getBufferTemplate()).slice(0, caretPos.begin).
                  join('')) valueBeforeCaret = '';
              if (valueAfterCaret === (isRTL ?
                  getBufferTemplate().reverse() :
                  getBufferTemplate()).slice(caretPos.end).
                  join('')) valueAfterCaret = '';
              if (window.clipboardData && window.clipboardData.getData) {
                inputValue = valueBeforeCaret +
                    window.clipboardData.getData('Text') + valueAfterCaret;
              } else if (ev.clipboardData && ev.clipboardData.getData) {
                inputValue = valueBeforeCaret +
                    ev.clipboardData.getData('text/plain') + valueAfterCaret;
              } else return true;
              var pasteValue = inputValue;
              if ($.isFunction(opts.onBeforePaste)) {
                pasteValue = opts.onBeforePaste.call(inputmask, inputValue,
                    opts);
                if (pasteValue === false) {
                  return e.preventDefault();
                }
                if (!pasteValue) {
                  pasteValue = inputValue;
                }
              }
              checkVal(input, false, false, pasteValue.toString().split(''));
              writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()),
                  e, undoValue !== getBuffer().join(''));
              return e.preventDefault();
            },
            inputFallBackEvent: function inputFallBackEvent(e) {
              function radixPointHandler(input, inputValue, caretPos) {
                if (inputValue.charAt(caretPos.begin - 1) === '.' &&
                    opts.radixPoint !== '') {
                  inputValue = inputValue.split('');
                  inputValue[caretPos.begin - 1] = opts.radixPoint.charAt(0);
                  inputValue = inputValue.join('');
                }
                return inputValue;
              }

              function ieMobileHandler(input, inputValue, caretPos) {
                if (iemobile) {
                  var inputChar = inputValue.replace(getBuffer().join(''), '');
                  if (inputChar.length === 1) {
                    var iv = inputValue.split('');
                    iv.splice(caretPos.begin, 0, inputChar);
                    inputValue = iv.join('');
                  }
                }
                return inputValue;
              }

              var input = this, inputValue = input.inputmask._valueGet();
              if (getBuffer().join('') !== inputValue) {
                var caretPos = caret(input);
                inputValue = radixPointHandler(input, inputValue, caretPos);
                inputValue = ieMobileHandler(input, inputValue, caretPos);
                if (getBuffer().join('') !== inputValue) {
                  var buffer = getBuffer().join(''),
                      offset = !opts.numericInput &&
                      inputValue.length > buffer.length ? -1 : 0,
                      frontPart = inputValue.substr(0, caretPos.begin),
                      backPart = inputValue.substr(caretPos.begin),
                      frontBufferPart = buffer.substr(0, caretPos.begin +
                          offset),
                      backBufferPart = buffer.substr(caretPos.begin + offset);
                  var selection = caretPos, entries = '', isEntry = false;
                  if (frontPart !== frontBufferPart) {
                    var fpl = (isEntry = frontPart.length >=
                        frontBufferPart.length) ?
                        frontPart.length :
                        frontBufferPart.length, i;
                    for (i = 0; frontPart.charAt(i) ===
                    frontBufferPart.charAt(i) && i < fpl; i++) {
                    }
                    if (isEntry) {
                      selection.begin = i - offset;
                      entries += frontPart.slice(i, selection.end);
                    }
                  }
                  if (backPart !== backBufferPart) {
                    if (backPart.length > backBufferPart.length) {
                      entries += backPart.slice(0, 1);
                    } else {
                      if (backPart.length < backBufferPart.length) {
                        selection.end += backBufferPart.length -
                            backPart.length;
                        if (!isEntry && opts.radixPoint !== '' && backPart ===
                            '' &&
                            frontPart.charAt(selection.begin + offset - 1) ===
                            opts.radixPoint) {
                          selection.begin--;
                          entries = opts.radixPoint;
                        }
                      }
                    }
                  }
                  writeBuffer(input, getBuffer(), {
                    begin: selection.begin + offset,
                    end: selection.end + offset,
                  });
                  if (entries.length > 0) {
                    $.each(entries.split(''), function(ndx, entry) {
                      var keypress = new $.Event('keypress');
                      keypress.which = entry.charCodeAt(0);
                      ignorable = false;
                      EventHandlers.keypressEvent.call(input, keypress);
                    });
                  } else {
                    if (selection.begin === selection.end - 1) {
                      selection.begin = seekPrevious(selection.begin + 1);
                      if (selection.begin === selection.end - 1) {
                        caret(input, selection.begin);
                      } else {
                        caret(input, selection.begin, selection.end);
                      }
                    }
                    var keydown = new $.Event('keydown');
                    keydown.keyCode = opts.numericInput ?
                        Inputmask.keyCode.BACKSPACE :
                        Inputmask.keyCode.DELETE;
                    EventHandlers.keydownEvent.call(input, keydown);
                  }
                  e.preventDefault();
                }
              }
            },
            beforeInputEvent: function beforeInputEvent(e) {
              if (e.cancelable) {
                var input = this;
                switch (e.inputType) {
                  case 'insertText':
                    $.each(e.data.split(''), function(ndx, entry) {
                      var keypress = new $.Event('keypress');
                      keypress.which = entry.charCodeAt(0);
                      ignorable = false;
                      EventHandlers.keypressEvent.call(input, keypress);
                    });
                    return e.preventDefault();

                  case 'deleteContentBackward':
                    var keydown = new $.Event('keydown');
                    keydown.keyCode = Inputmask.keyCode.BACKSPACE;
                    EventHandlers.keydownEvent.call(input, keydown);
                    return e.preventDefault();

                  case 'deleteContentForward':
                    var keydown = new $.Event('keydown');
                    keydown.keyCode = Inputmask.keyCode.DELETE;
                    EventHandlers.keydownEvent.call(input, keydown);
                    return e.preventDefault();
                }
              }
            },
            setValueEvent: function setValueEvent(e) {
              this.inputmask.refreshValue = false;
              var input = this,
                  value = e && e.detail ? e.detail[0] : arguments[1],
                  value = value || input.inputmask._valueGet(true);
              if ($.isFunction(
                  opts.onBeforeMask)) value = opts.onBeforeMask.call(inputmask,
                  value, opts) || value;
              value = value.split('');
              checkVal(input, true, false, value);
              undoValue = getBuffer().join('');
              if ((opts.clearMaskOnLostFocus || opts.clearIncomplete) &&
                  input.inputmask._valueGet() ===
                  getBufferTemplate().join('')) {
                input.inputmask._valueSet('');
              }
            },
            focusEvent: function focusEvent(e) {
              var input = this, nptValue = input.inputmask._valueGet();
              if (opts.showMaskOnFocus &&
                  (!opts.showMaskOnHover || opts.showMaskOnHover && nptValue ===
                      '')) {
                if (input.inputmask._valueGet() !== getBuffer().join('')) {
                  writeBuffer(input, getBuffer(),
                      seekNext(getLastValidPosition()));
                } else if (mouseEnter === false) {
                  caret(input, seekNext(getLastValidPosition()));
                }
              }
              if (opts.positionCaretOnTab === true && mouseEnter === false) {
                EventHandlers.clickEvent.apply(input, [e, true]);
              }
              undoValue = getBuffer().join('');
            },
            mouseleaveEvent: function mouseleaveEvent(e) {
              var input = this;
              mouseEnter = false;
              if (opts.clearMaskOnLostFocus && document.activeElement !==
                  input) {
                input.placeholder = originalPlaceholder;
                if (input.placeholder === '') input.removeAttribute(
                    'placeholder');
              }
            },
            clickEvent: function clickEvent(e, tabbed) {
              function doRadixFocus(clickPos) {
                if (opts.radixPoint !== '') {
                  var vps = getMaskSet().validPositions;
                  if (vps[clickPos] === undefined || vps[clickPos].input ===
                      getPlaceholder(clickPos)) {
                    if (clickPos < seekNext(-1)) return true;
                    var radixPos = $.inArray(opts.radixPoint, getBuffer());
                    if (radixPos !== -1) {
                      for (var vp in vps) {
                        if (radixPos < vp && vps[vp].input !==
                            getPlaceholder(vp)) {
                          return false;
                        }
                      }
                      return true;
                    }
                  }
                }
                return false;
              }

              var input = this;
              setTimeout(function() {
                if (document.activeElement === input) {
                  var selectedCaret = caret(input);
                  if (tabbed) {
                    if (isRTL) {
                      selectedCaret.end = selectedCaret.begin;
                    } else {
                      selectedCaret.begin = selectedCaret.end;
                    }
                  }
                  if (selectedCaret.begin === selectedCaret.end) {
                    switch (opts.positionCaretOnClick) {
                      case 'none':
                        break;

                      case 'select':
                        caret(input, 0, getBuffer().length);
                        break;

                      case 'ignore':
                        caret(input, seekNext(getLastValidPosition()));
                        break;

                      case 'radixFocus':
                        if (doRadixFocus(selectedCaret.begin)) {
                          var radixPos = getBuffer().
                              join('').
                              indexOf(opts.radixPoint);
                          caret(input, opts.numericInput ?
                              seekNext(radixPos) :
                              radixPos);
                          break;
                        }

                      default:
                        var clickPosition = selectedCaret.begin,
                            lvclickPosition = getLastValidPosition(
                                clickPosition, true),
                            lastPosition = seekNext(lvclickPosition);
                        if (clickPosition < lastPosition) {
                          caret(input, !isMask(clickPosition, true) &&
                          !isMask(clickPosition - 1, true) ?
                              seekNext(clickPosition) :
                              clickPosition);
                        } else {
                          var lvp = getMaskSet().validPositions[lvclickPosition],
                              tt = getTestTemplate(lastPosition,
                                  lvp ? lvp.match.locator : undefined, lvp),
                              placeholder = getPlaceholder(lastPosition,
                                  tt.match);
                          if (placeholder !== '' &&
                              getBuffer()[lastPosition] !== placeholder &&
                              tt.match.optionalQuantifier !== true &&
                              tt.match.newBlockMarker !== true ||
                              !isMask(lastPosition, opts.keepStatic) &&
                              tt.match.def === placeholder) {
                            var newPos = seekNext(lastPosition);
                            if (clickPosition >= newPos || clickPosition ===
                                lastPosition) {
                              lastPosition = newPos;
                            }
                          }
                          caret(input, lastPosition);
                        }
                        break;
                    }
                  }
                }
              }, 0);
            },
            cutEvent: function cutEvent(e) {
              var input = this, $input = $(input), pos = caret(input),
                  ev = e.originalEvent || e;
              var clipboardData = window.clipboardData || ev.clipboardData,
                  clipData = isRTL ?
                      getBuffer().slice(pos.end, pos.begin) :
                      getBuffer().slice(pos.begin, pos.end);
              clipboardData.setData('text',
                  isRTL ? clipData.reverse().join('') : clipData.join(''));
              if (document.execCommand) document.execCommand('copy');
              handleRemove(input, Inputmask.keyCode.DELETE, pos);
              writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !==
                  getBuffer().join(''));
            },
            blurEvent: function blurEvent(e) {
              var $input = $(this), input = this;
              if (input.inputmask) {
                input.placeholder = originalPlaceholder;
                if (input.placeholder === '') input.removeAttribute(
                    'placeholder');
                var nptValue = input.inputmask._valueGet(),
                    buffer = getBuffer().slice();
                if (nptValue !== '' || colorMask !== undefined) {
                  if (opts.clearMaskOnLostFocus) {
                    if (getLastValidPosition() === -1 && nptValue ===
                        getBufferTemplate().join('')) {
                      buffer = [];
                    } else {
                      clearOptionalTail(buffer);
                    }
                  }
                  if (isComplete(buffer) === false) {
                    setTimeout(function() {
                      $input.trigger('incomplete');
                    }, 0);
                    if (opts.clearIncomplete) {
                      resetMaskSet();
                      if (opts.clearMaskOnLostFocus) {
                        buffer = [];
                      } else {
                        buffer = getBufferTemplate().slice();
                      }
                    }
                  }
                  writeBuffer(input, buffer, undefined, e);
                }
                if (undoValue !== getBuffer().join('')) {
                  undoValue = buffer.join('');
                  $input.trigger('change');
                }
              }
            },
            mouseenterEvent: function mouseenterEvent(e) {
              var input = this;
              mouseEnter = true;
              if (document.activeElement !== input && opts.showMaskOnHover) {
                input.placeholder = (isRTL ?
                    getBuffer().slice().reverse() :
                    getBuffer()).join('');
              }
            },
            submitEvent: function submitEvent(e) {
              if (undoValue !== getBuffer().join('')) {
                $el.trigger('change');
              }
              if (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 &&
                  el.inputmask._valueGet && el.inputmask._valueGet() ===
                  getBufferTemplate().join('')) {
                el.inputmask._valueSet('');
              }
              if (opts.clearIncomplete && isComplete(getBuffer()) === false) {
                el.inputmask._valueSet('');
              }
              if (opts.removeMaskOnSubmit) {
                el.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);
                setTimeout(function() {
                  writeBuffer(el, getBuffer());
                }, 0);
              }
            },
            resetEvent: function resetEvent(e) {
              el.inputmask.refreshValue = true;
              setTimeout(function() {
                $el.trigger('setvalue');
              }, 0);
            },
          };

          function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {
            var inputmask = this || input.inputmask, inputValue = nptvl.slice(),
                charCodes = '', initialNdx = -1, result = undefined;

            function isTemplateMatch(ndx, charCodes) {
              var charCodeNdx = getMaskTemplate(true, 0, false).
                  slice(ndx, seekNext(ndx)).
                  join('').
                  replace(/'/g, '').
                  indexOf(charCodes);
              return charCodeNdx !== -1 && !isMask(ndx) &&
                  (getTest(ndx).match.nativeDef === charCodes.charAt(0) ||
                      getTest(ndx).match.fn === null &&
                      getTest(ndx).match.nativeDef === '\'' +
                      charCodes.charAt(0) || getTest(ndx).match.nativeDef ===
                      ' ' && (getTest(ndx + 1).match.nativeDef ===
                          charCodes.charAt(0) || getTest(ndx + 1).match.fn ===
                          null && getTest(ndx + 1).match.nativeDef === '\'' +
                          charCodes.charAt(0)));
            }

            resetMaskSet();
            if (!strict && opts.autoUnmask !== true) {
              var staticInput = getBufferTemplate().
                  slice(0, seekNext(-1)).
                  join(''), matches = inputValue.join('').
                  match(new RegExp('^' + Inputmask.escapeRegex(staticInput),
                      'g'));
              if (matches && matches.length > 0) {
                inputValue.splice(0, matches.length * staticInput.length);
                initialNdx = seekNext(initialNdx);
              }
            } else {
              initialNdx = seekNext(initialNdx);
            }
            if (initialNdx === -1) {
              getMaskSet().p = seekNext(initialNdx);
              initialNdx = 0;
            } else getMaskSet().p = initialNdx;
            inputmask.caretPos = {
              begin: initialNdx,
            };
            $.each(inputValue, function(ndx, charCode) {
              if (charCode !== undefined) {
                if (getMaskSet().validPositions[ndx] === undefined &&
                    inputValue[ndx] === getPlaceholder(ndx) &&
                    isMask(ndx, true) &&
                    isValid(ndx, inputValue[ndx], true, undefined, undefined,
                        true) === false) {
                  getMaskSet().p++;
                } else {
                  var keypress = new $.Event('_checkval');
                  keypress.which = charCode.charCodeAt(0);
                  charCodes += charCode;
                  var lvp = getLastValidPosition(undefined, true);
                  if (!isTemplateMatch(initialNdx, charCodes)) {
                    result = EventHandlers.keypressEvent.call(input, keypress,
                        true, false, strict, inputmask.caretPos.begin);
                    if (result) {
                      initialNdx = inputmask.caretPos.begin + 1;
                      charCodes = '';
                    }
                  } else {
                    result = EventHandlers.keypressEvent.call(input, keypress,
                        true, false, strict, lvp + 1);
                  }
                  if (result) {
                    writeBuffer(undefined, getBuffer(), result.forwardPosition,
                        keypress, false);
                    inputmask.caretPos = {
                      begin: result.forwardPosition,
                      end: result.forwardPosition,
                    };
                  }
                }
              }
            });
            if (writeOut) writeBuffer(input, getBuffer(),
                result ? result.forwardPosition : undefined, initiatingEvent ||
                new $.Event('checkval'), initiatingEvent &&
                initiatingEvent.type === 'input');
          }

          function unmaskedvalue(input) {
            if (input) {
              if (input.inputmask === undefined) {
                return input.value;
              }
              if (input.inputmask && input.inputmask.refreshValue) {
                EventHandlers.setValueEvent.call(input);
              }
            }
            var umValue = [], vps = getMaskSet().validPositions;
            for (var pndx in vps) {
              if (vps[pndx].match && vps[pndx].match.fn != null) {
                umValue.push(vps[pndx].input);
              }
            }
            var unmaskedValue = umValue.length === 0 ?
                '' :
                (isRTL ? umValue.reverse() : umValue).join('');
            if ($.isFunction(opts.onUnMask)) {
              var bufferValue = (isRTL ?
                  getBuffer().slice().reverse() :
                  getBuffer()).join('');
              unmaskedValue = opts.onUnMask.call(inputmask, bufferValue,
                  unmaskedValue, opts);
            }
            return unmaskedValue;
          }

          function caret(input, begin, end, notranslate) {
            function translatePosition(pos) {
              if (isRTL && typeof pos === 'number' &&
                  (!opts.greedy || opts.placeholder !== '') && el) {
                pos = el.inputmask._valueGet().length - pos;
              }
              return pos;
            }

            var range;
            if (begin !== undefined) {
              if ($.isArray(begin)) {
                end = isRTL ? begin[0] : begin[1];
                begin = isRTL ? begin[1] : begin[0];
              }
              if (begin.begin !== undefined) {
                end = isRTL ? begin.begin : begin.end;
                begin = isRTL ? begin.end : begin.begin;
              }
              if (typeof begin === 'number') {
                begin = notranslate ? begin : translatePosition(begin);
                end = notranslate ? end : translatePosition(end);
                end = typeof end == 'number' ? end : begin;
                var scrollCalc = parseInt(((input.ownerDocument.defaultView ||
                    window).getComputedStyle ?
                    (input.ownerDocument.defaultView ||
                        window).getComputedStyle(input, null) :
                    input.currentStyle).fontSize) * end;
                input.scrollLeft = scrollCalc > input.scrollWidth ?
                    scrollCalc :
                    0;
                input.inputmask.caretPos = {
                  begin: begin,
                  end: end,
                };
                if (input === document.activeElement) {
                  if ('selectionStart' in input) {
                    input.selectionStart = begin;
                    input.selectionEnd = end;
                  } else if (window.getSelection) {
                    range = document.createRange();
                    if (input.firstChild === undefined || input.firstChild ===
                        null) {
                      var textNode = document.createTextNode('');
                      input.appendChild(textNode);
                    }
                    range.setStart(input.firstChild,
                        begin < input.inputmask._valueGet().length ?
                            begin :
                            input.inputmask._valueGet().length);
                    range.setEnd(input.firstChild,
                        end < input.inputmask._valueGet().length ?
                            end :
                            input.inputmask._valueGet().length);
                    range.collapse(true);
                    var sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                  } else if (input.createTextRange) {
                    range = input.createTextRange();
                    range.collapse(true);
                    range.moveEnd('character', end);
                    range.moveStart('character', begin);
                    range.select();
                  }
                  renderColorMask(input, {
                    begin: begin,
                    end: end,
                  });
                }
              }
            } else {
              if ('selectionStart' in input) {
                begin = input.selectionStart;
                end = input.selectionEnd;
              } else if (window.getSelection) {
                range = window.getSelection().getRangeAt(0);
                if (range.commonAncestorContainer.parentNode === input ||
                    range.commonAncestorContainer === input) {
                  begin = range.startOffset;
                  end = range.endOffset;
                }
              } else if (document.selection && document.selection.createRange) {
                range = document.selection.createRange();
                begin = 0 - range.duplicate().
                    moveStart('character', -input.inputmask._valueGet().length);
                end = begin + range.text.length;
              }
              return {
                begin: notranslate ? begin : translatePosition(begin),
                end: notranslate ? end : translatePosition(end),
              };
            }
          }

          function determineLastRequiredPosition(returnDefinition) {
            var buffer = getMaskTemplate(true, getLastValidPosition(), true,
                true), bl = buffer.length, pos, lvp = getLastValidPosition(),
                positions = {}, lvTest = getMaskSet().validPositions[lvp],
                ndxIntlzr = lvTest !== undefined ?
                    lvTest.locator.slice() :
                    undefined, testPos;
            for (pos = lvp + 1; pos < buffer.length; pos++) {
              testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
              ndxIntlzr = testPos.locator.slice();
              positions[pos] = $.extend(true, {}, testPos);
            }
            var lvTestAlt = lvTest && lvTest.alternation !== undefined ?
                lvTest.locator[lvTest.alternation] :
                undefined;
            for (pos = bl - 1; pos > lvp; pos--) {
              testPos = positions[pos];
              if ((testPos.match.optionality ||
                  testPos.match.optionalQuantifier &&
                  testPos.match.newBlockMarker || lvTestAlt &&
                  (lvTestAlt !== positions[pos].locator[lvTest.alternation] &&
                      testPos.match.fn != null || testPos.match.fn === null &&
                      testPos.locator[lvTest.alternation] &&
                      checkAlternationMatch(
                          testPos.locator[lvTest.alternation].toString().
                              split(','), lvTestAlt.toString().split(',')) &&
                      getTests(pos)[0].def !== '')) && buffer[pos] ===
                  getPlaceholder(pos, testPos.match)) {
                bl--;
              } else break;
            }
            return returnDefinition ? {
              l: bl,
              def: positions[bl] ? positions[bl].match : undefined,
            } : bl;
          }

          function clearOptionalTail(buffer) {
            buffer.length = 0;
            var template = getMaskTemplate(true, 0, true, undefined, true),
                lmnt, validPos;
            while (lmnt = template.shift(), lmnt !== undefined) {
              buffer.push(lmnt);
            }
            return buffer;
          }

          function isComplete(buffer) {
            if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer,
                opts);
            if (opts.repeat === '*') return undefined;
            var complete = false, lrp = determineLastRequiredPosition(true),
                aml = seekPrevious(lrp.l);
            if (lrp.def === undefined || lrp.def.newBlockMarker ||
                lrp.def.optionality || lrp.def.optionalQuantifier) {
              complete = true;
              for (var i = 0; i <= aml; i++) {
                var test = getTestTemplate(i).match;
                if (test.fn !== null && getMaskSet().validPositions[i] ===
                    undefined && test.optionality !== true &&
                    test.optionalQuantifier !== true || test.fn === null &&
                    buffer[i] !== getPlaceholder(i, test)) {
                  complete = false;
                  break;
                }
              }
            }
            return complete;
          }

          function handleRemove(input, k, pos, strict, fromIsValid) {
            if (opts.numericInput || isRTL) {
              if (k === Inputmask.keyCode.BACKSPACE) {
                k = Inputmask.keyCode.DELETE;
              } else if (k === Inputmask.keyCode.DELETE) {
                k = Inputmask.keyCode.BACKSPACE;
              }
              if (isRTL) {
                var pend = pos.end;
                pos.end = pos.begin;
                pos.begin = pend;
              }
            }
            if (k === Inputmask.keyCode.BACKSPACE && pos.end - pos.begin < 1) {
              pos.begin = seekPrevious(pos.begin);
              if (getMaskSet().validPositions[pos.begin] !== undefined &&
                  getMaskSet().validPositions[pos.begin].input ===
                  opts.groupSeparator) {
                pos.begin--;
              }
            } else if (k === Inputmask.keyCode.DELETE && pos.begin ===
                pos.end) {
              pos.end = isMask(pos.end, true) &&
              getMaskSet().validPositions[pos.end] &&
              getMaskSet().validPositions[pos.end].input !== opts.radixPoint ?
                  pos.end + 1 :
                  seekNext(pos.end) + 1;
              if (getMaskSet().validPositions[pos.begin] !== undefined &&
                  getMaskSet().validPositions[pos.begin].input ===
                  opts.groupSeparator) {
                pos.end++;
              }
            }
            revalidateMask(pos);
            if (strict !== true && opts.keepStatic !== false || opts.regex !==
                null) {
              var result = alternate(true);
              if (result) {
                var newPos = result.caret !== undefined ?
                    result.caret :
                    result.pos ?
                        seekNext(
                            result.pos.begin ? result.pos.begin : result.pos) :
                        getLastValidPosition(-1, true);
                if (k !== Inputmask.keyCode.DELETE || pos.begin > newPos) {
                  pos.begin == newPos;
                }
              }
            }
            var lvp = getLastValidPosition(pos.begin, true);
            if (lvp < pos.begin || pos.begin === -1) {
              getMaskSet().p = seekNext(lvp);
            } else if (strict !== true) {
              getMaskSet().p = pos.begin;
              if (fromIsValid !== true) {
                while (getMaskSet().p < lvp &&
                getMaskSet().validPositions[getMaskSet().p] === undefined) {
                  getMaskSet().p++;
                }
              }
            }
          }

          function initializeColorMask(input) {
            var computedStyle = (input.ownerDocument.defaultView ||
                window).getComputedStyle(input, null);

            function findCaretPos(clientx) {
              var e = document.createElement('span'), caretPos;
              for (var style in computedStyle) {
                if (isNaN(style) && style.indexOf('font') !== -1) {
                  e.style[style] = computedStyle[style];
                }
              }
              e.style.textTransform = computedStyle.textTransform;
              e.style.letterSpacing = computedStyle.letterSpacing;
              e.style.position = 'absolute';
              e.style.height = 'auto';
              e.style.width = 'auto';
              e.style.visibility = 'hidden';
              e.style.whiteSpace = 'nowrap';
              document.body.appendChild(e);
              var inputText = input.inputmask._valueGet(), previousWidth = 0,
                  itl;
              for (caretPos = 0, itl = inputText.length; caretPos <=
              itl; caretPos++) {
                e.innerHTML += inputText.charAt(caretPos) || '_';
                if (e.offsetWidth >= clientx) {
                  var offset1 = clientx - previousWidth;
                  var offset2 = e.offsetWidth - clientx;
                  e.innerHTML = inputText.charAt(caretPos);
                  offset1 -= e.offsetWidth / 3;
                  caretPos = offset1 < offset2 ? caretPos - 1 : caretPos;
                  break;
                }
                previousWidth = e.offsetWidth;
              }
              document.body.removeChild(e);
              return caretPos;
            }

            var template = document.createElement('div');
            template.style.width = computedStyle.width;
            template.style.textAlign = computedStyle.textAlign;
            colorMask = document.createElement('div');
            input.inputmask.colorMask = colorMask;
            colorMask.className = 'im-colormask';
            input.parentNode.insertBefore(colorMask, input);
            input.parentNode.removeChild(input);
            colorMask.appendChild(input);
            colorMask.appendChild(template);
            input.style.left = template.offsetLeft + 'px';
            $(colorMask).on('mouseleave', function(e) {
              return EventHandlers.mouseleaveEvent.call(input, [e]);
            });
            $(colorMask).on('mouseenter', function(e) {
              return EventHandlers.mouseenterEvent.call(input, [e]);
            });
            $(colorMask).on('click', function(e) {
              caret(input, findCaretPos(e.clientX));
              return EventHandlers.clickEvent.call(input, [e]);
            });
          }

          Inputmask.prototype.positionColorMask = function(input, template) {
            input.style.left = template.offsetLeft + 'px';
          };

          function renderColorMask(input, caretPos, clear) {
            var maskTemplate = [], isStatic = false, test, testPos, ndxIntlzr,
                pos = 0;

            function setEntry(entry) {
              if (entry === undefined) entry = '';
              if (!isStatic &&
                  (test.fn === null || testPos.input === undefined)) {
                isStatic = true;
                maskTemplate.push('<span class=\'im-static\'>' + entry);
              } else if (isStatic &&
                  (test.fn !== null && testPos.input !== undefined ||
                      test.def === '')) {
                isStatic = false;
                var mtl = maskTemplate.length;
                maskTemplate[mtl - 1] = maskTemplate[mtl - 1] + '</span>';
                maskTemplate.push(entry);
              } else maskTemplate.push(entry);
            }

            function setCaret() {
              if (document.activeElement === input) {
                maskTemplate.splice(caretPos.begin, 0,
                    caretPos.begin === caretPos.end ||
                    caretPos.end > getMaskSet().maskLength ?
                        '<mark class="im-caret" style="border-right-width: 1px;border-right-style: solid;">' :
                        '<mark class="im-caret-select">');
                maskTemplate.splice(caretPos.end + 1, 0, '</mark>');
              }
            }

            if (colorMask !== undefined) {
              var buffer = getBuffer();
              if (caretPos === undefined) {
                caretPos = caret(input);
              } else if (caretPos.begin === undefined) {
                caretPos = {
                  begin: caretPos,
                  end: caretPos,
                };
              }
              if (clear !== true) {
                var lvp = getLastValidPosition();
                do {
                  if (getMaskSet().validPositions[pos]) {
                    testPos = getMaskSet().validPositions[pos];
                    test = testPos.match;
                    ndxIntlzr = testPos.locator.slice();
                    setEntry(buffer[pos]);
                  } else {
                    testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                    test = testPos.match;
                    ndxIntlzr = testPos.locator.slice();
                    if (opts.jitMasking === false || pos < lvp ||
                        typeof opts.jitMasking === 'number' &&
                        isFinite(opts.jitMasking) && opts.jitMasking > pos) {
                      setEntry(getPlaceholder(pos, test));
                    } else isStatic = false;
                  }
                  pos++;
                } while ((maxLength === undefined || pos < maxLength) &&
                (test.fn !== null || test.def !== '') || lvp > pos || isStatic);
                if (isStatic) setEntry();
                setCaret();
              }
              var template = colorMask.getElementsByTagName('div')[0];
              template.innerHTML = maskTemplate.join('');
              input.inputmask.positionColorMask(input, template);
            }
          }

          function mask(elem) {
            function isElementTypeSupported(input, opts) {
              function patchValueProperty(npt) {
                var valueGet;
                var valueSet;

                function patchValhook(type) {
                  if ($.valHooks && ($.valHooks[type] === undefined ||
                      $.valHooks[type].inputmaskpatch !== true)) {
                    var valhookGet = $.valHooks[type] && $.valHooks[type].get ?
                        $.valHooks[type].get :
                        function(elem) {
                          return elem.value;
                        };
                    var valhookSet = $.valHooks[type] && $.valHooks[type].set ?
                        $.valHooks[type].set :
                        function(elem, value) {
                          elem.value = value;
                          return elem;
                        };
                    $.valHooks[type] = {
                      get: function get(elem) {
                        if (elem.inputmask) {
                          if (elem.inputmask.opts.autoUnmask) {
                            return elem.inputmask.unmaskedvalue();
                          } else {
                            var result = valhookGet(elem);
                            return getLastValidPosition(undefined, undefined,
                                elem.inputmask.maskset.validPositions) !== -1 ||
                            opts.nullable !== true ? result : '';
                          }
                        } else return valhookGet(elem);
                      },
                      set: function set(elem, value) {
                        var $elem = $(elem), result;
                        result = valhookSet(elem, value);
                        if (elem.inputmask) {
                          $elem.trigger('setvalue', [value]);
                        }
                        return result;
                      },
                      inputmaskpatch: true,
                    };
                  }
                }

                function getter() {
                  if (this.inputmask) {
                    return this.inputmask.opts.autoUnmask ?
                        this.inputmask.unmaskedvalue() :
                        getLastValidPosition() !== -1 ||
                        opts.nullable !== true ?
                            document.activeElement === this &&
                            opts.clearMaskOnLostFocus ?
                                (isRTL ?
                                    clearOptionalTail(getBuffer().slice()).
                                        reverse() :
                                    clearOptionalTail(
                                        getBuffer().slice())).join('') :
                                valueGet.call(this) :
                            '';
                  } else return valueGet.call(this);
                }

                function setter(value) {
                  valueSet.call(this, value);
                  if (this.inputmask) {
                    $(this).trigger('setvalue', [value]);
                  }
                }

                function installNativeValueSetFallback(npt) {
                  EventRuler.on(npt, 'mouseenter', function(event) {
                    var $input = $(this), input = this,
                        value = input.inputmask._valueGet();
                    if (value !== getBuffer().join('')) {
                      $input.trigger('setvalue');
                    }
                  });
                }

                if (!npt.inputmask.__valueGet) {
                  if (opts.noValuePatching !== true) {
                    if (Object.getOwnPropertyDescriptor) {
                      if (typeof Object.getPrototypeOf !== 'function') {
                        Object.getPrototypeOf = _typeof('test'.__proto__) ===
                        'object' ? function(object) {
                          return object.__proto__;
                        } : function(object) {
                          return object.constructor.prototype;
                        };
                      }
                      var valueProperty = Object.getPrototypeOf ?
                          Object.getOwnPropertyDescriptor(
                              Object.getPrototypeOf(npt), 'value') :
                          undefined;
                      if (valueProperty && valueProperty.get &&
                          valueProperty.set) {
                        valueGet = valueProperty.get;
                        valueSet = valueProperty.set;
                        Object.defineProperty(npt, 'value', {
                          get: getter,
                          set: setter,
                          configurable: true,
                        });
                      } else if (npt.tagName !== 'INPUT') {
                        valueGet = function valueGet() {
                          return this.textContent;
                        };
                        valueSet = function valueSet(value) {
                          this.textContent = value;
                        };
                        Object.defineProperty(npt, 'value', {
                          get: getter,
                          set: setter,
                          configurable: true,
                        });
                      }
                    } else if (document.__lookupGetter__ &&
                        npt.__lookupGetter__('value')) {
                      valueGet = npt.__lookupGetter__('value');
                      valueSet = npt.__lookupSetter__('value');
                      npt.__defineGetter__('value', getter);
                      npt.__defineSetter__('value', setter);
                    }
                    npt.inputmask.__valueGet = valueGet;
                    npt.inputmask.__valueSet = valueSet;
                  }
                  npt.inputmask._valueGet = function(overruleRTL) {
                    return isRTL && overruleRTL !== true ?
                        valueGet.call(this.el).split('').reverse().join('') :
                        valueGet.call(this.el);
                  };
                  npt.inputmask._valueSet = function(value, overruleRTL) {
                    valueSet.call(this.el,
                        value === null || value === undefined ?
                            '' :
                            overruleRTL !== true && isRTL ?
                                value.split('').reverse().join('') :
                                value);
                  };
                  if (valueGet === undefined) {
                    valueGet = function valueGet() {
                      return this.value;
                    };
                    valueSet = function valueSet(value) {
                      this.value = value;
                    };
                    patchValhook(npt.type);
                    installNativeValueSetFallback(npt);
                  }
                }
              }

              var elementType = input.getAttribute('type');
              var isSupported = input.tagName === 'INPUT' &&
                  $.inArray(elementType, opts.supportsInputType) !== -1 ||
                  input.isContentEditable || input.tagName === 'TEXTAREA';
              if (!isSupported) {
                if (input.tagName === 'INPUT') {
                  var el = document.createElement('input');
                  el.setAttribute('type', elementType);
                  isSupported = el.type === 'text';
                  el = null;
                } else isSupported = 'partial';
              }
              if (isSupported !== false) {
                patchValueProperty(input);
              } else input.inputmask = undefined;
              return isSupported;
            }

            EventRuler.off(elem);
            var isSupported = isElementTypeSupported(elem, opts);
            if (isSupported !== false) {
              el = elem;
              $el = $(el);
              originalPlaceholder = el.placeholder;
              maxLength = el !== undefined ? el.maxLength : undefined;
              if (maxLength === -1) maxLength = undefined;
              if (opts.colorMask === true) {
                initializeColorMask(el);
              }
              if (mobile) {
                if ('inputmode' in el) {
                  el.inputmode = opts.inputmode;
                  el.setAttribute('inputmode', opts.inputmode);
                }
                if (opts.disablePredictiveText === true) {
                  if ('autocorrect' in el) {
                    el.autocorrect = false;
                  } else {
                    if (opts.colorMask !== true) {
                      initializeColorMask(el);
                    }
                    el.type = 'password';
                  }
                }
              }
              if (isSupported === true) {
                el.setAttribute('im-insert', opts.insertMode);
                EventRuler.on(el, 'submit', EventHandlers.submitEvent);
                EventRuler.on(el, 'reset', EventHandlers.resetEvent);
                EventRuler.on(el, 'blur', EventHandlers.blurEvent);
                EventRuler.on(el, 'focus', EventHandlers.focusEvent);
                if (opts.colorMask !== true) {
                  EventRuler.on(el, 'click', EventHandlers.clickEvent);
                  EventRuler.on(el, 'mouseleave',
                      EventHandlers.mouseleaveEvent);
                  EventRuler.on(el, 'mouseenter',
                      EventHandlers.mouseenterEvent);
                }
                EventRuler.on(el, 'paste', EventHandlers.pasteEvent);
                EventRuler.on(el, 'cut', EventHandlers.cutEvent);
                EventRuler.on(el, 'complete', opts.oncomplete);
                EventRuler.on(el, 'incomplete', opts.onincomplete);
                EventRuler.on(el, 'cleared', opts.oncleared);
                if (!mobile && opts.inputEventOnly !== true) {
                  EventRuler.on(el, 'keydown', EventHandlers.keydownEvent);
                  EventRuler.on(el, 'keypress', EventHandlers.keypressEvent);
                } else {
                  el.removeAttribute('maxLength');
                }
                EventRuler.on(el, 'input', EventHandlers.inputFallBackEvent);
                EventRuler.on(el, 'beforeinput',
                    EventHandlers.beforeInputEvent);
              }
              EventRuler.on(el, 'setvalue', EventHandlers.setValueEvent);
              undoValue = getBufferTemplate().join('');
              if (el.inputmask._valueGet(true) !== '' ||
                  opts.clearMaskOnLostFocus === false ||
                  document.activeElement === el) {
                var initialValue = $.isFunction(opts.onBeforeMask) ?
                    opts.onBeforeMask.call(inputmask,
                        el.inputmask._valueGet(true), opts) ||
                    el.inputmask._valueGet(true) :
                    el.inputmask._valueGet(true);
                if (initialValue !== '') checkVal(el, true, false,
                    initialValue.split(''));
                var buffer = getBuffer().slice();
                undoValue = buffer.join('');
                if (isComplete(buffer) === false) {
                  if (opts.clearIncomplete) {
                    resetMaskSet();
                  }
                }
                if (opts.clearMaskOnLostFocus && document.activeElement !==
                    el) {
                  if (getLastValidPosition() === -1) {
                    buffer = [];
                  } else {
                    clearOptionalTail(buffer);
                  }
                }
                if (opts.clearMaskOnLostFocus === false ||
                    opts.showMaskOnFocus && document.activeElement === el ||
                    el.inputmask._valueGet(true) !== '') writeBuffer(el,
                    buffer);
                if (document.activeElement === el) {
                  caret(el, seekNext(getLastValidPosition()));
                }
              }
            }
          }

          var valueBuffer;
          if (actionObj !== undefined) {
            switch (actionObj.action) {
              case 'isComplete':
                el = actionObj.el;
                return isComplete(getBuffer());

              case 'unmaskedvalue':
                if (el === undefined || actionObj.value !== undefined) {
                  valueBuffer = actionObj.value;
                  valueBuffer = ($.isFunction(opts.onBeforeMask) ?
                      opts.onBeforeMask.call(inputmask, valueBuffer, opts) ||
                      valueBuffer :
                      valueBuffer).split('');
                  checkVal.call(this, undefined, false, false, valueBuffer);
                  if ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite.call(
                      inputmask, undefined, getBuffer(), 0, opts);
                }
                return unmaskedvalue(el);

              case 'mask':
                mask(el);
                break;

              case 'format':
                valueBuffer = ($.isFunction(opts.onBeforeMask) ?
                    opts.onBeforeMask.call(inputmask, actionObj.value, opts) ||
                    actionObj.value :
                    actionObj.value).split('');
                checkVal.call(this, undefined, true, false, valueBuffer);
                if (actionObj.metadata) {
                  return {
                    value: isRTL ?
                        getBuffer().slice().reverse().join('') :
                        getBuffer().join(''),
                    metadata: maskScope.call(this, {
                      action: 'getmetadata',
                    }, maskset, opts),
                  };
                }
                return isRTL ?
                    getBuffer().slice().reverse().join('') :
                    getBuffer().join('');

              case 'isValid':
                if (actionObj.value) {
                  valueBuffer = actionObj.value.split('');
                  checkVal.call(this, undefined, true, true, valueBuffer);
                } else {
                  actionObj.value = getBuffer().join('');
                }
                var buffer = getBuffer();
                var rl = determineLastRequiredPosition(),
                    lmib = buffer.length - 1;
                for (; lmib > rl; lmib--) {
                  if (isMask(lmib)) break;
                }
                buffer.splice(rl, lmib + 1 - rl);
                return isComplete(buffer) && actionObj.value ===
                    getBuffer().join('');

              case 'getemptymask':
                return getBufferTemplate().join('');

              case 'remove':
                if (el && el.inputmask) {
                  $.data(el, '_inputmask_opts', null);
                  $el = $(el);
                  el.inputmask._valueSet(opts.autoUnmask ?
                      unmaskedvalue(el) :
                      el.inputmask._valueGet(true));
                  EventRuler.off(el);
                  if (el.inputmask.colorMask) {
                    colorMask = el.inputmask.colorMask;
                    colorMask.removeChild(el);
                    colorMask.parentNode.insertBefore(el, colorMask);
                    colorMask.parentNode.removeChild(colorMask);
                  }
                  var valueProperty;
                  if (Object.getOwnPropertyDescriptor &&
                      Object.getPrototypeOf) {
                    valueProperty = Object.getOwnPropertyDescriptor(
                        Object.getPrototypeOf(el), 'value');
                    if (valueProperty) {
                      if (el.inputmask.__valueGet) {
                        Object.defineProperty(el, 'value', {
                          get: el.inputmask.__valueGet,
                          set: el.inputmask.__valueSet,
                          configurable: true,
                        });
                      }
                    }
                  } else if (document.__lookupGetter__ &&
                      el.__lookupGetter__('value')) {
                    if (el.inputmask.__valueGet) {
                      el.__defineGetter__('value', el.inputmask.__valueGet);
                      el.__defineSetter__('value', el.inputmask.__valueSet);
                    }
                  }
                  el.inputmask = undefined;
                }
                return el;
                break;

              case 'getmetadata':
                if ($.isArray(maskset.metadata)) {
                  var maskTarget = getMaskTemplate(true, 0, false).join('');
                  $.each(maskset.metadata, function(ndx, mtdt) {
                    if (mtdt.mask === maskTarget) {
                      maskTarget = mtdt;
                      return false;
                    }
                  });
                  return maskTarget;
                }
                return maskset.metadata;
            }
          }
        }

        return Inputmask;
      });
    }, function(module, exports, __webpack_require__) {
      'use strict';
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' &&
      typeof Symbol.iterator === 'symbol' ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === 'function' &&
        obj.constructor === Symbol && obj !== Symbol.prototype ?
            'symbol' :
            typeof obj;
      };
      (function(factory) {
        if (true) {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = factory,
              __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
              'function' ?
                  __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports,
                      __WEBPACK_AMD_DEFINE_ARRAY__) :
                  __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(function($) {
        return $;
      });
    }, function(module, exports) {
      module.exports = jQuery;
    }, function(module, exports, __webpack_require__) {
      'use strict';
      var __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' &&
      typeof Symbol.iterator === 'symbol' ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === 'function' &&
        obj.constructor === Symbol && obj !== Symbol.prototype ?
            'symbol' :
            typeof obj;
      };
      if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
        return window;
      }.call(exports, __webpack_require__, exports,
          module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
      (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else {
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      var __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' &&
      typeof Symbol.iterator === 'symbol' ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === 'function' &&
        obj.constructor === Symbol && obj !== Symbol.prototype ?
            'symbol' :
            typeof obj;
      };
      if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
        return document;
      }.call(exports, __webpack_require__, exports,
          module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
      (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else {
      }
    }, function(module, exports, __webpack_require__) {
      'use strict';
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' &&
      typeof Symbol.iterator === 'symbol' ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === 'function' &&
        obj.constructor === Symbol && obj !== Symbol.prototype ?
            'symbol' :
            typeof obj;
      };
      (function(factory) {
        if (true) {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = factory,
              __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
              'function' ?
                  __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports,
                      __WEBPACK_AMD_DEFINE_ARRAY__) :
                  __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(function(Inputmask) {
        var $ = Inputmask.dependencyLib;
        var formatCode = {
          d: [
            '[1-9]|[12][0-9]|3[01]',
            Date.prototype.setDate,
            'day',
            Date.prototype.getDate],
          dd: [
            '0[1-9]|[12][0-9]|3[01]',
            Date.prototype.setDate,
            'day',
            function() {
              return pad(Date.prototype.getDate.call(this), 2);
            }],
          ddd: [''],
          dddd: [''],
          m: [
            '[1-9]|1[012]', Date.prototype.setMonth, 'month', function() {
              return Date.prototype.getMonth.call(this) + 1;
            }],
          mm: [
            '0[1-9]|1[012]', Date.prototype.setMonth, 'month', function() {
              return pad(Date.prototype.getMonth.call(this) + 1, 2);
            }],
          mmm: [''],
          mmmm: [''],
          yy: [
            '[0-9]{2}', Date.prototype.setFullYear, 'year', function() {
              return pad(Date.prototype.getFullYear.call(this), 2);
            }],
          yyyy: [
            '[0-9]{4}', Date.prototype.setFullYear, 'year', function() {
              return pad(Date.prototype.getFullYear.call(this), 4);
            }],
          h: [
            '[1-9]|1[0-2]',
            Date.prototype.setHours,
            'hours',
            Date.prototype.getHours],
          hh: [
            '0[1-9]|1[0-2]', Date.prototype.setHours, 'hours', function() {
              return pad(Date.prototype.getHours.call(this), 2);
            }],
          hhh: [
            '[0-9]+',
            Date.prototype.setHours,
            'hours',
            Date.prototype.getHours],
          H: [
            '1?[0-9]|2[0-3]',
            Date.prototype.setHours,
            'hours',
            Date.prototype.getHours],
          HH: [
            '[01][0-9]|2[0-3]', Date.prototype.setHours, 'hours', function() {
              return pad(Date.prototype.getHours.call(this), 2);
            }],
          HHH: [
            '[0-9]+',
            Date.prototype.setHours,
            'hours',
            Date.prototype.getHours],
          M: [
            '[1-5]?[0-9]',
            Date.prototype.setMinutes,
            'minutes',
            Date.prototype.getMinutes],
          MM: [
            '[0-5][0-9]', Date.prototype.setMinutes, 'minutes', function() {
              return pad(Date.prototype.getMinutes.call(this), 2);
            }],
          s: [
            '[1-5]?[0-9]',
            Date.prototype.setSeconds,
            'seconds',
            Date.prototype.getSeconds],
          ss: [
            '[0-5][0-9]', Date.prototype.setSeconds, 'seconds', function() {
              return pad(Date.prototype.getSeconds.call(this), 2);
            }],
          l: [
            '[0-9]{3}',
            Date.prototype.setMilliseconds,
            'milliseconds',
            function() {
              return pad(Date.prototype.getMilliseconds.call(this), 3);
            }],
          L: [
            '[0-9]{2}',
            Date.prototype.setMilliseconds,
            'milliseconds',
            function() {
              return pad(Date.prototype.getMilliseconds.call(this), 2);
            }],
          t: ['[ap]'],
          tt: ['[ap]m'],
          T: ['[AP]'],
          TT: ['[AP]M'],
          Z: [''],
          o: [''],
          S: [''],
        }, formatAlias = {
          isoDate: 'yyyy-mm-dd',
          isoTime: 'HH:MM:ss',
          isoDateTime: 'yyyy-mm-dd\'T\'HH:MM:ss',
          isoUtcDateTime: 'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
        };

        function getTokenizer(opts) {
          if (!opts.tokenizer) {
            var tokens = [];
            for (var ndx in formatCode) {
              if (tokens.indexOf(ndx[0]) === -1) tokens.push(ndx[0]);
            }
            opts.tokenizer = '(' + tokens.join('+|') + ')+?|.';
            opts.tokenizer = new RegExp(opts.tokenizer, 'g');
          }
          return opts.tokenizer;
        }

        function isValidDate(dateParts, currentResult) {
          return !isFinite(dateParts.rawday) ||
          dateParts.day == '29' && !isFinite(dateParts.rawyear) ||
          new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ?
              dateParts.month :
              dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day ?
              currentResult :
              false;
        }

        function isDateInRange(dateParts, opts) {
          var result = true;
          if (opts.min) {
            if (dateParts['rawyear']) {
              var rawYear = dateParts['rawyear'].replace(/[^0-9]/g, ''),
                  minYear = opts.min.year.substr(0, rawYear.length);
              result = minYear <= rawYear;
            }
            if (dateParts['year'] === dateParts['rawyear']) {
              if (opts.min.date.getTime() === opts.min.date.getTime()) {
                result = opts.min.date.getTime() <= dateParts.date.getTime();
              }
            }
          }
          if (result && opts.max && opts.max.date.getTime() ===
              opts.max.date.getTime()) {
            result = opts.max.date.getTime() >= dateParts.date.getTime();
          }
          return result;
        }

        function parse(format, dateObjValue, opts, raw) {
          var mask = '', match;
          while (match = getTokenizer(opts).exec(format)) {
            if (dateObjValue === undefined) {
              if (formatCode[match[0]]) {
                mask += '(' + formatCode[match[0]][0] + ')';
              } else {
                switch (match[0]) {
                  case '[':
                    mask += '(';
                    break;

                  case ']':
                    mask += ')?';
                    break;

                  default:
                    mask += Inputmask.escapeRegex(match[0]);
                }
              }
            } else {
              if (formatCode[match[0]]) {
                if (raw !== true && formatCode[match[0]][3]) {
                  var getFn = formatCode[match[0]][3];
                  mask += getFn.call(dateObjValue.date);
                } else if (formatCode[match[0]][2]) mask += dateObjValue['raw' +
                formatCode[match[0]][2]]; else mask += match[0];
              } else mask += match[0];
            }
          }
          return mask;
        }

        function pad(val, len) {
          val = String(val);
          len = len || 2;
          while (val.length < len) {
            val = '0' + val;
          }
          return val;
        }

        function analyseMask(maskString, format, opts) {
          var dateObj = {
                date: new Date(1, 0, 1),
              }, targetProp, mask = maskString, match, dateOperation,
              targetValidator;

          function extendProperty(value) {
            var correctedValue;
            if (opts.min && opts.min[targetProp] || opts.max &&
                opts.max[targetProp]) {
              var min = opts.min && opts.min[targetProp] ||
                  opts.max[targetProp],
                  max = opts.max && opts.max[targetProp] ||
                      opts.min[targetProp];
              correctedValue = value.replace(/[^0-9]/g, '');
              correctedValue += (min.indexOf(correctedValue) <
              max.indexOf(correctedValue) ? max : min).toString().
                  substr(correctedValue.length);
              while (!new RegExp(targetValidator).test(correctedValue)) {
                correctedValue--;
              }
            } else correctedValue = value.replace(/[^0-9]/g, '0');
            return correctedValue;
          }

          function setValue(dateObj, value, opts) {
            dateObj[targetProp] = extendProperty(value);
            dateObj['raw' + targetProp] = value;
            if (dateOperation !== undefined) dateOperation.call(dateObj.date,
                targetProp == 'month' ?
                    parseInt(dateObj[targetProp]) - 1 :
                    dateObj[targetProp]);
          }

          if (typeof mask === 'string') {
            while (match = getTokenizer(opts).exec(format)) {
              var value = mask.slice(0, match[0].length);
              if (formatCode.hasOwnProperty(match[0])) {
                targetValidator = formatCode[match[0]][0];
                targetProp = formatCode[match[0]][2];
                dateOperation = formatCode[match[0]][1];
                setValue(dateObj, value, opts);
              }
              mask = mask.slice(value.length);
            }
            return dateObj;
          } else if (mask &&
              (typeof mask === 'undefined' ? 'undefined' : _typeof(mask)) ===
              'object' && mask.hasOwnProperty('date')) {
            return mask;
          }
          return undefined;
        }

        Inputmask.extendAliases({
          datetime: {
            mask: function mask(opts) {
              formatCode.S = opts.i18n.ordinalSuffix.join('|');
              opts.inputFormat = formatAlias[opts.inputFormat] ||
                  opts.inputFormat;
              opts.displayFormat = formatAlias[opts.displayFormat] ||
                  opts.displayFormat || opts.inputFormat;
              opts.outputFormat = formatAlias[opts.outputFormat] ||
                  opts.outputFormat || opts.inputFormat;
              opts.placeholder = opts.placeholder !== '' ?
                  opts.placeholder :
                  opts.inputFormat.replace(/[\[\]]/, '');
              opts.regex = parse(opts.inputFormat, undefined, opts);
              return null;
            },
            placeholder: '',
            inputFormat: 'isoDateTime',
            displayFormat: undefined,
            outputFormat: undefined,
            min: null,
            max: null,
            i18n: {
              dayNames: [
                'Mon',
                'Tue',
                'Wed',
                'Thu',
                'Fri',
                'Sat',
                'Sun',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday',
                'Sunday'],
              monthNames: [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec',
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December'],
              ordinalSuffix: ['st', 'nd', 'rd', 'th'],
            },
            postValidation: function postValidation(
                buffer, pos, currentResult, opts) {
              opts.min = analyseMask(opts.min, opts.inputFormat, opts);
              opts.max = analyseMask(opts.max, opts.inputFormat, opts);
              var result = currentResult,
                  dateParts = analyseMask(buffer.join(''), opts.inputFormat,
                      opts);
              if (result && dateParts.date.getTime() ===
                  dateParts.date.getTime()) {
                result = isValidDate(dateParts, result);
                result = result && isDateInRange(dateParts, opts);
              }
              if (pos && result && currentResult.pos !== pos) {
                return {
                  buffer: parse(opts.inputFormat, dateParts, opts),
                  refreshFromBuffer: {
                    start: pos,
                    end: currentResult.pos,
                  },
                };
              }
              return result;
            },
            onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {
              var input = this;
              if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
                var today = new Date(), match, date = '';
                while (match = getTokenizer(opts).exec(opts.inputFormat)) {
                  if (match[0].charAt(0) === 'd') {
                    date += pad(today.getDate(), match[0].length);
                  } else if (match[0].charAt(0) === 'm') {
                    date += pad(today.getMonth() + 1, match[0].length);
                  } else if (match[0] === 'yyyy') {
                    date += today.getFullYear().toString();
                  } else if (match[0].charAt(0) === 'y') {
                    date += pad(today.getYear(), match[0].length);
                  }
                }
                input.inputmask._valueSet(date);
                $(input).trigger('setvalue');
              }
            },
            onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
              return parse(opts.outputFormat,
                  analyseMask(maskedValue, opts.inputFormat, opts), opts, true);
            },
            casing: function casing(elem, test, pos, validPositions) {
              if (test.nativeDef.indexOf('[ap]') ==
                  0) return elem.toLowerCase();
              if (test.nativeDef.indexOf('[AP]') ==
                  0) return elem.toUpperCase();
              return elem;
            },
            insertMode: false,
          },
        });
        return Inputmask;
      });
    }, function(module, exports, __webpack_require__) {
      'use strict';
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' &&
      typeof Symbol.iterator === 'symbol' ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === 'function' &&
        obj.constructor === Symbol && obj !== Symbol.prototype ?
            'symbol' :
            typeof obj;
      };
      (function(factory) {
        if (true) {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = factory,
              __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
              'function' ?
                  __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports,
                      __WEBPACK_AMD_DEFINE_ARRAY__) :
                  __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(function(Inputmask) {
        var $ = Inputmask.dependencyLib;

        function autoEscape(txt, opts) {
          var escapedTxt = '';
          for (var i = 0; i < txt.length; i++) {
            if (Inputmask.prototype.definitions[txt.charAt(i)] ||
                opts.definitions[txt.charAt(i)] || opts.optionalmarker.start ===
                txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) ||
                opts.quantifiermarker.start === txt.charAt(i) ||
                opts.quantifiermarker.end === txt.charAt(i) ||
                opts.groupmarker.start === txt.charAt(i) ||
                opts.groupmarker.end === txt.charAt(i) ||
                opts.alternatormarker === txt.charAt(i)) {
              escapedTxt += '\\' + txt.charAt(i);
            } else escapedTxt += txt.charAt(i);
          }
          return escapedTxt;
        }

        function alignDigits(buffer, opts) {
          if (opts.numericInput) {
            var radixPosition = $.inArray(opts.radixPoint, buffer);
            if (radixPosition === -1) {
              buffer.push(opts.radixPoint);
              radixPosition = buffer.length - 1;
            }
            for (var i = 1; i <= opts.digits; i++) {
              buffer[radixPosition + i] = buffer[radixPosition + i] || '0';
            }
          }
          return buffer;
        }

        Inputmask.extendAliases({
          numeric: {
            mask: function mask(opts) {
              if (opts.repeat !== 0 && isNaN(opts.integerDigits)) {
                opts.integerDigits = opts.repeat;
              }
              opts.repeat = 0;
              if (opts.groupSeparator === opts.radixPoint && opts.digits &&
                  opts.digits !== '0') {
                if (opts.radixPoint === '.') {
                  opts.groupSeparator = ',';
                } else if (opts.radixPoint === ',') {
                  opts.groupSeparator = '.';
                } else opts.groupSeparator = '';
              }
              if (opts.groupSeparator === ' ') {
                opts.skipOptionalPartCharacter = undefined;
              }
              opts.autoGroup = opts.autoGroup && opts.groupSeparator !== '';
              if (opts.autoGroup) {
                if (typeof opts.groupSize == 'string' &&
                    isFinite(opts.groupSize)) opts.groupSize = parseInt(
                    opts.groupSize);
                if (isFinite(opts.integerDigits)) {
                  var seps = Math.floor(opts.integerDigits / opts.groupSize);
                  var mod = opts.integerDigits % opts.groupSize;
                  opts.integerDigits = parseInt(opts.integerDigits) +
                      (mod === 0 ? seps - 1 : seps);
                  if (opts.integerDigits < 1) {
                    opts.integerDigits = '*';
                  }
                }
              }
              if (opts.placeholder.length > 1) {
                opts.placeholder = opts.placeholder.charAt(0);
              }
              if (opts.positionCaretOnClick === 'radixFocus' &&
                  opts.placeholder === '' && opts.integerOptional === false) {
                opts.positionCaretOnClick = 'lvp';
              }
              opts.definitions[';'] = opts.definitions['~'];
              opts.definitions[';'].definitionSymbol = '~';
              if (opts.numericInput === true) {
                opts.positionCaretOnClick = opts.positionCaretOnClick ===
                'radixFocus' ? 'lvp' : opts.positionCaretOnClick;
                opts.digitsOptional = false;
                if (isNaN(opts.digits)) opts.digits = 2;
                opts.decimalProtect = false;
              }
              var mask = '[+]';
              mask += autoEscape(opts.prefix, opts);
              if (opts.integerOptional === true) {
                mask += '~{1,' + opts.integerDigits + '}';
              } else mask += '~{' + opts.integerDigits + '}';
              if (opts.digits !== undefined) {
                var radixDef = opts.decimalProtect ? ':' : opts.radixPoint;
                var dq = opts.digits.toString().split(',');
                if (isFinite(dq[0]) && dq[1] && isFinite(dq[1])) {
                  mask += radixDef + ';{' + opts.digits + '}';
                } else if (isNaN(opts.digits) || parseInt(opts.digits) > 0) {
                  if (opts.digitsOptional) {
                    mask += '[' + radixDef + ';{1,' + opts.digits + '}]';
                  } else mask += radixDef + ';{' + opts.digits + '}';
                }
              }
              mask += autoEscape(opts.suffix, opts);
              mask += '[-]';
              opts.greedy = false;
              return mask;
            },
            placeholder: '',
            greedy: false,
            digits: '*',
            digitsOptional: true,
            enforceDigitsOnBlur: false,
            radixPoint: '.',
            positionCaretOnClick: 'radixFocus',
            groupSize: 3,
            groupSeparator: '',
            autoGroup: false,
            allowMinus: true,
            negationSymbol: {
              front: '-',
              back: '',
            },
            integerDigits: '+',
            integerOptional: true,
            prefix: '',
            suffix: '',
            rightAlign: true,
            decimalProtect: true,
            min: null,
            max: null,
            step: 1,
            insertMode: true,
            autoUnmask: false,
            unmaskAsNumber: false,
            inputmode: 'numeric',
            preValidation: function preValidation(
                buffer, pos, c, isSelection, opts, maskset) {
              if (c === '-' || c === opts.negationSymbol.front) {
                if (opts.allowMinus !== true) return false;
                opts.isNegative = opts.isNegative === undefined ?
                    true :
                    !opts.isNegative;
                if (buffer.join('') === '') return true;
                return {
                  caret: maskset.validPositions[pos] ? pos : undefined,
                  dopost: true,
                };
              }
              if (isSelection === false && c === opts.radixPoint &&
                  opts.digits !== undefined &&
                  (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {
                var radixPos = $.inArray(opts.radixPoint, buffer);
                if (radixPos !== -1 && maskset.validPositions[radixPos] !==
                    undefined) {
                  if (opts.numericInput === true) {
                    return pos === radixPos;
                  }
                  return {
                    caret: radixPos + 1,
                  };
                }
              }
              return true;
            },
            postValidation: function postValidation(
                buffer, pos, currentResult, opts) {
              function buildPostMask(buffer, opts) {
                var postMask = '';
                postMask += '(' + opts.groupSeparator + '*{' + opts.groupSize +
                    '}){*}';
                if (opts.radixPoint !== '') {
                  var radixSplit = buffer.join('').split(opts.radixPoint);
                  if (radixSplit[1]) {
                    postMask += opts.radixPoint + '*{' +
                        radixSplit[1].match(/^\d*\??\d*/)[0].length + '}';
                  }
                }
                return postMask;
              }

              var suffix = opts.suffix.split(''),
                  prefix = opts.prefix.split('');
              if (currentResult.pos === undefined && currentResult.caret !==
                  undefined && currentResult.dopost !==
                  true) return currentResult;
              var caretPos = currentResult.caret !== undefined ?
                  currentResult.caret :
                  currentResult.pos;
              var maskedValue = buffer.slice();
              if (opts.numericInput) {
                caretPos = maskedValue.length - caretPos - 1;
                maskedValue = maskedValue.reverse();
              }
              var charAtPos = maskedValue[caretPos];
              if (charAtPos === opts.groupSeparator) {
                caretPos += 1;
                charAtPos = maskedValue[caretPos];
              }
              if (caretPos === maskedValue.length - opts.suffix.length - 1 &&
                  charAtPos === opts.radixPoint) return currentResult;
              if (charAtPos !== undefined) {
                if (charAtPos !== opts.radixPoint && charAtPos !==
                    opts.negationSymbol.front && charAtPos !==
                    opts.negationSymbol.back) {
                  maskedValue[caretPos] = '?';
                  if (opts.prefix.length > 0 && caretPos >=
                      (opts.isNegative === false ? 1 : 0) && caretPos <
                      opts.prefix.length - 1 +
                      (opts.isNegative === false ? 1 : 0)) {
                    prefix[caretPos -
                    (opts.isNegative === false ? 1 : 0)] = '?';
                  } else if (opts.suffix.length > 0 && caretPos >=
                      maskedValue.length - opts.suffix.length -
                      (opts.isNegative === false ? 1 : 0)) {
                    suffix[caretPos - (maskedValue.length - opts.suffix.length -
                        (opts.isNegative === false ? 1 : 0))] = '?';
                  }
                }
              }
              prefix = prefix.join('');
              suffix = suffix.join('');
              var processValue = maskedValue.join('').replace(prefix, '');
              processValue = processValue.replace(suffix, '');
              processValue = processValue.replace(
                  new RegExp(Inputmask.escapeRegex(opts.groupSeparator), 'g'),
                  '');
              processValue = processValue.replace(new RegExp('[-' +
                  Inputmask.escapeRegex(opts.negationSymbol.front) + ']', 'g'),
                  '');
              processValue = processValue.replace(
                  new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) +
                      '$'), '');
              if (isNaN(opts.placeholder)) {
                processValue = processValue.replace(
                    new RegExp(Inputmask.escapeRegex(opts.placeholder), 'g'),
                    '');
              }
              if (processValue.length > 1 &&
                  processValue.indexOf(opts.radixPoint) !== 1) {
                if (charAtPos === '0') {
                  processValue = processValue.replace(/^\?/g, '');
                }
                processValue = processValue.replace(/^0/g, '');
              }
              if (processValue.charAt(0) === opts.radixPoint &&
                  opts.radixPoint !== '' && opts.numericInput !== true) {
                processValue = '0' + processValue;
              }
              if (processValue !== '') {
                processValue = processValue.split('');
                if ((!opts.digitsOptional || opts.enforceDigitsOnBlur &&
                    currentResult.event === 'blur') && isFinite(opts.digits)) {
                  var radixPosition = $.inArray(opts.radixPoint, processValue);
                  var rpb = $.inArray(opts.radixPoint, maskedValue);
                  if (radixPosition === -1) {
                    processValue.push(opts.radixPoint);
                    radixPosition = processValue.length - 1;
                  }
                  for (var i = 1; i <= opts.digits; i++) {
                    if ((!opts.digitsOptional || opts.enforceDigitsOnBlur &&
                        currentResult.event === 'blur') &&
                        (processValue[radixPosition + i] === undefined ||
                            processValue[radixPosition + i] ===
                            opts.placeholder.charAt(0))) {
                      processValue[radixPosition +
                      i] = currentResult.placeholder ||
                          opts.placeholder.charAt(0);
                    } else if (rpb !== -1 && maskedValue[rpb + i] !==
                        undefined) {
                      processValue[radixPosition +
                      i] = processValue[radixPosition + i] ||
                          maskedValue[rpb + i];
                    }
                  }
                }
                if (opts.autoGroup === true && opts.groupSeparator !== '' &&
                    (charAtPos !== opts.radixPoint || currentResult.pos !==
                        undefined || currentResult.dopost)) {
                  var addRadix = processValue[processValue.length - 1] ===
                      opts.radixPoint && currentResult.c === opts.radixPoint;
                  processValue = Inputmask(buildPostMask(processValue, opts), {
                    numericInput: true,
                    jitMasking: true,
                    definitions: {
                      '*': {
                        validator: '[0-9?]',
                        cardinality: 1,
                      },
                    },
                  }).format(processValue.join(''));
                  if (addRadix) processValue += opts.radixPoint;
                  if (processValue.charAt(0) === opts.groupSeparator) {
                    processValue.substr(1);
                  }
                } else processValue = processValue.join('');
              }
              if (opts.isNegative && currentResult.event === 'blur') {
                opts.isNegative = processValue !== '0';
              }
              processValue = prefix + processValue;
              processValue += suffix;
              if (opts.isNegative) {
                processValue = opts.negationSymbol.front + processValue;
                processValue += opts.negationSymbol.back;
              }
              processValue = processValue.split('');
              if (charAtPos !== undefined) {
                if (charAtPos !== opts.radixPoint && charAtPos !==
                    opts.negationSymbol.front && charAtPos !==
                    opts.negationSymbol.back) {
                  caretPos = $.inArray('?', processValue);
                  if (caretPos > -1) {
                    processValue[caretPos] = charAtPos;
                  } else caretPos = currentResult.caret || 0;
                } else if (charAtPos === opts.radixPoint || charAtPos ===
                    opts.negationSymbol.front || charAtPos ===
                    opts.negationSymbol.back) {
                  var newCaretPos = $.inArray(charAtPos, processValue);
                  if (newCaretPos !== -1) caretPos = newCaretPos;
                }
              }
              if (opts.numericInput) {
                caretPos = processValue.length - caretPos - 1;
                processValue = processValue.reverse();
              }
              var rslt = {
                caret: (charAtPos === undefined || currentResult.pos !==
                    undefined) && caretPos !== undefined ?
                    caretPos + (opts.numericInput ? -1 : 1) :
                    caretPos,
                buffer: processValue,
                refreshFromBuffer: currentResult.dopost ||
                buffer.join('') !== processValue.join(''),
              };
              return rslt.refreshFromBuffer ? rslt : currentResult;
            },
            onBeforeWrite: function onBeforeWrite(e, buffer, caretPos, opts) {
              function parseMinMaxOptions(opts) {
                if (opts.parseMinMaxOptions === undefined) {
                  if (opts.min !== null) {
                    opts.min = opts.min.toString().
                        replace(new RegExp(
                            Inputmask.escapeRegex(opts.groupSeparator), 'g'),
                            '');
                    if (opts.radixPoint === ',') opts.min = opts.min.replace(
                        opts.radixPoint, '.');
                    opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN;
                    if (isNaN(opts.min)) opts.min = Number.MIN_VALUE;
                  }
                  if (opts.max !== null) {
                    opts.max = opts.max.toString().
                        replace(new RegExp(
                            Inputmask.escapeRegex(opts.groupSeparator), 'g'),
                            '');
                    if (opts.radixPoint === ',') opts.max = opts.max.replace(
                        opts.radixPoint, '.');
                    opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN;
                    if (isNaN(opts.max)) opts.max = Number.MAX_VALUE;
                  }
                  opts.parseMinMaxOptions = 'done';
                }
              }

              if (e) {
                switch (e.type) {
                  case 'keydown':
                    return opts.postValidation(buffer, caretPos, {
                      caret: caretPos,
                      dopost: true,
                    }, opts);

                  case 'blur':
                  case 'checkval':
                    var unmasked;
                    parseMinMaxOptions(opts);
                    if (opts.min !== null || opts.max !== null) {
                      unmasked = opts.onUnMask(buffer.join(''), undefined,
                          $.extend({}, opts, {
                            unmaskAsNumber: true,
                          }));
                      if (opts.min !== null && unmasked < opts.min) {
                        opts.isNegative = opts.min < 0;
                        return opts.postValidation(opts.min.toString().
                            replace('.', opts.radixPoint).
                            split(''), caretPos, {
                          caret: caretPos,
                          dopost: true,
                          placeholder: '0',
                        }, opts);
                      } else if (opts.max !== null && unmasked > opts.max) {
                        opts.isNegative = opts.max < 0;
                        return opts.postValidation(opts.max.toString().
                            replace('.', opts.radixPoint).
                            split(''), caretPos, {
                          caret: caretPos,
                          dopost: true,
                          placeholder: '0',
                        }, opts);
                      }
                    }
                    return opts.postValidation(buffer, caretPos, {
                      caret: caretPos,
                      placeholder: '0',
                      event: 'blur',
                    }, opts);

                  case '_checkval':
                    return {
                      caret: caretPos,
                    };

                  default:
                    break;
                }
              }
            },
            regex: {
              integerPart: function integerPart(opts, emptyCheck) {
                return emptyCheck ?
                    new RegExp('[' +
                        Inputmask.escapeRegex(opts.negationSymbol.front) +
                        '+]?') :
                    new RegExp('[' +
                        Inputmask.escapeRegex(opts.negationSymbol.front) +
                        '+]?\\d+');
              },
              integerNPart: function integerNPart(opts) {
                return new RegExp('[\\d' +
                    Inputmask.escapeRegex(opts.groupSeparator) +
                    Inputmask.escapeRegex(opts.placeholder.charAt(0)) + ']+');
              },
            },
            definitions: {
              '~': {
                validator: function validator(
                    chrs, maskset, pos, strict, opts, isSelection) {
                  var isValid, l;
                  if (chrs === 'k' || chrs === 'm') {
                    isValid = {
                      insert: [],
                      c: 0,
                    };
                    for (var i = 0, l = chrs === 'k' ? 2 : 5; i < l; i++) {
                      isValid.insert.push({
                        pos: pos + i,
                        c: 0,
                      });
                    }
                    isValid.pos = pos + l;
                    return isValid;
                  }
                  isValid = strict ?
                      new RegExp('[0-9' +
                          Inputmask.escapeRegex(opts.groupSeparator) +
                          ']').test(chrs) :
                      new RegExp('[0-9]').test(chrs);
                  if (isValid === true) {
                    if (opts.numericInput !== true &&
                        maskset.validPositions[pos] !== undefined &&
                        maskset.validPositions[pos].match.def === '~' &&
                        !isSelection) {
                      var processValue = maskset.buffer.join('');
                      processValue = processValue.replace(new RegExp('[-' +
                          Inputmask.escapeRegex(opts.negationSymbol.front) +
                          ']', 'g'), '');
                      processValue = processValue.replace(
                          new RegExp(Inputmask.escapeRegex(
                              opts.negationSymbol.back) + '$'), '');
                      var pvRadixSplit = processValue.split(opts.radixPoint);
                      if (pvRadixSplit.length > 1) {
                        pvRadixSplit[1] = pvRadixSplit[1].replace(/0/g,
                            opts.placeholder.charAt(0));
                      }
                      if (pvRadixSplit[0] === '0') {
                        pvRadixSplit[0] = pvRadixSplit[0].replace(/0/g,
                            opts.placeholder.charAt(0));
                      }
                      processValue = pvRadixSplit[0] + opts.radixPoint +
                          pvRadixSplit[1] || '';
                      var bufferTemplate = maskset._buffer.join('');
                      if (processValue === opts.radixPoint) {
                        processValue = bufferTemplate;
                      }
                      while (processValue.match(Inputmask.escapeRegex(
                          bufferTemplate) + '$') === null) {
                        bufferTemplate = bufferTemplate.slice(1);
                      }
                      processValue = processValue.replace(bufferTemplate, '');
                      processValue = processValue.split('');
                      if (processValue[pos] === undefined) {
                        isValid = {
                          pos: pos,
                          remove: pos,
                        };
                      } else {
                        isValid = {
                          pos: pos,
                        };
                      }
                    }
                  } else if (!strict && chrs === opts.radixPoint &&
                      maskset.validPositions[pos - 1] === undefined) {
                    isValid = {
                      insert: {
                        pos: pos,
                        c: 0,
                      },
                      pos: pos + 1,
                    };
                  }
                  return isValid;
                },
                cardinality: 1,
              },
              '+': {
                validator: function validator(
                    chrs, maskset, pos, strict, opts) {
                  return opts.allowMinus &&
                      (chrs === '-' || chrs === opts.negationSymbol.front);
                },
                cardinality: 1,
                placeholder: '',
              },
              '-': {
                validator: function validator(
                    chrs, maskset, pos, strict, opts) {
                  return opts.allowMinus && chrs === opts.negationSymbol.back;
                },
                cardinality: 1,
                placeholder: '',
              },
              ':': {
                validator: function validator(
                    chrs, maskset, pos, strict, opts) {
                  var radix = '[' + Inputmask.escapeRegex(opts.radixPoint) +
                      ']';
                  var isValid = new RegExp(radix).test(chrs);
                  if (isValid && maskset.validPositions[pos] &&
                      maskset.validPositions[pos].match.placeholder ===
                      opts.radixPoint) {
                    isValid = {
                      caret: pos + 1,
                    };
                  }
                  return isValid;
                },
                cardinality: 1,
                placeholder: function placeholder(opts) {
                  return opts.radixPoint;
                },
              },
            },
            onUnMask: function onUnMask(maskedValue, unmaskedValue, opts) {
              if (unmaskedValue === '' && opts.nullable === true) {
                return unmaskedValue;
              }
              var processValue = maskedValue.replace(opts.prefix, '');
              processValue = processValue.replace(opts.suffix, '');
              processValue = processValue.replace(
                  new RegExp(Inputmask.escapeRegex(opts.groupSeparator), 'g'),
                  '');
              if (opts.placeholder.charAt(0) !== '') {
                processValue = processValue.replace(
                    new RegExp(opts.placeholder.charAt(0), 'g'), '0');
              }
              if (opts.unmaskAsNumber) {
                if (opts.radixPoint !== '' &&
                    processValue.indexOf(opts.radixPoint) !==
                    -1) processValue = processValue.replace(
                    Inputmask.escapeRegex.call(this, opts.radixPoint), '.');
                processValue = processValue.replace(new RegExp('^' +
                    Inputmask.escapeRegex(opts.negationSymbol.front)), '-');
                processValue = processValue.replace(
                    new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) +
                        '$'), '');
                return Number(processValue);
              }
              return processValue;
            },
            isComplete: function isComplete(buffer, opts) {
              var maskedValue = (opts.numericInput ?
                  buffer.slice().reverse() :
                  buffer).join('');
              maskedValue = maskedValue.replace(new RegExp('^' +
                  Inputmask.escapeRegex(opts.negationSymbol.front)), '-');
              maskedValue = maskedValue.replace(
                  new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) +
                      '$'), '');
              maskedValue = maskedValue.replace(opts.prefix, '');
              maskedValue = maskedValue.replace(opts.suffix, '');
              maskedValue = maskedValue.replace(
                  new RegExp(Inputmask.escapeRegex(opts.groupSeparator) +
                      '([0-9]{3})', 'g'), '$1');
              if (opts.radixPoint === ',') maskedValue = maskedValue.replace(
                  Inputmask.escapeRegex(opts.radixPoint), '.');
              return isFinite(maskedValue);
            },
            onBeforeMask: function onBeforeMask(initialValue, opts) {
              opts.isNegative = undefined;
              if (typeof initialValue == 'number' && opts.radixPoint !== '') {
                initialValue = initialValue.toString().
                    replace('.', opts.radixPoint);
              }
              initialValue = initialValue.toString().
                  charAt(initialValue.length - 1) === opts.radixPoint ?
                  initialValue.toString().substr(0, initialValue.length - 1) :
                  initialValue.toString();
              if (opts.radixPoint !== '' && isFinite(initialValue)) {
                var vs = initialValue.split('.'),
                    groupSize = opts.groupSeparator !== '' ?
                        parseInt(opts.groupSize) :
                        0;
                if (vs.length === 2 &&
                    (vs[0].length > groupSize || vs[1].length > groupSize ||
                        vs[0].length <= groupSize && vs[1].length <
                        groupSize)) {
                  initialValue = initialValue.replace('.', opts.radixPoint);
                }
              }
              var kommaMatches = initialValue.match(/,/g);
              var dotMatches = initialValue.match(/\./g);
              if (dotMatches && kommaMatches) {
                if (dotMatches.length > kommaMatches.length) {
                  initialValue = initialValue.replace(/\./g, '');
                  initialValue = initialValue.replace(',', opts.radixPoint);
                } else if (kommaMatches.length > dotMatches.length) {
                  initialValue = initialValue.replace(/,/g, '');
                  initialValue = initialValue.replace('.', opts.radixPoint);
                } else {
                  initialValue = initialValue.indexOf('.') <
                  initialValue.indexOf(',') ?
                      initialValue.replace(/\./g, '') :
                      initialValue.replace(/,/g, '');
                }
              } else {
                initialValue = initialValue.replace(
                    new RegExp(Inputmask.escapeRegex(opts.groupSeparator), 'g'),
                    '');
              }
              if (opts.digits === 0) {
                if (initialValue.indexOf('.') !== -1) {
                  initialValue = initialValue.substring(0,
                      initialValue.indexOf('.'));
                } else if (initialValue.indexOf(',') !== -1) {
                  initialValue = initialValue.substring(0,
                      initialValue.indexOf(','));
                }
              }
              if (opts.radixPoint !== '' && isFinite(opts.digits)) {
                if (initialValue.indexOf(opts.radixPoint) !== -1) {
                  var valueParts = initialValue.split(opts.radixPoint),
                      decPart = valueParts[1].match(new RegExp('\\d*'))[0];
                  if (parseInt(opts.digits) < decPart.toString().length) {
                    var digitsFactor = Math.pow(10, parseInt(opts.digits));
                    initialValue = initialValue.replace(
                        Inputmask.escapeRegex(opts.radixPoint), '.');
                    initialValue = Math.round(parseFloat(initialValue) *
                        digitsFactor) / digitsFactor;
                    initialValue = initialValue.toString().
                        replace('.', opts.radixPoint);
                  }
                }
              }
              return alignDigits(initialValue.toString().split(''), opts).
                  join('');
            },
            onKeyDown: function onKeyDown(e, buffer, caretPos, opts) {
              var $input = $(this);
              if (e.ctrlKey) {
                switch (e.keyCode) {
                  case Inputmask.keyCode.UP:
                    $input.val(parseFloat(this.inputmask.unmaskedvalue()) +
                        parseInt(opts.step));
                    $input.trigger('setvalue');
                    break;

                  case Inputmask.keyCode.DOWN:
                    $input.val(parseFloat(this.inputmask.unmaskedvalue()) -
                        parseInt(opts.step));
                    $input.trigger('setvalue');
                    break;
                }
              }
            },
          },
          currency: {
            prefix: '$ ',
            groupSeparator: ',',
            alias: 'numeric',
            placeholder: '0',
            autoGroup: true,
            digits: 2,
            digitsOptional: false,
            clearMaskOnLostFocus: false,
          },
          decimal: {
            alias: 'numeric',
          },
          integer: {
            alias: 'numeric',
            digits: 0,
            radixPoint: '',
          },
          percentage: {
            alias: 'numeric',
            digits: 2,
            digitsOptional: true,
            radixPoint: '.',
            placeholder: '0',
            autoGroup: false,
            min: 0,
            max: 100,
            suffix: ' %',
            allowMinus: false,
          },
        });
        return Inputmask;
      });
    }, function(module, exports, __webpack_require__) {
      'use strict';
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__;
      var _typeof = typeof Symbol === 'function' &&
      typeof Symbol.iterator === 'symbol' ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === 'function' &&
        obj.constructor === Symbol && obj !== Symbol.prototype ?
            'symbol' :
            typeof obj;
      };
      (function(factory) {
        if (true) {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
            __webpack_require__(4),
            __webpack_require__(2)],
              __WEBPACK_AMD_DEFINE_FACTORY__ = factory, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ ===
          'function' ?
              __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports,
                  __WEBPACK_AMD_DEFINE_ARRAY__) :
              __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
          (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {
        }
      })(function($, Inputmask) {
        if ($.fn.inputmask === undefined) {
          $.fn.inputmask = function(fn, options) {
            var nptmask, input = this[0];
            if (options === undefined) options = {};
            if (typeof fn === 'string') {
              switch (fn) {
                case 'unmaskedvalue':
                  return input && input.inputmask ?
                      input.inputmask.unmaskedvalue() :
                      $(input).val();

                case 'remove':
                  return this.each(function() {
                    if (this.inputmask) this.inputmask.remove();
                  });

                case 'getemptymask':
                  return input && input.inputmask ?
                      input.inputmask.getemptymask() :
                      '';

                case 'hasMaskedValue':
                  return input && input.inputmask ?
                      input.inputmask.hasMaskedValue() :
                      false;

                case 'isComplete':
                  return input && input.inputmask ?
                      input.inputmask.isComplete() :
                      true;

                case 'getmetadata':
                  return input && input.inputmask ?
                      input.inputmask.getmetadata() :
                      undefined;

                case 'setvalue':
                  Inputmask.setValue(input, options);
                  break;

                case 'option':
                  if (typeof options === 'string') {
                    if (input && input.inputmask !== undefined) {
                      return input.inputmask.option(options);
                    }
                  } else {
                    return this.each(function() {
                      if (this.inputmask !== undefined) {
                        return this.inputmask.option(options);
                      }
                    });
                  }
                  break;

                default:
                  options.alias = fn;
                  nptmask = new Inputmask(options);
                  return this.each(function() {
                    nptmask.mask(this);
                  });
              }
            } else if (Array.isArray(fn)) {
              options.alias = fn;
              nptmask = new Inputmask(options);
              return this.each(function() {
                nptmask.mask(this);
              });
            } else if ((typeof fn === 'undefined' ?
                'undefined' :
                _typeof(fn)) == 'object') {
              nptmask = new Inputmask(fn);
              if (fn.mask === undefined && fn.alias === undefined) {
                return this.each(function() {
                  if (this.inputmask !== undefined) {
                    return this.inputmask.option(fn);
                  } else nptmask.mask(this);
                });
              } else {
                return this.each(function() {
                  nptmask.mask(this);
                });
              }
            } else if (fn === undefined) {
              return this.each(function() {
                nptmask = new Inputmask(options);
                nptmask.mask(this);
              });
            }
          };
        }
        return $.fn.inputmask;
      });
    }]);
  /* ../../node_modules/inputmask/dist/jquery.inputmask.bundle.js end */

  provide($);
});

/* end: ../../5th.blocks/common.blocks/jquery/__inputmask/jquery__inputmask.js */
/* begin: ../../5th.blocks/common.blocks/show-modal/show-modal.js */
modules.define('show-modal', [
      'i-bem-dom',
      'show-modal__button',
      'show-modal__modal',
      'notification',
      'next-tick'],
    function(provide, bemDom, ShowModal__button, ShowModal__modal, Notification,
             nextTick) {

      provide(bemDom.declBlock(this.name, {
        onSetMod: {
          'js': {
            'inited': function() {
              this._modals = this.findChildElems(ShowModal__modal);
              this._buttons = this.findChildElems(ShowModal__button);
              this._notification = this.findMixedBlock(Notification);
              this._events(this._modals).
                  on({modName: 'visible', modVal: '*'},
                      this._onModalVisibleChange);
            },
          },
        },

        /**
         * Событие смены модификатора _visible у ShowModal__modal
         * @param {Object} e event
         * @param {Object} data event data
         * @param {String} data.modName
         * @param {Bool} data.modVal
         */
        _onModalVisibleChange: function(e, data) {
          !data.modVal && this._buttons.delMod('active', data.modVal);

          nextTick(function() {
            this._notification.switchScroll(this._modals.someHasMod('visible'));
          }.bind(this));
        },

        /**
         * Клик по кнопке
         * @param {Object} e event
         * @param {Object} params
         * @param {String} params[modal-id] id модального окна
         */
        _onButtonClick: function(e, params) {
          if (!params || !params['modal-id']) return;

          this._modals.forEach(function(modal) {
            modal.params['modal-id'] == params['modal-id'] ?
                modal.open(params) :
                modal.close();
          }, this);
        },
      }, {
        lazyInit: true,
        onInit: function() {
          this._events(ShowModal__button).
              on('click', this.prototype._onButtonClick);
          this._events(ShowModal__modal).
              on({modName: 'visible', modVal: '*'},
                  this.prototype._onModalVisibleChange);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/show-modal/show-modal.js */
/* begin: ../../5th.blocks/common.blocks/show-modal/__button/show-modal__button.js */
modules.define('show-modal__button', ['i-bem-dom', 'button', 'link', 'events'],
    function(provide, bemDom, Button, Link, events) {

      provide(bemDom.declElem('show-modal', 'button', {
        onSetMod: {
          'js': {
            'inited': function() {

            },
          },
        },

        _onButtonClick: function(e) {
          var event = new events.Event('click');
          this._emit(event, this.params);
        },

      }, {
        lazyInit: true,
        onInit: function() {
          this._events(Button).on('click', this.prototype._onButtonClick);
          this._events(Link).on('click', this.prototype._onButtonClick);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/show-modal/__button/show-modal__button.js */
/* begin: ../../node_modules/bem-components/common.blocks/link/link.js */
/**
 * @module link
 */

modules.define(
    'link',
    ['i-bem-dom', 'control', 'events'],
    function(provide, bemDom, Control, events) {

      /**
       * @exports
       * @class link
       * @augments control
       * @bem
       */
      provide(bemDom.declBlock(this.name, Control, /** @lends link.prototype */{
        onSetMod: {
          'js': {
            'inited': function() {
              this._url = this.params.url || this.domElem.attr('href');

              this.hasMod('disabled') && this.domElem.removeAttr('href');
            },
          },

          'disabled': {
            'true': function() {
              this.__base.apply(this, arguments);
              this.domElem.removeAttr('href').attr('aria-disabled', true);
            },

            '': function() {
              this.__base.apply(this, arguments);
              this.domElem.attr('href', this._url).removeAttr('aria-disabled');
            },
          },
        },

        /**
         * Returns url
         * @returns {String}
         */
        getUrl: function() {
          return this._url;
        },

        /**
         * Sets url
         * @param {String} url
         * @returns {link} this
         */
        setUrl: function(url) {
          this._url = url;
          this.hasMod('disabled') || this.domElem.attr('href', url);
          return this;
        },

        _onPointerClick: function(e) {
          if (this.hasMod('disabled')) {
            e.preventDefault();
          } else {
            var event = new events.Event('click');
            this._emit(event);
            event.isDefaultPrevented() && e.preventDefault();
          }
        },
      }, /** @lends link */{
        lazyInit: true,
        onInit: function() {
          this._domEvents('control').
              on('pointerclick', this.prototype._onPointerClick);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../node_modules/bem-components/common.blocks/link/link.js */
/* begin: ../../5th.blocks/common.blocks/show-modal/__modal/show-modal__modal.js */
modules.define('show-modal__modal', ['i-bem-dom', 'modal'],
    function(provide, bemDom, Modal) {

      provide(bemDom.declElem('show-modal', 'modal', {
        onSetMod: {
          'js': {
            'inited': function() {
              this._modal = this.findMixedBlock(Modal);
              this._events(this._modal).
                  on({modName: 'visible', modVal: '*'},
                      this._onModalVisibleChange);
            },
          },

          'visible': function(modName, modVal) {
            this.params.goals && (this._modal.params.goals = this.params.goals);
            this._modal.setMod(modName, modVal);
          },
        },

        /**
         * @param {Object} data params object
         */
        open: function(data) {
          this.setMod('visible', true);
          this._emit('open', data);
        },

        close: function() {
          this.delMod('visible');
        },

        _onModalVisibleChange: function(e, data) {
          this.setMod('visible', data.modVal);
        },
      }, {
        lazyInit: true,
        onInit: function() {
          this._events(Modal).
              on({modName: 'visible', modVal: '*'},
                  this.prototype._onModalVisibleChange);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/show-modal/__modal/show-modal__modal.js */
/* begin: ../../5th.blocks/common.blocks/scroll/scroll.js */
modules.define('scroll', ['i-bem-dom', 'jquery', 'scroll__link', 'maniac'],
    function(provide, bemDom, $, Scroll__Link, Maniac) {

      provide(bemDom.declBlock(this.name, {
        onSetMod: {
          'js': {
            'inited': function() {
              this._maniac = this.findChildBlock(Maniac);
            },
          },
        },

        /**
         * @param {Object} e bem event
         * @param {String} elem dom selector
         */
        _onLinkClick: function(e, elem) {
          elem && this.scrollTo(elem);
        },

        /**
         * @param {String} elem dom selector
         */
        scrollTo: function(elem) {
          var $elem = $(elem),
              maniac = this._maniac;

          if (!$elem.length) return;

          $('html, body').animate({
            scrollTop: $elem.offset().top - (
                maniac && !maniac.hasMod('crutch', 'disable') ?
                    maniac.getHeight() : 0
            ),
          }, 500);
        },
      }, {
        lazyInit: true,
        onInit: function() {
          this._events(Scroll__Link).on('click', this.prototype._onLinkClick);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/scroll/scroll.js */
/* begin: ../../5th.blocks/common.blocks/scroll/__link/scroll__link.js */
modules.define('scroll__link', ['i-bem-dom', 'link', 'button'],
    function(provide, bemDom, Link, Button) {

      provide(bemDom.declElem('scroll', 'link', {
        onSetMod: {
          'js': {
            'inited': function() {

            },
          },
        },

        _onControlClick: function(e) {
          var elem = this.params.elem;

          elem && this._emit('click', elem);
        },
      }, {
        lazyInit: true,
        onInit: function() {
          var ptp = this.prototype;

          this._events(Link).on('click', ptp._onControlClick);
          this._events(Button).on('click', ptp._onControlClick);

          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/scroll/__link/scroll__link.js */
/* begin: ../../5th.blocks/common.blocks/maniac/maniac.js */
modules.define('maniac', ['i-bem-dom', 'jquery'], function(provide, bemDom, $) {
  provide(bemDom.declBlock(this.name, {

    beforeSetMod: {
      'active': {
        '': function() {
          // check needs then _active_manual del, for example see mobile-menu
          if (this._needsActivation()) return false;
        },
      },
    },

    onSetMod: {
      'active': function() {
        this._changeCrutchHeight();
      },

      'js': {
        'inited': function() {
          this._offset = this.domElem.offset();
          this._crutch = this.findChildElem('crutch');
          this._content = this.findChildElem('content');
          this._height = 0;
          this._winScrollTop = bemDom.win.scrollTop();

          this._calcContentHeight();
          this._toggle();

          this._domEvents(bemDom.win).on('scroll', this._onWinScroll);
          this._domEvents(bemDom.win).on('resize', this._onWinResize);
        },
      },
    },

    _changeCrutchHeight: function() {
      this._crutch.domElem.css('height',
          this.hasMod('active') ? this._height : '');
    },

    /**
     * Проверка нужно ли работать
     * @returns {Bool}
     */
    _needsActivation: function() {
      return this._winScrollTop >= this._offset.top;
    },

    _onWinScroll: function() {
      this._winScrollTop = bemDom.win.scrollTop();
      this._toggle();
    },

    _onWinResize: function() {
      this._calcContentHeight();
      this._changeCrutchHeight();
    },

    _calcContentHeight: function() {
      this._height = this._content.domElem.outerHeight();
    },

    /**
     * @return {Number} content height
     */
    getHeight: function() {
      return this._height;
    },

    /**
     * Toggle mod `active`
     */
    _toggle: function() {
      this.setMod('active', this._needsActivation());
    },
  }));
});

/* end: ../../5th.blocks/common.blocks/maniac/maniac.js */
/* begin: ../../5th.blocks/common.blocks/header/header.js */
modules.define('header', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declBlock(this.name, {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },

  }, {
    lazyInit: true,
  }));

});

/* end: ../../5th.blocks/common.blocks/header/header.js */
/* begin: ../../5th.blocks/common.blocks/nav/nav.js */
modules.define('nav', ['i-bem-dom', 'nav__item'],
    function(provide, bemDom, Nav__Item) {
      provide(bemDom.declBlock(this.name, {

        onSetMod: {
          'js': {
            'inited': function() {
              this._itemsHasSubNav = this.findChildElems(
                  {elem: Nav__Item, modName: 'has-subnav', modVal: true});

              this._existActiveItemHasSubNav();

              this._events(this._itemsHasSubNav).
                  on('click', this._onItemHasSubNavClick);
            },
          },
        },

        hasOpenSubnav: function() {
          return this._itemsHasSubNav.someHasMod('active');
        },

        _onItemHasSubNavClick: function(e) {
          var bemTarget = e.bemTarget;

          if (bemTarget.hasMod('active'))
            bemTarget.delMod('active');
          else
            this._changeActiveItemHasSubNav(bemTarget);
        },

        /**
         * @param {BemEntity} navItemHasSubNav
         */
        _changeActiveItemHasSubNav: function(navItemHasSubNav) {
          this._itemsHasSubNav.forEach(function(item) {
            item.setMod('active', item == navItemHasSubNav);
          }, this);

        },

        _existActiveItemHasSubNav: function() {
          var active = this._itemsHasSubNav.some(function(item) {
            return item.hasMod('active');
          }, this);

          this.setMod('opened', active);
        },
      }));
    });

/* end: ../../5th.blocks/common.blocks/nav/nav.js */
/* begin: ../../5th.blocks/common.blocks/nav/__list/nav__list.js */
modules.define('nav__list', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declElem('nav', 'list', {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },
  }, {
    lazyInit: true,
  }));

});

/* end: ../../5th.blocks/common.blocks/nav/__list/nav__list.js */
/* begin: ../../node_modules/bem-components/common.blocks/link/_pseudo/link_pseudo.js */
/**
 * @module link
 */

modules.define('link', ['keyboard__codes'], function(provide, keyCodes, Link) {

  /**
   * @exports
   * @class link
   * @bem
   */
  provide(Link.declMod({modName: 'pseudo', modVal: true},
      /** @lends link.prototype */{
        onSetMod: {
          'focused': {
            'true': function() {
              this.__base.apply(this, arguments);

              this._domEvents('control').on('keydown', this._onKeyDown);
            },
            '': function() {
              this.__base.apply(this, arguments);

              this._domEvents('control').un('keydown', this._onKeyDown);
            },
          },
        },

        _onPointerClick: function(e) {
          e.preventDefault();

          this.__base.apply(this, arguments);
        },

        _onKeyDown: function(e) {
          e.keyCode === keyCodes.ENTER && this._onPointerClick(e);
        },
      }));

});

/* end: ../../node_modules/bem-components/common.blocks/link/_pseudo/link_pseudo.js */
/* begin: ../../5th.blocks/common.blocks/nav/__item/nav__item.js */
modules.define('nav__item', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declElem('nav', 'item', {
    onSetMod: {
      'hovered': {
        'true': function() {
          this._domEvents().on('mouseleave', this._onMouseLeave);
        },

        '': function() {
          this._domEvents().un('mouseleave', this._onMouseLeave);
        },
      },
    },

    _onMouseEnter: function(e) {
      this.setMod('hovered');
    },

    _onMouseLeave: function(e) {
      this.delMod('hovered');
    },

  }, {
    lazyInit: true,
    onInit: function() {
      this._domEvents().on('mouseenter', this.prototype._onMouseEnter);
      return this.__base.apply(this, arguments);
    },
  }));

});

/* end: ../../5th.blocks/common.blocks/nav/__item/nav__item.js */
/* begin: ../../5th.blocks/common.blocks/nav/__item/_has-subnav/nav__item_has-subnav.js */
modules.define('nav__item', ['i-bem-dom', 'nav__list', 'link'],
    function(provide, bemDom, Nav__list, Link, Nav__item) {

      provide(Nav__item.declMod({modName: 'has-subnav', modVal: true}, {
        onSetMod: {
          'js': {
            'inited': function() {
              this.__base.apply(this, arguments);

              this._link = this.findChildBlock(Link);

              this._events(this._link).on('click', this._onLinkClick);
            },
          },
        },

        _onLinkClick: function(e) {
          this._emit(e.type);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/nav/__item/_has-subnav/nav__item_has-subnav.js */
/* begin: ../../5th.blocks/common.blocks/popup-menu/popup-menu.js */
modules.define('popup-menu',
    ['i-bem-dom', 'popup-menu__switch', 'notification'],
    function(provide, bemDom, PopupMenu__switch, Notification) {

      provide(bemDom.declBlock(this.name, {
        onSetMod: {
          'js': {
            'inited': function() {
              this._notification = this.findParentBlock(Notification);
              this._domEvents(bemDom.win).
                  on('resize', this._notificationSwitchScroll);
            },
          },

          'active': function(modName, modVal, oldModVal) {
            this._elems(PopupMenu__switch).setMod('opened', modVal);
            this._notificationSwitchScroll();
          },
        },

        _onSwitchClick: function(e) {
          this.toggleMod('active');
        },

        _notificationSwitchScroll: function() {
          this._notification.switchScroll(this.params.notification >=
              window.innerWidth && this.hasMod('active'));
        },
      }, {
        lazyInit: true,
        onInit: function() {
          this._events(PopupMenu__switch).
              on('click', this.prototype._onSwitchClick);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/popup-menu/popup-menu.js */
/* begin: ../../5th.blocks/common.blocks/popup-menu/__switch/popup-menu__switch.js */
modules.define('popup-menu__switch', ['i-bem-dom', 'link', 'button'],
    function(provide, bemDom, Link, Button) {

      provide(bemDom.declElem('popup-menu', 'switch', {
        onSetMod: {
          'js': {
            'inited': function() {

            },
          },
        },

        _onControlClick: function(e) {
          this._emit(e.type);
        },
      }, {
        lazyInit: true,
        onInit: function() {
          var ptp = this.prototype;

          this._events(Link).on('click', ptp._onControlClick);
          this._events(Button).on('click', ptp._onControlClick);

          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/popup-menu/__switch/popup-menu__switch.js */
/* begin: ../../5th.blocks/common.blocks/content/content.js */
modules.define('content', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declBlock(this.name, {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },
  }, {
    lazyInit: true,
  }));

});

/* end: ../../5th.blocks/common.blocks/content/content.js */
/* begin: ../../common.blocks/calc/calc.js */
modules.define('calc',
    ['i-bem-dom', 'calc__value', 'calc__section', 'calc__get', 'range-slider'],
    function
        (provide, bemDom, Calc__Value, Calc__Section, Calc__Get, RangeSlider) {

      function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }

      provide(bemDom.declBlock(this.name, {
        onSetMod: {
          'js': {
            'inited': function() {
              this._values = {sum: 0, time: 0, rate: this.params.rate || 1.5};
              this._rangeSliders = this.findChildBlocks(RangeSlider);
              this._getRangeValues();
            },
          },
        },

        /**
         * @param {Array|String} values
         * @return {Number}
         */
        _formatRangeSliderValue: function(values) {
          return parseFloat(Array.isArray(values) ? values[0] : values);
        },

        _getRangeValues: function() {
          this._rangeSliders.forEach(function(rangeSlider) {
            this._values[rangeSlider.params.name] = this._formatRangeSliderValue(
                rangeSlider.getVal());
          }, this);
        },

        /**
         * @param {Object} e bem event
         * @param {Object} data
         * @param {String} data.name
         * @param {Array} data.values
         */
        _rangeSliderUpd: function(e, data) {
          var name = data.name,
              value = this._formatRangeSliderValue(data.values),
              getBtn = this._elem(Calc__Get),
              valueFormat = new Intl.NumberFormat('ru-RU').format(value),
              date = e.bemTarget.params.date;

          var valueElems = (this._elems(Calc__Value) || []).filter(
              function(val) {
                return val.hasMod('name', name);
              }, this);

          (valueElems || []).forEach(function(valueEl) {
            valueEl.setContent(valueFormat);
          }, this);

          this._values[name] = value;

          date && (this._values.date = date);

          var invalid = !this._isValid(name);

          [
            this._elem({
              elem: Calc__Section,
              modName: 'name',
              modVal: name,
            }),
            e.bemTarget,
          ].forEach(function(item) {
            item.setMod('invalid', invalid);
          }, this);

          getBtn && getBtn.setMod('disabled', invalid);

          this._calculation();
        },

        /**
         * @param {String} name
         */
        _isValid: function(name) {
          var max = this.params.max;
          if (!max || !max[name]) return true;
          return this._values[name] <= max[name];
        },

        _calculation: function() {
          var values = this._values,
              sum = values.sum,
              time = values.time,
              total = Math.ceil(sum + sum / 100 * values.rate * time),
              date = new Date(),
              dateType = capitalizeFirstLetter(values.date || 'date');
          totalElem = this._elem(
              {elem: Calc__Value, modName: 'name', modVal: 'total'}),
              dateElem = this._elem(
                  {elem: Calc__Value, modName: 'name', modVal: 'date'});
          monthly = this._elem(
              {elem: Calc__Value, modName: 'name', modVal: 'monthly'});

          date = new Date(
              date['set' + dateType](date['get' + dateType]() + time));

          totalElem &&
          totalElem.setContent(new Intl.NumberFormat('ru-RU').format(total));

          dateElem &&
          dateElem.setContent(
              (date.getDate() < 10 ? '0' + date.getDate() : date.getDate())
              + '.' +
              ((date.getMonth() + 1) < 10 ?
                  '0' + (date.getMonth() + 1) :
                  date.getMonth() + 1)
              + '.' +
              date.getFullYear(),
          );

          monthly && dateType.toLowerCase() == 'month' &&
          monthly.setContent(
              new Intl.NumberFormat('ru-RU').format(Math.ceil(total / time)));
        },
      }, {
        lazyInit: true,
        onInit: function() {
          this._events(RangeSlider).
              on('update', this.prototype._rangeSliderUpd);

          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../common.blocks/calc/calc.js */
/* begin: ../../common.blocks/calc/__value/calc__value.js */
modules.define('calc__value', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declElem('calc', 'value', {
    onSetMod: {
      'js': {
        'inited': function() {
          this._domElem = this.domElem[0];
        },
      },
    },

    /**
     * @param {String} text
     */
    setContent: function(text) {
      this._domElem.textContent = text;
    },
  }, {
    lazyInit: true,
  }));

});

/* end: ../../common.blocks/calc/__value/calc__value.js */
/* begin: ../../common.blocks/calc/__section/calc__section.js */
modules.define('calc__section', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declElem('calc', 'section', {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },
  }, {
    lazyInit: true,
  }));

});

/* end: ../../common.blocks/calc/__section/calc__section.js */
/* begin: ../../common.blocks/calc/__get/calc__get.js */
modules.define('calc__get', ['i-bem-dom', 'button'],
    function(provide, bemDom, Button) {

      provide(bemDom.declElem('calc', 'get', {
        onSetMod: {
          'js': {
            'inited': function() {
              this._button = this.findMixedBlock(Button);
            },
          },

          'disabled': function(modName, modVal, oldModVal) {
            this._button.setMod(modName, modVal);
          },
        },

        _onButtonClick: function(e) {
          this._emit(e.type);
        },
      }, {
        lazyInit: true,
        onInit: function() {
          this._events(Button).on('click', this.prototype._onButtonClick);

          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../common.blocks/calc/__get/calc__get.js */
/* begin: ../../5th.blocks/common.blocks/range-slider/range-slider.js */
modules.define('range-slider',
    ['i-bem-dom', 'range-slider__container', 'nouislider', 'wnumb'],
    function(provide, bemDom, RangeSlider__Container, noUiSlider, wNumb) {

      /* ../../5th.blocks/common.blocks/polyfill/__isinteger/polyfill__isinteger.js begin */
      Number.isInteger = Number.isInteger || function(value) {
        return typeof value === 'number' &&
            isFinite(value) &&
            Math.floor(value) === value;
      };

      /* ../../5th.blocks/common.blocks/polyfill/__isinteger/polyfill__isinteger.js end */

      provide(bemDom.declBlock(this.name, {
        onSetMod: {
          'js': {
            'inited': function() {
              this._container = this.findChildElem(RangeSlider__Container);
              this._init();
            },
          },
        },

        /**
         * @see https://refreshless.com/nouislider/slider-read-write/#section-reading
         */
        getVal: function() {
          return this._noUiSlider.noUiSlider.get();
        },

        _init: function() {
          this._noUiSlider = this._container ?
              this._container.domElem[0] :
              this.domElem[0];

          var options = this.params.options,
              tooltips = this.params.tooltips;

          if (options.tooltips && tooltips &&
              Number.isInteger(tooltips.decimals)) {
            options.tooltips = wNumb({decimals: tooltips.decimals});
          }

          noUiSlider.create(this._noUiSlider, this.params.options);

          /**
           * @see https://refreshless.com/nouislider/events-callbacks/#section-binding
           */
          this._noUiSlider.noUiSlider.on('update',
              this._onNoUiSliderUpdate.bind(this));
        },

        /**
         * @see https://refreshless.com/nouislider/events-callbacks/#section-binding
         */
        _onNoUiSliderUpdate: function(
            values, handle, unencoded, tap, positions) {
          this._emit('update', {name: this.params.name, values: values});
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/range-slider/range-slider.js */
/* begin: ../../5th.blocks/common.blocks/range-slider/__container/range-slider__container.js */
modules.define('range-slider__container', ['i-bem-dom'],
    function(provide, bemDom) {

      provide(bemDom.declElem('range-slider', 'container', {
        onSetMod: {
          'js': {
            'inited': function() {

            },
          },
        },
      }, {
        lazyInit: true,
      }));

    });

/* end: ../../5th.blocks/common.blocks/range-slider/__container/range-slider__container.js */
/* begin: ../../5th.blocks/common.blocks/nouislider/nouislider.js */
modules.define('nouislider', function(provide) {

  /* ../../node_modules/nouislider/distribute/nouislider.js begin */
  /*! nouislider - 12.0.0 - 9/14/2018 */
  (function(factory) {
    if (typeof define === 'function' && define.amd) {
      // AMD. Register as an anonymous module.
      define([], factory);
    } else if (typeof exports === 'object') {
      // Node/CommonJS
      module.exports = factory();
    } else {
      // Browser globals
      window.noUiSlider = factory();
    }
  })(function() {
    'use strict';

    var VERSION = '12.0.0';

    function isValidFormatter(entry) {
      return typeof entry === 'object' && typeof entry.to === 'function' &&
          typeof entry.from === 'function';
    }

    function removeElement(el) {
      el.parentElement.removeChild(el);
    }

    function isSet(value) {
      return value !== null && value !== undefined;
    }

    // Bindable version
    function preventDefault(e) {
      e.preventDefault();
    }

    // Removes duplicates from an array.
    function unique(array) {
      return array.filter(function(a) {
        return !this[a] ? (this[a] = true) : false;
      }, {});
    }

    // Round a value to the closest 'to'.
    function closest(value, to) {
      return Math.round(value / to) * to;
    }

    // Current position of an element relative to the document.
    function offset(elem, orientation) {
      var rect = elem.getBoundingClientRect();
      var doc = elem.ownerDocument;
      var docElem = doc.documentElement;
      var pageOffset = getPageOffset(doc);

      // getBoundingClientRect contains left scroll in Chrome on Android.
      // I haven't found a feature detection that proves this. Worst case
      // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.
      if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {
        pageOffset.x = 0;
      }

      return orientation
          ? rect.top + pageOffset.y - docElem.clientTop
          : rect.left + pageOffset.x - docElem.clientLeft;
    }

    // Checks whether a value is numerical.
    function isNumeric(a) {
      return typeof a === 'number' && !isNaN(a) && isFinite(a);
    }

    // Sets a class and removes it after [duration] ms.
    function addClassFor(element, className, duration) {
      if (duration > 0) {
        addClass(element, className);
        setTimeout(function() {
          removeClass(element, className);
        }, duration);
      }
    }

    // Limits a value to 0 - 100
    function limit(a) {
      return Math.max(Math.min(a, 100), 0);
    }

    // Wraps a variable as an array, if it isn't one yet.
    // Note that an input array is returned by reference!
    function asArray(a) {
      return Array.isArray(a) ? a : [a];
    }

    // Counts decimals
    function countDecimals(numStr) {
      numStr = String(numStr);
      var pieces = numStr.split('.');
      return pieces.length > 1 ? pieces[1].length : 0;
    }

    // http://youmightnotneedjquery.com/#add_class
    function addClass(el, className) {
      if (el.classList) {
        el.classList.add(className);
      } else {
        el.className += ' ' + className;
      }
    }

    // http://youmightnotneedjquery.com/#remove_class
    function removeClass(el, className) {
      if (el.classList) {
        el.classList.remove(className);
      } else {
        el.className = el.className.replace(
            new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)',
                'gi'),
            ' ',
        );
      }
    }

    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/
    function hasClass(el, className) {
      return el.classList
          ? el.classList.contains(className)
          : new RegExp('\\b' + className + '\\b').test(el.className);
    }

    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes
    function getPageOffset(doc) {
      var supportPageOffset = window.pageXOffset !== undefined;
      var isCSS1Compat = (doc.compatMode || '') === 'CSS1Compat';
      var x = supportPageOffset
          ? window.pageXOffset
          : isCSS1Compat
              ? doc.documentElement.scrollLeft
              : doc.body.scrollLeft;
      var y = supportPageOffset
          ? window.pageYOffset
          : isCSS1Compat
              ? doc.documentElement.scrollTop
              : doc.body.scrollTop;

      return {
        x: x,
        y: y,
      };
    }

    // we provide a function to compute constants instead
    // of accessing window.* as soon as the module needs it
    // so that we do not compute anything if not needed
    function getActions() {
      // Determine the events to bind. IE11 implements pointerEvents without
      // a prefix, which breaks compatibility with the IE10 implementation.
      return window.navigator.pointerEnabled
          ? {
            start: 'pointerdown',
            move: 'pointermove',
            end: 'pointerup',
          }
          : window.navigator.msPointerEnabled
              ? {
                start: 'MSPointerDown',
                move: 'MSPointerMove',
                end: 'MSPointerUp',
              }
              : {
                start: 'mousedown touchstart',
                move: 'mousemove touchmove',
                end: 'mouseup touchend',
              };
    }

    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
    // Issue #785
    function getSupportsPassive() {
      var supportsPassive = false;

      /* eslint-disable */
      try {
        var opts = Object.defineProperty({}, 'passive', {
          get: function() {
            supportsPassive = true;
          },
        });

        window.addEventListener('test', null, opts);
      } catch (e) {
      }
      /* eslint-enable */

      return supportsPassive;
    }

    function getSupportsTouchActionNone() {
      return window.CSS && CSS.supports && CSS.supports('touch-action', 'none');
    }

    // Value calculation

    // Determine the size of a sub-range in relation to a full range.
    function subRangeRatio(pa, pb) {
      return 100 / (pb - pa);
    }

    // (percentage) How many percent is this value of this range?
    function fromPercentage(range, value) {
      return (value * 100) / (range[1] - range[0]);
    }

    // (percentage) Where is this value on this range?
    function toPercentage(range, value) {
      return fromPercentage(range,
          range[0] < 0 ? value + Math.abs(range[0]) : value - range[0]);
    }

    // (value) How much is this percentage on this range?
    function isPercentage(range, value) {
      return (value * (range[1] - range[0])) / 100 + range[0];
    }

    // Range conversion

    function getJ(value, arr) {
      var j = 1;

      while (value >= arr[j]) {
        j += 1;
      }

      return j;
    }

    // (percentage) Input a value, find where, on a scale of 0-100, it applies.
    function toStepping(xVal, xPct, value) {
      if (value >= xVal.slice(-1)[0]) {
        return 100;
      }

      var j = getJ(value, xVal);
      var va = xVal[j - 1];
      var vb = xVal[j];
      var pa = xPct[j - 1];
      var pb = xPct[j];

      return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);
    }

    // (value) Input a percentage, find where it is on the specified range.
    function fromStepping(xVal, xPct, value) {
      // There is no range group that fits 100
      if (value >= 100) {
        return xVal.slice(-1)[0];
      }

      var j = getJ(value, xPct);
      var va = xVal[j - 1];
      var vb = xVal[j];
      var pa = xPct[j - 1];
      var pb = xPct[j];

      return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));
    }

    // (percentage) Get the step that applies at a certain value.
    function getStep(xPct, xSteps, snap, value) {
      if (value === 100) {
        return value;
      }

      var j = getJ(value, xPct);
      var a = xPct[j - 1];
      var b = xPct[j];

      // If 'snap' is set, steps are used as fixed points on the slider.
      if (snap) {
        // Find the closest position, a or b.
        if (value - a > (b - a) / 2) {
          return b;
        }

        return a;
      }

      if (!xSteps[j - 1]) {
        return value;
      }

      return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);
    }

    // Entry parsing

    function handleEntryPoint(index, value, that) {
      var percentage;

      // Wrap numerical input in an array.
      if (typeof value === 'number') {
        value = [value];
      }

      // Reject any invalid input, by testing whether value is an array.
      if (!Array.isArray(value)) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'range\' contains invalid value.');
      }

      // Covert min/max syntax to 0 and 100.
      if (index === 'min') {
        percentage = 0;
      } else if (index === 'max') {
        percentage = 100;
      } else {
        percentage = parseFloat(index);
      }

      // Check for correct input.
      if (!isNumeric(percentage) || !isNumeric(value[0])) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'range\' value isn\'t numeric.');
      }

      // Store values.
      that.xPct.push(percentage);
      that.xVal.push(value[0]);

      // NaN will evaluate to false too, but to keep
      // logging clear, set step explicitly. Make sure
      // not to override the 'step' setting with false.
      if (!percentage) {
        if (!isNaN(value[1])) {
          that.xSteps[0] = value[1];
        }
      } else {
        that.xSteps.push(isNaN(value[1]) ? false : value[1]);
      }

      that.xHighestCompleteStep.push(0);
    }

    function handleStepPoint(i, n, that) {
      // Ignore 'false' stepping.
      if (!n) {
        return true;
      }

      // Factor to range ratio
      that.xSteps[i] =
          fromPercentage([that.xVal[i], that.xVal[i + 1]], n) /
          subRangeRatio(that.xPct[i], that.xPct[i + 1]);

      var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];
      var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
      var step = that.xVal[i] + that.xNumSteps[i] * highestStep;

      that.xHighestCompleteStep[i] = step;
    }

    // Interface

    function Spectrum(entry, snap, singleStep) {
      this.xPct = [];
      this.xVal = [];
      this.xSteps = [singleStep || false];
      this.xNumSteps = [false];
      this.xHighestCompleteStep = [];

      this.snap = snap;

      var index;
      var ordered = []; // [0, 'min'], [1, '50%'], [2, 'max']

      // Map the object keys to an array.
      for (index in entry) {
        if (entry.hasOwnProperty(index)) {
          ordered.push([entry[index], index]);
        }
      }

      // Sort all entries by value (numeric sort).
      if (ordered.length && typeof ordered[0][0] === 'object') {
        ordered.sort(function(a, b) {
          return a[0][0] - b[0][0];
        });
      } else {
        ordered.sort(function(a, b) {
          return a[0] - b[0];
        });
      }

      // Convert all entries to subranges.
      for (index = 0; index < ordered.length; index++) {
        handleEntryPoint(ordered[index][1], ordered[index][0], this);
      }

      // Store the actual step values.
      // xSteps is sorted in the same order as xPct and xVal.
      this.xNumSteps = this.xSteps.slice(0);

      // Convert all numeric steps to the percentage of the subrange they represent.
      for (index = 0; index < this.xNumSteps.length; index++) {
        handleStepPoint(index, this.xNumSteps[index], this);
      }
    }

    Spectrum.prototype.getMargin = function(value) {
      var step = this.xNumSteps[0];

      if (step && (value / step) % 1 !== 0) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'limit\', \'margin\' and \'padding\' must be divisible by step.');
      }

      return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;
    };

    Spectrum.prototype.toStepping = function(value) {
      value = toStepping(this.xVal, this.xPct, value);

      return value;
    };

    Spectrum.prototype.fromStepping = function(value) {
      return fromStepping(this.xVal, this.xPct, value);
    };

    Spectrum.prototype.getStep = function(value) {
      value = getStep(this.xPct, this.xSteps, this.snap, value);

      return value;
    };

    Spectrum.prototype.getNearbySteps = function(value) {
      var j = getJ(value, this.xPct);

      return {
        stepBefore: {
          startValue: this.xVal[j - 2],
          step: this.xNumSteps[j - 2],
          highestStep: this.xHighestCompleteStep[j - 2],
        },
        thisStep: {
          startValue: this.xVal[j - 1],
          step: this.xNumSteps[j - 1],
          highestStep: this.xHighestCompleteStep[j - 1],
        },
        stepAfter: {
          startValue: this.xVal[j],
          step: this.xNumSteps[j],
          highestStep: this.xHighestCompleteStep[j],
        },
      };
    };

    Spectrum.prototype.countStepDecimals = function() {
      var stepDecimals = this.xNumSteps.map(countDecimals);
      return Math.max.apply(null, stepDecimals);
    };

    // Outside testing
    Spectrum.prototype.convert = function(value) {
      return this.getStep(this.toStepping(value));
    };

    /*	Every input option is tested and parsed. This'll prevent
        endless validation in internal methods. These tests are
        structured with an item for every option available. An
        option can be marked as required by setting the 'r' flag.
        The testing function is provided with three arguments:
            - The provided value for the option;
            - A reference to the options object;
            - The name for the option;

        The testing function returns false when an error is detected,
        or true when everything is OK. It can also modify the option
        object, to make sure all values can be correctly looped elsewhere. */

    var defaultFormatter = {
      to: function(value) {
        return value !== undefined && value.toFixed(2);
      },
      from: Number,
    };

    function validateFormat(entry) {
      // Any object with a to and from method is supported.
      if (isValidFormatter(entry)) {
        return true;
      }

      throw new Error('noUiSlider (' + VERSION +
          '): \'format\' requires \'to\' and \'from\' methods.');
    }

    function testStep(parsed, entry) {
      if (!isNumeric(entry)) {
        throw new Error('noUiSlider (' + VERSION + '): \'step\' is not numeric.');
      }

      // The step option can still be used to set stepping
      // for linear sliders. Overwritten if set in 'range'.
      parsed.singleStep = entry;
    }

    function testRange(parsed, entry) {
      // Filter incorrect input.
      if (typeof entry !== 'object' || Array.isArray(entry)) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'range\' is not an object.');
      }

      // Catch missing start or end.
      if (entry.min === undefined || entry.max === undefined) {
        throw new Error('noUiSlider (' + VERSION +
            '): Missing \'min\' or \'max\' in \'range\'.');
      }

      // Catch equal start or end.
      if (entry.min === entry.max) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'range\' \'min\' and \'max\' cannot be equal.');
      }

      parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);
    }

    function testStart(parsed, entry) {
      entry = asArray(entry);

      // Validate input. Values aren't tested, as the public .val method
      // will always provide a valid location.
      if (!Array.isArray(entry) || !entry.length) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'start\' option is incorrect.');
      }

      // Store the number of handles.
      parsed.handles = entry.length;

      // When the slider is initialized, the .val method will
      // be called with the start options.
      parsed.start = entry;
    }

    function testSnap(parsed, entry) {
      // Enforce 100% stepping within subranges.
      parsed.snap = entry;

      if (typeof entry !== 'boolean') {
        throw new Error('noUiSlider (' + VERSION +
            '): \'snap\' option must be a boolean.');
      }
    }

    function testAnimate(parsed, entry) {
      // Enforce 100% stepping within subranges.
      parsed.animate = entry;

      if (typeof entry !== 'boolean') {
        throw new Error('noUiSlider (' + VERSION +
            '): \'animate\' option must be a boolean.');
      }
    }

    function testAnimationDuration(parsed, entry) {
      parsed.animationDuration = entry;

      if (typeof entry !== 'number') {
        throw new Error('noUiSlider (' + VERSION +
            '): \'animationDuration\' option must be a number.');
      }
    }

    function testConnect(parsed, entry) {
      var connect = [false];
      var i;

      // Map legacy options
      if (entry === 'lower') {
        entry = [true, false];
      } else if (entry === 'upper') {
        entry = [false, true];
      }

      // Handle boolean options
      if (entry === true || entry === false) {
        for (i = 1; i < parsed.handles; i++) {
          connect.push(entry);
        }

        connect.push(false);
      }

      // Reject invalid input
      else if (!Array.isArray(entry) || !entry.length || entry.length !==
          parsed.handles + 1) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'connect\' option doesn\'t match handle count.');
      } else {
        connect = entry;
      }

      parsed.connect = connect;
    }

    function testOrientation(parsed, entry) {
      // Set orientation to an a numerical value for easy
      // array selection.
      switch (entry) {
        case 'horizontal':
          parsed.ort = 0;
          break;
        case 'vertical':
          parsed.ort = 1;
          break;
        default:
          throw new Error('noUiSlider (' + VERSION +
              '): \'orientation\' option is invalid.');
      }
    }

    function testMargin(parsed, entry) {
      if (!isNumeric(entry)) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'margin\' option must be numeric.');
      }

      // Issue #582
      if (entry === 0) {
        return;
      }

      parsed.margin = parsed.spectrum.getMargin(entry);

      if (!parsed.margin) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'margin\' option is only supported on linear sliders.');
      }
    }

    function testLimit(parsed, entry) {
      if (!isNumeric(entry)) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'limit\' option must be numeric.');
      }

      parsed.limit = parsed.spectrum.getMargin(entry);

      if (!parsed.limit || parsed.handles < 2) {
        throw new Error(
            'noUiSlider (' +
            VERSION +
            '): \'limit\' option is only supported on linear sliders with 2 or more handles.',
        );
      }
    }

    function testPadding(parsed, entry) {
      if (!isNumeric(entry) && !Array.isArray(entry)) {
        throw new Error(
            'noUiSlider (' + VERSION +
            '): \'padding\' option must be numeric or array of exactly 2 numbers.',
        );
      }

      if (Array.isArray(entry) &&
          !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {
        throw new Error(
            'noUiSlider (' + VERSION +
            '): \'padding\' option must be numeric or array of exactly 2 numbers.',
        );
      }

      if (entry === 0) {
        return;
      }

      if (!Array.isArray(entry)) {
        entry = [entry, entry];
      }

      // 'getMargin' returns false for invalid values.
      parsed.padding = [
        parsed.spectrum.getMargin(entry[0]),
        parsed.spectrum.getMargin(entry[1])];

      if (parsed.padding[0] === false || parsed.padding[1] === false) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'padding\' option is only supported on linear sliders.');
      }

      if (parsed.padding[0] < 0 || parsed.padding[1] < 0) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'padding\' option must be a positive number(s).');
      }

      if (parsed.padding[0] + parsed.padding[1] >= 100) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'padding\' option must not exceed 100% of the range.');
      }
    }

    function testDirection(parsed, entry) {
      // Set direction as a numerical value for easy parsing.
      // Invert connection for RTL sliders, so that the proper
      // handles get the connect/background classes.
      switch (entry) {
        case 'ltr':
          parsed.dir = 0;
          break;
        case 'rtl':
          parsed.dir = 1;
          break;
        default:
          throw new Error('noUiSlider (' + VERSION +
              '): \'direction\' option was not recognized.');
      }
    }

    function testBehaviour(parsed, entry) {
      // Make sure the input is a string.
      if (typeof entry !== 'string') {
        throw new Error('noUiSlider (' + VERSION +
            '): \'behaviour\' must be a string containing options.');
      }

      // Check if the string contains any keywords.
      // None are required.
      var tap = entry.indexOf('tap') >= 0;
      var drag = entry.indexOf('drag') >= 0;
      var fixed = entry.indexOf('fixed') >= 0;
      var snap = entry.indexOf('snap') >= 0;
      var hover = entry.indexOf('hover') >= 0;

      if (fixed) {
        if (parsed.handles !== 2) {
          throw new Error('noUiSlider (' + VERSION +
              '): \'fixed\' behaviour must be used with 2 handles');
        }

        // Use margin to enforce fixed state
        testMargin(parsed, parsed.start[1] - parsed.start[0]);
      }

      parsed.events = {
        tap: tap || snap,
        drag: drag,
        fixed: fixed,
        snap: snap,
        hover: hover,
      };
    }

    function testTooltips(parsed, entry) {
      if (entry === false) {
        return;
      }

      if (entry === true) {
        parsed.tooltips = [];

        for (var i = 0; i < parsed.handles; i++) {
          parsed.tooltips.push(true);
        }
      } else {
        parsed.tooltips = asArray(entry);

        if (parsed.tooltips.length !== parsed.handles) {
          throw new Error('noUiSlider (' + VERSION +
              '): must pass a formatter for all handles.');
        }

        parsed.tooltips.forEach(function(formatter) {
          if (
              typeof formatter !== 'boolean' &&
              (typeof formatter !== 'object' || typeof formatter.to !==
                  'function')
          ) {
            throw new Error('noUiSlider (' + VERSION +
                '): \'tooltips\' must be passed a formatter or \'false\'.');
          }
        });
      }
    }

    function testAriaFormat(parsed, entry) {
      parsed.ariaFormat = entry;
      validateFormat(entry);
    }

    function testFormat(parsed, entry) {
      parsed.format = entry;
      validateFormat(entry);
    }

    function testKeyboardSupport(parsed, entry) {
      parsed.keyboardSupport = entry;

      if (typeof entry !== 'boolean') {
        throw new Error('noUiSlider (' + VERSION +
            '): \'keyboardSupport\' option must be a boolean.');
      }
    }

    function testDocumentElement(parsed, entry) {
      // This is an advanced option. Passed values are used without validation.
      parsed.documentElement = entry;
    }

    function testCssPrefix(parsed, entry) {
      if (typeof entry !== 'string' && entry !== false) {
        throw new Error('noUiSlider (' + VERSION +
            '): \'cssPrefix\' must be a string or `false`.');
      }

      parsed.cssPrefix = entry;
    }

    function testCssClasses(parsed, entry) {
      if (typeof entry !== 'object') {
        throw new Error('noUiSlider (' + VERSION +
            '): \'cssClasses\' must be an object.');
      }

      if (typeof parsed.cssPrefix === 'string') {
        parsed.cssClasses = {};

        for (var key in entry) {
          if (!entry.hasOwnProperty(key)) {
            continue;
          }

          parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
        }
      } else {
        parsed.cssClasses = entry;
      }
    }

    // Test all developer settings and parse to assumption-safe values.
    function testOptions(options) {
      // To prove a fix for #537, freeze options here.
      // If the object is modified, an error will be thrown.
      // Object.freeze(options);

      var parsed = {
        margin: 0,
        limit: 0,
        padding: 0,
        animate: true,
        animationDuration: 300,
        ariaFormat: defaultFormatter,
        format: defaultFormatter,
      };

      // Tests are executed in the order they are presented here.
      var tests = {
        step: {r: false, t: testStep},
        start: {r: true, t: testStart},
        connect: {r: true, t: testConnect},
        direction: {r: true, t: testDirection},
        snap: {r: false, t: testSnap},
        animate: {r: false, t: testAnimate},
        animationDuration: {r: false, t: testAnimationDuration},
        range: {r: true, t: testRange},
        orientation: {r: false, t: testOrientation},
        margin: {r: false, t: testMargin},
        limit: {r: false, t: testLimit},
        padding: {r: false, t: testPadding},
        behaviour: {r: true, t: testBehaviour},
        ariaFormat: {r: false, t: testAriaFormat},
        format: {r: false, t: testFormat},
        tooltips: {r: false, t: testTooltips},
        keyboardSupport: {r: true, t: testKeyboardSupport},
        documentElement: {r: false, t: testDocumentElement},
        cssPrefix: {r: true, t: testCssPrefix},
        cssClasses: {r: true, t: testCssClasses},
      };

      var defaults = {
        connect: false,
        direction: 'ltr',
        behaviour: 'tap',
        orientation: 'horizontal',
        keyboardSupport: true,
        cssPrefix: 'noUi-',
        cssClasses: {
          target: 'target',
          base: 'base',
          origin: 'origin',
          handle: 'handle',
          handleLower: 'handle-lower',
          handleUpper: 'handle-upper',
          horizontal: 'horizontal',
          vertical: 'vertical',
          background: 'background',
          connect: 'connect',
          connects: 'connects',
          ltr: 'ltr',
          rtl: 'rtl',
          draggable: 'draggable',
          drag: 'state-drag',
          tap: 'state-tap',
          active: 'active',
          tooltip: 'tooltip',
          pips: 'pips',
          pipsHorizontal: 'pips-horizontal',
          pipsVertical: 'pips-vertical',
          marker: 'marker',
          markerHorizontal: 'marker-horizontal',
          markerVertical: 'marker-vertical',
          markerNormal: 'marker-normal',
          markerLarge: 'marker-large',
          markerSub: 'marker-sub',
          value: 'value',
          valueHorizontal: 'value-horizontal',
          valueVertical: 'value-vertical',
          valueNormal: 'value-normal',
          valueLarge: 'value-large',
          valueSub: 'value-sub',
        },
      };

      // AriaFormat defaults to regular format, if any.
      if (options.format && !options.ariaFormat) {
        options.ariaFormat = options.format;
      }

      // Run all options through a testing mechanism to ensure correct
      // input. It should be noted that options might get modified to
      // be handled properly. E.g. wrapping integers in arrays.
      Object.keys(tests).forEach(function(name) {
        // If the option isn't set, but it is required, throw an error.
        if (!isSet(options[name]) && defaults[name] === undefined) {
          if (tests[name].r) {
            throw new Error('noUiSlider (' + VERSION + '): \'' + name +
                '\' is required.');
          }

          return true;
        }

        tests[name].t(parsed,
            !isSet(options[name]) ? defaults[name] : options[name]);
      });

      // Forward pips options
      parsed.pips = options.pips;

      // All recent browsers accept unprefixed transform.
      // We need -ms- for IE9 and -webkit- for older Android;
      // Assume use of -webkit- if unprefixed and -ms- are not supported.
      // https://caniuse.com/#feat=transforms2d
      var d = document.createElement('div');
      var msPrefix = d.style.msTransform !== undefined;
      var noPrefix = d.style.transform !== undefined;

      parsed.transformRule = noPrefix ?
          'transform' :
          msPrefix ? 'msTransform' : 'webkitTransform';

      // Pips don't move, so we can place them using left/top.
      var styles = [['left', 'top'], ['right', 'bottom']];

      parsed.style = styles[parsed.dir][parsed.ort];

      return parsed;
    }

    function scope(target, options, originalOptions) {
      var actions = getActions();
      var supportsTouchActionNone = getSupportsTouchActionNone();
      var supportsPassive = supportsTouchActionNone && getSupportsPassive();

      // All variables local to 'scope' are prefixed with 'scope_'
      var scope_Target = target;
      var scope_Locations = [];
      var scope_Base;
      var scope_Handles;
      var scope_HandleNumbers = [];
      var scope_ActiveHandlesCount = 0;
      var scope_Connects;
      var scope_Spectrum = options.spectrum;
      var scope_Values = [];
      var scope_Events = {};
      var scope_Self;
      var scope_Pips;
      var scope_Document = target.ownerDocument;
      var scope_DocumentElement = options.documentElement ||
          scope_Document.documentElement;
      var scope_Body = scope_Document.body;

      // Pips constants
      var PIPS_NONE = -1;
      var PIPS_NO_VALUE = 0;
      var PIPS_LARGE_VALUE = 1;
      var PIPS_SMALL_VALUE = 2;

      // For horizontal sliders in standard ltr documents,
      // make .noUi-origin overflow to the left so the document doesn't scroll.
      var scope_DirOffset = scope_Document.dir === 'rtl' || options.ort === 1 ?
          0 :
          100;

      // Creates a node, adds it to target, returns the new node.
      function addNodeTo(addTarget, className) {
        var div = scope_Document.createElement('div');

        if (className) {
          addClass(div, className);
        }

        addTarget.appendChild(div);

        return div;
      }

      // Append a origin to the base
      function addOrigin(base, handleNumber) {
        var origin = addNodeTo(base, options.cssClasses.origin);
        var handle = addNodeTo(origin, options.cssClasses.handle);

        handle.setAttribute('data-handle', handleNumber);

        if (options.keyboardSupport) {
          // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
          // 0 = focusable and reachable
          handle.setAttribute('tabindex', '0');
        }

        handle.setAttribute('role', 'slider');
        handle.setAttribute('aria-orientation',
            options.ort ? 'vertical' : 'horizontal');

        if (handleNumber === 0) {
          addClass(handle, options.cssClasses.handleLower);
        } else if (handleNumber === options.handles - 1) {
          addClass(handle, options.cssClasses.handleUpper);
        }

        return origin;
      }

      // Insert nodes for connect elements
      function addConnect(base, add) {
        if (!add) {
          return false;
        }

        return addNodeTo(base, options.cssClasses.connect);
      }

      // Add handles to the slider base.
      function addElements(connectOptions, base) {
        var connectBase = addNodeTo(base, options.cssClasses.connects);

        scope_Handles = [];
        scope_Connects = [];

        scope_Connects.push(addConnect(connectBase, connectOptions[0]));

        // [::::O====O====O====]
        // connectOptions = [0, 1, 1, 1]

        for (var i = 0; i < options.handles; i++) {
          // Keep a list of all added handles.
          scope_Handles.push(addOrigin(base, i));
          scope_HandleNumbers[i] = i;
          scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));
        }
      }

      // Initialize a single slider.
      function addSlider(addTarget) {
        // Apply classes and data to the target.
        addClass(addTarget, options.cssClasses.target);

        if (options.dir === 0) {
          addClass(addTarget, options.cssClasses.ltr);
        } else {
          addClass(addTarget, options.cssClasses.rtl);
        }

        if (options.ort === 0) {
          addClass(addTarget, options.cssClasses.horizontal);
        } else {
          addClass(addTarget, options.cssClasses.vertical);
        }

        return addNodeTo(addTarget, options.cssClasses.base);
      }

      function addTooltip(handle, handleNumber) {
        if (!options.tooltips[handleNumber]) {
          return false;
        }

        return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
      }

      // The tooltips option is a shorthand for using the 'update' event.
      function tooltips() {
        // Tooltips are added with options.tooltips in original order.
        var tips = scope_Handles.map(addTooltip);

        bindEvent('update', function(values, handleNumber, unencoded) {
          if (!tips[handleNumber]) {
            return;
          }

          var formattedValue = values[handleNumber];

          if (options.tooltips[handleNumber] !== true) {
            formattedValue = options.tooltips[handleNumber].to(
                unencoded[handleNumber]);
          }

          tips[handleNumber].innerHTML = formattedValue;
        });
      }

      function aria() {
        bindEvent('update',
            function(values, handleNumber, unencoded, tap, positions) {
              // Update Aria Values for all handles, as a change in one changes min and max values for the next.
              scope_HandleNumbers.forEach(function(index) {
                var handle = scope_Handles[index];

                var min = checkHandlePosition(scope_Locations, index, 0, true,
                    true, true);
                var max = checkHandlePosition(scope_Locations, index, 100, true,
                    true, true);

                var now = positions[index];

                // Formatted value for display
                var text = options.ariaFormat.to(unencoded[index]);

                // Map to slider range values
                min = scope_Spectrum.fromStepping(min).toFixed(1);
                max = scope_Spectrum.fromStepping(max).toFixed(1);
                now = scope_Spectrum.fromStepping(now).toFixed(1);

                handle.children[0].setAttribute('aria-valuemin', min);
                handle.children[0].setAttribute('aria-valuemax', max);
                handle.children[0].setAttribute('aria-valuenow', now);
                handle.children[0].setAttribute('aria-valuetext', text);
              });
            });
      }

      function getGroup(mode, values, stepped) {
        // Use the range.
        if (mode === 'range' || mode === 'steps') {
          return scope_Spectrum.xVal;
        }

        if (mode === 'count') {
          if (values < 2) {
            throw new Error('noUiSlider (' + VERSION +
                '): \'values\' (>= 2) required for mode \'count\'.');
          }

          // Divide 0 - 100 in 'count' parts.
          var interval = values - 1;
          var spread = 100 / interval;

          values = [];

          // List these parts and have them handled as 'positions'.
          while (interval--) {
            values[interval] = interval * spread;
          }

          values.push(100);

          mode = 'positions';
        }

        if (mode === 'positions') {
          // Map all percentages to on-range values.
          return values.map(function(value) {
            return scope_Spectrum.fromStepping(
                stepped ? scope_Spectrum.getStep(value) : value);
          });
        }

        if (mode === 'values') {
          // If the value must be stepped, it needs to be converted to a percentage first.
          if (stepped) {
            return values.map(function(value) {
              // Convert to percentage, apply step, return to value.
              return scope_Spectrum.fromStepping(
                  scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));
            });
          }

          // Otherwise, we can simply use the values.
          return values;
        }
      }

      function generateSpread(density, mode, group) {
        function safeIncrement(value, increment) {
          // Avoid floating point variance by dropping the smallest decimal places.
          return (value + increment).toFixed(7) / 1;
        }

        var indexes = {};
        var firstInRange = scope_Spectrum.xVal[0];
        var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];
        var ignoreFirst = false;
        var ignoreLast = false;
        var prevPct = 0;

        // Create a copy of the group, sort it and filter away all duplicates.
        group = unique(
            group.slice().sort(function(a, b) {
              return a - b;
            }),
        );

        // Make sure the range starts with the first element.
        if (group[0] !== firstInRange) {
          group.unshift(firstInRange);
          ignoreFirst = true;
        }

        // Likewise for the last one.
        if (group[group.length - 1] !== lastInRange) {
          group.push(lastInRange);
          ignoreLast = true;
        }

        group.forEach(function(current, index) {
          // Get the current step and the lower + upper positions.
          var step;
          var i;
          var q;
          var low = current;
          var high = group[index + 1];
          var newPct;
          var pctDifference;
          var pctPos;
          var type;
          var steps;
          var realSteps;
          var stepSize;
          var isSteps = mode === 'steps';

          // When using 'steps' mode, use the provided steps.
          // Otherwise, we'll step on to the next subrange.
          if (isSteps) {
            step = scope_Spectrum.xNumSteps[index];
          }

          // Default to a 'full' step.
          if (!step) {
            step = high - low;
          }

          // Low can be 0, so test for false. If high is undefined,
          // we are at the last subrange. Index 0 is already handled.
          if (low === false || high === undefined) {
            return;
          }

          // Make sure step isn't 0, which would cause an infinite loop (#654)
          step = Math.max(step, 0.0000001);

          // Find all steps in the subrange.
          for (i = low; i <= high; i = safeIncrement(i, step)) {
            // Get the percentage value for the current step,
            // calculate the size for the subrange.
            newPct = scope_Spectrum.toStepping(i);
            pctDifference = newPct - prevPct;

            steps = pctDifference / density;
            realSteps = Math.round(steps);

            // This ratio represents the amount of percentage-space a point indicates.
            // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.
            // Round the percentage offset to an even number, then divide by two
            // to spread the offset on both sides of the range.
            stepSize = pctDifference / realSteps;

            // Divide all points evenly, adding the correct number to this subrange.
            // Run up to <= so that 100% gets a point, event if ignoreLast is set.
            for (q = 1; q <= realSteps; q += 1) {
              // The ratio between the rounded value and the actual size might be ~1% off.
              // Correct the percentage offset by the number of points
              // per subrange. density = 1 will result in 100 points on the
              // full range, 2 for 50, 4 for 25, etc.
              pctPos = prevPct + q * stepSize;
              indexes[pctPos.toFixed(5)] = [
                scope_Spectrum.fromStepping(pctPos),
                0];
            }

            // Determine the point type.
            type = group.indexOf(i) > -1 ?
                PIPS_LARGE_VALUE :
                isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE;

            // Enforce the 'ignoreFirst' option by overwriting the type for 0.
            if (!index && ignoreFirst) {
              type = 0;
            }

            if (!(i === high && ignoreLast)) {
              // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.
              indexes[newPct.toFixed(5)] = [i, type];
            }

            // Update the percentage count.
            prevPct = newPct;
          }
        });

        return indexes;
      }

      function addMarking(spread, filterFunc, formatter) {
        var element = scope_Document.createElement('div');

        var valueSizeClasses = [];
        valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal;
        valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge;
        valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;

        var markerSizeClasses = [];
        markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal;
        markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge;
        markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;

        var valueOrientationClasses = [
          options.cssClasses.valueHorizontal,
          options.cssClasses.valueVertical];
        var markerOrientationClasses = [
          options.cssClasses.markerHorizontal,
          options.cssClasses.markerVertical];

        addClass(element, options.cssClasses.pips);
        addClass(element, options.ort === 0 ?
            options.cssClasses.pipsHorizontal :
            options.cssClasses.pipsVertical);

        function getClasses(type, source) {
          var a = source === options.cssClasses.value;
          var orientationClasses = a ?
              valueOrientationClasses :
              markerOrientationClasses;
          var sizeClasses = a ? valueSizeClasses : markerSizeClasses;

          return source + ' ' + orientationClasses[options.ort] + ' ' +
              sizeClasses[type];
        }

        function addSpread(offset, value, type) {
          // Apply the filter function, if it is set.
          type = filterFunc ? filterFunc(value, type) : type;

          if (type === PIPS_NONE) {
            return;
          }

          // Add a marker for every point
          var node = addNodeTo(element, false);
          node.className = getClasses(type, options.cssClasses.marker);
          node.style[options.style] = offset + '%';

          // Values are only appended for points marked '1' or '2'.
          if (type > PIPS_NO_VALUE) {
            node = addNodeTo(element, false);
            node.className = getClasses(type, options.cssClasses.value);
            node.setAttribute('data-value', value);
            node.style[options.style] = offset + '%';
            node.innerHTML = formatter.to(value);
          }
        }

        // Append all points.
        Object.keys(spread).forEach(function(offset) {
          addSpread(offset, spread[offset][0], spread[offset][1]);
        });

        return element;
      }

      function removePips() {
        if (scope_Pips) {
          removeElement(scope_Pips);
          scope_Pips = null;
        }
      }

      function pips(grid) {
        // Fix #669
        removePips();

        var mode = grid.mode;
        var density = grid.density || 1;
        var filter = grid.filter || false;
        var values = grid.values || false;
        var stepped = grid.stepped || false;
        var group = getGroup(mode, values, stepped);
        var spread = generateSpread(density, mode, group);
        var format = grid.format || {
          to: Math.round,
        };

        scope_Pips = scope_Target.appendChild(
            addMarking(spread, filter, format));

        return scope_Pips;
      }

      // Shorthand for base dimensions.
      function baseSize() {
        var rect = scope_Base.getBoundingClientRect();
        var alt = 'offset' + ['Width', 'Height'][options.ort];
        return options.ort === 0 ?
            rect.width || scope_Base[alt] :
            rect.height || scope_Base[alt];
      }

      // Handler for attaching events trough a proxy.
      function attachEvent(events, element, callback, data) {
        // This function can be used to 'filter' events to the slider.
        // element is a node, not a nodeList

        var method = function(e) {
          e = fixEvent(e, data.pageOffset, data.target || element);

          // fixEvent returns false if this event has a different target
          // when handling (multi-) touch events;
          if (!e) {
            return false;
          }

          // doNotReject is passed by all end events to make sure released touches
          // are not rejected, leaving the slider "stuck" to the cursor;
          if (scope_Target.hasAttribute('disabled') && !data.doNotReject) {
            return false;
          }

          // Stop if an active 'tap' transition is taking place.
          if (hasClass(scope_Target, options.cssClasses.tap) &&
              !data.doNotReject) {
            return false;
          }

          // Ignore right or middle clicks on start #454
          if (events === actions.start && e.buttons !== undefined && e.buttons >
              1) {
            return false;
          }

          // Ignore right or middle clicks on start #454
          if (data.hover && e.buttons) {
            return false;
          }

          // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.
          // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support
          // touch-action: manipulation, but that allows panning, which breaks
          // sliders after zooming/on non-responsive pages.
          // See: https://bugs.webkit.org/show_bug.cgi?id=133112
          if (!supportsPassive) {
            e.preventDefault();
          }

          e.calcPoint = e.points[options.ort];

          // Call the event handler with the event [ and additional data ].
          callback(e, data);
        };

        var methods = [];

        // Bind a closure on the target for every event type.
        events.split(' ').forEach(function(eventName) {
          element.addEventListener(eventName, method,
              supportsPassive ? {passive: true} : false);
          methods.push([eventName, method]);
        });

        return methods;
      }

      // Provide a clean event with standardized offset values.
      function fixEvent(e, pageOffset, eventTarget) {
        // Filter the event to register the type, which can be
        // touch, mouse or pointer. Offset changes need to be
        // made on an event specific basis.
        var touch = e.type.indexOf('touch') === 0;
        var mouse = e.type.indexOf('mouse') === 0;
        var pointer = e.type.indexOf('pointer') === 0;

        var x;
        var y;

        // IE10 implemented pointer events with a prefix;
        if (e.type.indexOf('MSPointer') === 0) {
          pointer = true;
        }

        // In the event that multitouch is activated, the only thing one handle should be concerned
        // about is the touches that originated on top of it.
        if (touch) {
          // Returns true if a touch originated on the target.
          var isTouchOnTarget = function(checkTouch) {
            return checkTouch.target === eventTarget ||
                eventTarget.contains(checkTouch.target);
          };

          // In the case of touchstart events, we need to make sure there is still no more than one
          // touch on the target so we look amongst all touches.
          if (e.type === 'touchstart') {
            var targetTouches = Array.prototype.filter.call(e.touches,
                isTouchOnTarget);

            // Do not support more than one touch per handle.
            if (targetTouches.length > 1) {
              return false;
            }

            x = targetTouches[0].pageX;
            y = targetTouches[0].pageY;
          } else {
            // In the other cases, find on changedTouches is enough.
            var targetTouch = Array.prototype.find.call(e.changedTouches,
                isTouchOnTarget);

            // Cancel if the target touch has not moved.
            if (!targetTouch) {
              return false;
            }

            x = targetTouch.pageX;
            y = targetTouch.pageY;
          }
        }

        pageOffset = pageOffset || getPageOffset(scope_Document);

        if (mouse || pointer) {
          x = e.clientX + pageOffset.x;
          y = e.clientY + pageOffset.y;
        }

        e.pageOffset = pageOffset;
        e.points = [x, y];
        e.cursor = mouse || pointer; // Fix #435

        return e;
      }

      // Translate a coordinate in the document to a percentage on the slider
      function calcPointToPercentage(calcPoint) {
        var location = calcPoint - offset(scope_Base, options.ort);
        var proposal = (location * 100) / baseSize();

        // Clamp proposal between 0% and 100%
        // Out-of-bound coordinates may occur when .noUi-base pseudo-elements
        // are used (e.g. contained handles feature)
        proposal = limit(proposal);

        return options.dir ? 100 - proposal : proposal;
      }

      // Find handle closest to a certain percentage on the slider
      function getClosestHandle(proposal) {
        var closest = 100;
        var handleNumber = false;

        scope_Handles.forEach(function(handle, index) {
          // Disabled handles are ignored
          if (handle.hasAttribute('disabled')) {
            return;
          }

          var pos = Math.abs(scope_Locations[index] - proposal);

          if (pos < closest || (pos === 100 && closest === 100)) {
            handleNumber = index;
            closest = pos;
          }
        });

        return handleNumber;
      }

      // Fire 'end' when a mouse or pen leaves the document.
      function documentLeave(event, data) {
        if (event.type === 'mouseout' && event.target.nodeName === 'HTML' &&
            event.relatedTarget === null) {
          eventEnd(event, data);
        }
      }

      // Handle movement on document for handle and range drag.
      function eventMove(event, data) {
        // Fix #498
        // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).
        // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero
        // IE9 has .buttons and .which zero on mousemove.
        // Firefox breaks the spec MDN defines.
        if (navigator.appVersion.indexOf('MSIE 9') === -1 && event.buttons ===
            0 && data.buttonsProperty !== 0) {
          return eventEnd(event, data);
        }

        // Check if we are moving up or down
        var movement = (options.dir ? -1 : 1) *
            (event.calcPoint - data.startCalcPoint);

        // Convert the movement into a percentage of the slider width/height
        var proposal = (movement * 100) / data.baseSize;

        moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);
      }

      // Unbind move events on document, call callbacks.
      function eventEnd(event, data) {
        // The handle is no longer active, so remove the class.
        if (data.handle) {
          removeClass(data.handle, options.cssClasses.active);
          scope_ActiveHandlesCount -= 1;
        }

        // Unbind the move and end events, which are added on 'start'.
        data.listeners.forEach(function(c) {
          scope_DocumentElement.removeEventListener(c[0], c[1]);
        });

        if (scope_ActiveHandlesCount === 0) {
          // Remove dragging class.
          removeClass(scope_Target, options.cssClasses.drag);
          setZindex();

          // Remove cursor styles and text-selection events bound to the body.
          if (event.cursor) {
            scope_Body.style.cursor = '';
            scope_Body.removeEventListener('selectstart', preventDefault);
          }
        }

        data.handleNumbers.forEach(function(handleNumber) {
          fireEvent('change', handleNumber);
          fireEvent('set', handleNumber);
          fireEvent('end', handleNumber);
        });
      }

      // Bind move events on document.
      function eventStart(event, data) {
        var handle;
        if (data.handleNumbers.length === 1) {
          var handleOrigin = scope_Handles[data.handleNumbers[0]];

          // Ignore 'disabled' handles
          if (handleOrigin.hasAttribute('disabled')) {
            return false;
          }

          handle = handleOrigin.children[0];
          scope_ActiveHandlesCount += 1;

          // Mark the handle as 'active' so it can be styled.
          addClass(handle, options.cssClasses.active);
        }

        // A drag should never propagate up to the 'tap' event.
        event.stopPropagation();

        // Record the event listeners.
        var listeners = [];

        // Attach the move and end events.
        var moveEvent = attachEvent(actions.move, scope_DocumentElement,
            eventMove, {
              // The event target has changed so we need to propagate the original one so that we keep
              // relying on it to extract target touches.
              target: event.target,
              handle: handle,
              listeners: listeners,
              startCalcPoint: event.calcPoint,
              baseSize: baseSize(),
              pageOffset: event.pageOffset,
              handleNumbers: data.handleNumbers,
              buttonsProperty: event.buttons,
              locations: scope_Locations.slice(),
            });

        var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd,
            {
              target: event.target,
              handle: handle,
              listeners: listeners,
              doNotReject: true,
              handleNumbers: data.handleNumbers,
            });

        var outEvent = attachEvent('mouseout', scope_DocumentElement,
            documentLeave, {
              target: event.target,
              handle: handle,
              listeners: listeners,
              doNotReject: true,
              handleNumbers: data.handleNumbers,
            });

        // We want to make sure we pushed the listeners in the listener list rather than creating
        // a new one as it has already been passed to the event handlers.
        listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));

        // Text selection isn't an issue on touch devices,
        // so adding cursor styles can be skipped.
        if (event.cursor) {
          // Prevent the 'I' cursor and extend the range-drag cursor.
          scope_Body.style.cursor = getComputedStyle(event.target).cursor;

          // Mark the target with a dragging state.
          if (scope_Handles.length > 1) {
            addClass(scope_Target, options.cssClasses.drag);
          }

          // Prevent text selection when dragging the handles.
          // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,
          // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,
          // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.
          // The 'cursor' flag is false.
          // See: http://caniuse.com/#search=selectstart
          scope_Body.addEventListener('selectstart', preventDefault, false);
        }

        data.handleNumbers.forEach(function(handleNumber) {
          fireEvent('start', handleNumber);
        });
      }

      // Move closest handle to tapped location.
      function eventTap(event) {
        // The tap event shouldn't propagate up
        event.stopPropagation();

        var proposal = calcPointToPercentage(event.calcPoint);
        var handleNumber = getClosestHandle(proposal);

        // Tackle the case that all handles are 'disabled'.
        if (handleNumber === false) {
          return false;
        }

        // Flag the slider as it is now in a transitional state.
        // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.
        if (!options.events.snap) {
          addClassFor(scope_Target, options.cssClasses.tap,
              options.animationDuration);
        }

        setHandle(handleNumber, proposal, true, true);

        setZindex();

        fireEvent('slide', handleNumber, true);
        fireEvent('update', handleNumber, true);
        fireEvent('change', handleNumber, true);
        fireEvent('set', handleNumber, true);

        if (options.events.snap) {
          eventStart(event, {handleNumbers: [handleNumber]});
        }
      }

      // Fires a 'hover' event for a hovered mouse/pen position.
      function eventHover(event) {
        var proposal = calcPointToPercentage(event.calcPoint);

        var to = scope_Spectrum.getStep(proposal);
        var value = scope_Spectrum.fromStepping(to);

        Object.keys(scope_Events).forEach(function(targetEvent) {
          if ('hover' === targetEvent.split('.')[0]) {
            scope_Events[targetEvent].forEach(function(callback) {
              callback.call(scope_Self, value);
            });
          }
        });
      }

      // Attach events to several slider parts.
      function bindSliderEvents(behaviour) {
        // Attach the standard drag event to the handles.
        if (!behaviour.fixed) {
          scope_Handles.forEach(function(handle, index) {
            // These events are only bound to the visual handle
            // element, not the 'real' origin element.
            attachEvent(actions.start, handle.children[0], eventStart, {
              handleNumbers: [index],
            });
          });
        }

        // Attach the tap event to the slider base.
        if (behaviour.tap) {
          attachEvent(actions.start, scope_Base, eventTap, {});
        }

        // Fire hover events
        if (behaviour.hover) {
          attachEvent(actions.move, scope_Base, eventHover, {
            hover: true,
          });
        }

        // Make the range draggable.
        if (behaviour.drag) {
          scope_Connects.forEach(function(connect, index) {
            if (connect === false || index === 0 || index ===
                scope_Connects.length - 1) {
              return;
            }

            var handleBefore = scope_Handles[index - 1];
            var handleAfter = scope_Handles[index];
            var eventHolders = [connect];

            addClass(connect, options.cssClasses.draggable);

            // When the range is fixed, the entire range can
            // be dragged by the handles. The handle in the first
            // origin will propagate the start event upward,
            // but it needs to be bound manually on the other.
            if (behaviour.fixed) {
              eventHolders.push(handleBefore.children[0]);
              eventHolders.push(handleAfter.children[0]);
            }

            eventHolders.forEach(function(eventHolder) {
              attachEvent(actions.start, eventHolder, eventStart, {
                handles: [handleBefore, handleAfter],
                handleNumbers: [index - 1, index],
              });
            });
          });
        }
      }

      // Attach an event to this slider, possibly including a namespace
      function bindEvent(namespacedEvent, callback) {
        scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
        scope_Events[namespacedEvent].push(callback);

        // If the event bound is 'update,' fire it immediately for all handles.
        if (namespacedEvent.split('.')[0] === 'update') {
          scope_Handles.forEach(function(a, index) {
            fireEvent('update', index);
          });
        }
      }

      // Undo attachment of event
      function removeEvent(namespacedEvent) {
        var event = namespacedEvent && namespacedEvent.split('.')[0];
        var namespace = event && namespacedEvent.substring(event.length);

        Object.keys(scope_Events).forEach(function(bind) {
          var tEvent = bind.split('.')[0];
          var tNamespace = bind.substring(tEvent.length);

          if ((!event || event === tEvent) &&
              (!namespace || namespace === tNamespace)) {
            delete scope_Events[bind];
          }
        });
      }

      // External event handling
      function fireEvent(eventName, handleNumber, tap) {
        Object.keys(scope_Events).forEach(function(targetEvent) {
          var eventType = targetEvent.split('.')[0];

          if (eventName === eventType) {
            scope_Events[targetEvent].forEach(function(callback) {
              callback.call(
                  // Use the slider public API as the scope ('this')
                  scope_Self,
                  // Return values as array, so arg_1[arg_2] is always valid.
                  scope_Values.map(options.format.to),
                  // Handle index, 0 or 1
                  handleNumber,
                  // Un-formatted slider values
                  scope_Values.slice(),
                  // Event is fired by tap, true or false
                  tap || false,
                  // Left offset of the handle, in relation to the slider
                  scope_Locations.slice(),
              );
            });
          }
        });
      }

      function toPct(pct) {
        return pct + '%';
      }

      // Split out the handle positioning logic so the Move event can use it, too
      function checkHandlePosition(
          reference, handleNumber, to, lookBackward, lookForward, getValue) {
        // For sliders with multiple handles, limit movement to the other handle.
        // Apply the margin option by adding it to the handle positions.
        if (scope_Handles.length > 1) {
          if (lookBackward && handleNumber > 0) {
            to = Math.max(to, reference[handleNumber - 1] + options.margin);
          }

          if (lookForward && handleNumber < scope_Handles.length - 1) {
            to = Math.min(to, reference[handleNumber + 1] - options.margin);
          }
        }

        // The limit option has the opposite effect, limiting handles to a
        // maximum distance from another. Limit must be > 0, as otherwise
        // handles would be unmovable.
        if (scope_Handles.length > 1 && options.limit) {
          if (lookBackward && handleNumber > 0) {
            to = Math.min(to, reference[handleNumber - 1] + options.limit);
          }

          if (lookForward && handleNumber < scope_Handles.length - 1) {
            to = Math.max(to, reference[handleNumber + 1] - options.limit);
          }
        }

        // The padding option keeps the handles a certain distance from the
        // edges of the slider. Padding must be > 0.
        if (options.padding) {
          if (handleNumber === 0) {
            to = Math.max(to, options.padding[0]);
          }

          if (handleNumber === scope_Handles.length - 1) {
            to = Math.min(to, 100 - options.padding[1]);
          }
        }

        to = scope_Spectrum.getStep(to);

        // Limit percentage to the 0 - 100 range
        to = limit(to);

        // Return false if handle can't move
        if (to === reference[handleNumber] && !getValue) {
          return false;
        }

        return to;
      }

      // Uses slider orientation to create CSS rules. a = base value;
      function inRuleOrder(v, a) {
        var o = options.ort;
        return (o ? a : v) + ', ' + (o ? v : a);
      }

      // Moves handle(s) by a percentage
      // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])
      function moveHandles(upward, proposal, locations, handleNumbers) {
        var proposals = locations.slice();

        var b = [!upward, upward];
        var f = [upward, !upward];

        // Copy handleNumbers so we don't change the dataset
        handleNumbers = handleNumbers.slice();

        // Check to see which handle is 'leading'.
        // If that one can't move the second can't either.
        if (upward) {
          handleNumbers.reverse();
        }

        // Step 1: get the maximum percentage that any of the handles can move
        if (handleNumbers.length > 1) {
          handleNumbers.forEach(function(handleNumber, o) {
            var to = checkHandlePosition(
                proposals,
                handleNumber,
                proposals[handleNumber] + proposal,
                b[o],
                f[o],
                false,
            );

            // Stop if one of the handles can't move.
            if (to === false) {
              proposal = 0;
            } else {
              proposal = to - proposals[handleNumber];
              proposals[handleNumber] = to;
            }
          });
        }

        // If using one handle, check backward AND forward
        else {
          b = f = [true];
        }

        var state = false;

        // Step 2: Try to set the handles with the found percentage
        handleNumbers.forEach(function(handleNumber, o) {
          state = setHandle(handleNumber, locations[handleNumber] + proposal,
              b[o], f[o]) || state;
        });

        // Step 3: If a handle moved, fire events
        if (state) {
          handleNumbers.forEach(function(handleNumber) {
            fireEvent('update', handleNumber);
            fireEvent('slide', handleNumber);
          });
        }
      }

      // Takes a base value and an offset. This offset is used for the connect bar size.
      // In the initial design for this feature, the origin element was 1% wide.
      // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature
      // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223
      function transformDirection(a, b) {
        return options.dir ? 100 - a - b : a;
      }

      // Updates scope_Locations and scope_Values, updates visual state
      function updateHandlePosition(handleNumber, to) {
        // Update locations.
        scope_Locations[handleNumber] = to;

        // Convert the value to the slider stepping/range.
        scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);

        var rule = 'translate(' +
            inRuleOrder(toPct(transformDirection(to, 0) - scope_DirOffset),
                '0') + ')';
        scope_Handles[handleNumber].style[options.transformRule] = rule;

        updateConnect(handleNumber);
        updateConnect(handleNumber + 1);
      }

      // Handles before the slider middle are stacked later = higher,
      // Handles after the middle later is lower
      // [[7] [8] .......... | .......... [5] [4]
      function setZindex() {
        scope_HandleNumbers.forEach(function(handleNumber) {
          var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;
          var zIndex = 3 + (scope_Handles.length + dir * handleNumber);
          scope_Handles[handleNumber].style.zIndex = zIndex;
        });
      }

      // Test suggested values and apply margin, step.
      function setHandle(handleNumber, to, lookBackward, lookForward) {
        to = checkHandlePosition(scope_Locations, handleNumber, to,
            lookBackward, lookForward, false);

        if (to === false) {
          return false;
        }

        updateHandlePosition(handleNumber, to);

        return true;
      }

      // Updates style attribute for connect nodes
      function updateConnect(index) {
        // Skip connects set to false
        if (!scope_Connects[index]) {
          return;
        }

        var l = 0;
        var h = 100;

        if (index !== 0) {
          l = scope_Locations[index - 1];
        }

        if (index !== scope_Connects.length - 1) {
          h = scope_Locations[index];
        }

        // We use two rules:
        // 'translate' to change the left/top offset;
        // 'scale' to change the width of the element;
        // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)
        var connectWidth = h - l;
        var translateRule = 'translate(' +
            inRuleOrder(toPct(transformDirection(l, connectWidth)), '0') + ')';
        var scaleRule = 'scale(' + inRuleOrder(connectWidth / 100, '1') + ')';

        scope_Connects[index].style[options.transformRule] = translateRule +
            ' ' + scaleRule;
      }

      // Parses value passed to .set method. Returns current value if not parse-able.
      function resolveToValue(to, handleNumber) {
        // Setting with null indicates an 'ignore'.
        // Inputting 'false' is invalid.
        if (to === null || to === false || to === undefined) {
          return scope_Locations[handleNumber];
        }

        // If a formatted number was passed, attempt to decode it.
        if (typeof to === 'number') {
          to = String(to);
        }

        to = options.format.from(to);
        to = scope_Spectrum.toStepping(to);

        // If parsing the number failed, use the current value.
        if (to === false || isNaN(to)) {
          return scope_Locations[handleNumber];
        }

        return to;
      }

      // Set the slider value.
      function valueSet(input, fireSetEvent) {
        var values = asArray(input);
        var isInit = scope_Locations[0] === undefined;

        // Event fires by default
        fireSetEvent = fireSetEvent === undefined ? true : !!fireSetEvent;

        // Animation is optional.
        // Make sure the initial values were set before using animated placement.
        if (options.animate && !isInit) {
          addClassFor(scope_Target, options.cssClasses.tap,
              options.animationDuration);
        }

        // First pass, without lookAhead but with lookBackward. Values are set from left to right.
        scope_HandleNumbers.forEach(function(handleNumber) {
          setHandle(handleNumber,
              resolveToValue(values[handleNumber], handleNumber), true, false);
        });

        // Second pass. Now that all base values are set, apply constraints
        scope_HandleNumbers.forEach(function(handleNumber) {
          setHandle(handleNumber, scope_Locations[handleNumber], true, true);
        });

        setZindex();

        scope_HandleNumbers.forEach(function(handleNumber) {
          fireEvent('update', handleNumber);

          // Fire the event only for handles that received a new value, as per #579
          if (values[handleNumber] !== null && fireSetEvent) {
            fireEvent('set', handleNumber);
          }
        });
      }

      // Reset slider to initial values
      function valueReset(fireSetEvent) {
        valueSet(options.start, fireSetEvent);
      }

      // Get the slider value.
      function valueGet() {
        var values = scope_Values.map(options.format.to);

        // If only one handle is used, return a single value.
        if (values.length === 1) {
          return values[0];
        }

        return values;
      }

      // Removes classes from the root and empties it.
      function destroy() {
        for (var key in options.cssClasses) {
          if (!options.cssClasses.hasOwnProperty(key)) {
            continue;
          }
          removeClass(scope_Target, options.cssClasses[key]);
        }

        while (scope_Target.firstChild) {
          scope_Target.removeChild(scope_Target.firstChild);
        }

        delete scope_Target.noUiSlider;
      }

      // Get the current step size for the slider.
      function getCurrentStep() {
        // Check all locations, map them to their stepping point.
        // Get the step point, then find it in the input list.
        return scope_Locations.map(function(location, index) {
          var nearbySteps = scope_Spectrum.getNearbySteps(location);
          var value = scope_Values[index];
          var increment = nearbySteps.thisStep.step;
          var decrement = null;

          // If the next value in this step moves into the next step,
          // the increment is the start of the next step - the current value
          if (increment !== false) {
            if (value + increment > nearbySteps.stepAfter.startValue) {
              increment = nearbySteps.stepAfter.startValue - value;
            }
          }

          // If the value is beyond the starting point
          if (value > nearbySteps.thisStep.startValue) {
            decrement = nearbySteps.thisStep.step;
          } else if (nearbySteps.stepBefore.step === false) {
            decrement = false;
          }

          // If a handle is at the start of a step, it always steps back into the previous step first
          else {
            decrement = value - nearbySteps.stepBefore.highestStep;
          }

          // Now, if at the slider edges, there is not in/decrement
          if (location === 100) {
            increment = null;
          } else if (location === 0) {
            decrement = null;
          }

          // As per #391, the comparison for the decrement step can have some rounding issues.
          var stepDecimals = scope_Spectrum.countStepDecimals();

          // Round per #391
          if (increment !== null && increment !== false) {
            increment = Number(increment.toFixed(stepDecimals));
          }

          if (decrement !== null && decrement !== false) {
            decrement = Number(decrement.toFixed(stepDecimals));
          }

          return [decrement, increment];
        });
      }

      // Updateable: margin, limit, padding, step, range, animate, snap
      function updateOptions(optionsToUpdate, fireSetEvent) {
        // Spectrum is created using the range, snap, direction and step options.
        // 'snap' and 'step' can be updated.
        // If 'snap' and 'step' are not passed, they should remain unchanged.
        var v = valueGet();

        var updateAble = [
          'margin',
          'limit',
          'padding',
          'range',
          'animate',
          'snap',
          'step',
          'format'];

        // Only change options that we're actually passed to update.
        updateAble.forEach(function(name) {
          if (optionsToUpdate[name] !== undefined) {
            originalOptions[name] = optionsToUpdate[name];
          }
        });

        var newOptions = testOptions(originalOptions);

        // Load new options into the slider state
        updateAble.forEach(function(name) {
          if (optionsToUpdate[name] !== undefined) {
            options[name] = newOptions[name];
          }
        });

        scope_Spectrum = newOptions.spectrum;

        // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)
        options.margin = newOptions.margin;
        options.limit = newOptions.limit;
        options.padding = newOptions.padding;

        // Update pips, removes existing.
        if (options.pips) {
          pips(options.pips);
        }

        // Invalidate the current positioning so valueSet forces an update.
        scope_Locations = [];
        valueSet(optionsToUpdate.start || v, fireSetEvent);
      }

      // Create the base element, initialize HTML and set classes.
      // Add handles and connect elements.
      scope_Base = addSlider(scope_Target);
      addElements(options.connect, scope_Base);

      // Attach user events.
      bindSliderEvents(options.events);

      // Use the public value method to set the start values.
      valueSet(options.start);

      // noinspection JSUnusedGlobalSymbols
      scope_Self = {
        destroy: destroy,
        steps: getCurrentStep,
        on: bindEvent,
        off: removeEvent,
        get: valueGet,
        set: valueSet,
        reset: valueReset,
        // Exposed for unit testing, don't use this in your application.
        __moveHandles: function(a, b, c) {
          moveHandles(a, b, scope_Locations, c);
        },
        options: originalOptions, // Issue #600, #678
        updateOptions: updateOptions,
        target: scope_Target, // Issue #597
        removePips: removePips,
        pips: pips, // Issue #594
      };

      if (options.pips) {
        pips(options.pips);
      }

      if (options.tooltips) {
        tooltips();
      }

      aria();

      return scope_Self;
    }

    // Run the standard initializer
    function initialize(target, originalOptions) {
      if (!target || !target.nodeName) {
        throw new Error('noUiSlider (' + VERSION +
            '): create requires a single element, got: ' + target);
      }

      // Throw an error if the slider was already initialized.
      if (target.noUiSlider) {
        throw new Error('noUiSlider (' + VERSION +
            '): Slider was already initialized.');
      }

      // Test the options and create the slider environment;
      var options = testOptions(originalOptions, target);
      var api = scope(target, options, originalOptions);

      target.noUiSlider = api;

      return api;
    }

    // Use an object instead of a function for future expandability;
    return {
      // Exposed for unit testing, don't use this in your application.
      __spectrum: Spectrum,
      version: VERSION,
      create: initialize,
    };
  });

  /* ../../node_modules/nouislider/distribute/nouislider.js end */

  provide(window.noUiSlider);

});

/* end: ../../5th.blocks/common.blocks/nouislider/nouislider.js */
/* begin: ../../5th.blocks/common.blocks/wnumb/wnumb.js */
modules.define('wnumb', function(provide) {

  /**
   * @see https://github.com/leongersen/noUiSlider/blob/master/documentation/assets/wNumb.js
   */
  (function(factory) {

    if (typeof define === 'function' && define.amd) {

      // AMD. Register as an anonymous module.
      define([], factory);

    } else if (typeof exports === 'object') {

      // Node/CommonJS
      module.exports = factory();

    } else {

      // Browser globals
      window.wNumb = factory();
    }

  }(function() {

    'use strict';

    var FormatOptions = [
      'decimals',
      'thousand',
      'mark',
      'prefix',
      'suffix',
      'encoder',
      'decoder',
      'negativeBefore',
      'negative',
      'edit',
      'undo',
    ];

    // General

    // Reverse a string
    function strReverse(a) {
      return a.split('').reverse().join('');
    }

    // Check if a string starts with a specified prefix.
    function strStartsWith(input, match) {
      return input.substring(0, match.length) === match;
    }

    // Check is a string ends in a specified suffix.
    function strEndsWith(input, match) {
      return input.slice(-1 * match.length) === match;
    }

    // Throw an error if formatting options are incompatible.
    function throwEqualError(F, a, b) {
      if ((F[a] || F[b]) && (F[a] === F[b])) {
        throw new Error(a);
      }
    }

    // Check if a number is finite and not NaN
    function isValidNumber(input) {
      return typeof input === 'number' && isFinite(input);
    }

    // Provide rounding-accurate toFixed method.
    // Borrowed: http://stackoverflow.com/a/21323330/775265
    function toFixed(value, exp) {
      value = value.toString().split('e');
      value = Math.round(
          +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp)));
      value = value.toString().split('e');
      return (+(value[0] + 'e' +
          (value[1] ? (+value[1] - exp) : -exp))).toFixed(exp);
    }

    // Formatting

    // Accept a number as input, output formatted string.
    function formatTo(
        decimals, thousand, mark, prefix, suffix, encoder, decoder,
        negativeBefore, negative, edit, undo, input) {

      var originalInput = input, inputIsNegative, inputPieces, inputBase,
          inputDecimals = '', output = '';

      // Apply user encoder to the input.
      // Expected outcome: number.
      if (encoder) {
        input = encoder(input);
      }

      // Stop if no valid number was provided, the number is infinite or NaN.
      if (!isValidNumber(input)) {
        return false;
      }

      // Rounding away decimals might cause a value of -0
      // when using very small ranges. Remove those cases.
      if (decimals !== false && parseFloat(input.toFixed(decimals)) === 0) {
        input = 0;
      }

      // Formatting is done on absolute numbers,
      // decorated by an optional negative symbol.
      if (input < 0) {
        inputIsNegative = true;
        input = Math.abs(input);
      }

      // Reduce the number of decimals to the specified option.
      if (decimals !== false) {
        input = toFixed(input, decimals);
      }

      // Transform the number into a string, so it can be split.
      input = input.toString();

      // Break the number on the decimal separator.
      if (input.indexOf('.') !== -1) {
        inputPieces = input.split('.');

        inputBase = inputPieces[0];

        if (mark) {
          inputDecimals = mark + inputPieces[1];
        }

      } else {

        // If it isn't split, the entire number will do.
        inputBase = input;
      }

      // Group numbers in sets of three.
      if (thousand) {
        inputBase = strReverse(inputBase).match(/.{1,3}/g);
        inputBase = strReverse(inputBase.join(strReverse(thousand)));
      }

      // If the number is negative, prefix with negation symbol.
      if (inputIsNegative && negativeBefore) {
        output += negativeBefore;
      }

      // Prefix the number
      if (prefix) {
        output += prefix;
      }

      // Normal negative option comes after the prefix. Defaults to '-'.
      if (inputIsNegative && negative) {
        output += negative;
      }

      // Append the actual number.
      output += inputBase;
      output += inputDecimals;

      // Apply the suffix.
      if (suffix) {
        output += suffix;
      }

      // Run the output through a user-specified post-formatter.
      if (edit) {
        output = edit(output, originalInput);
      }

      // All done.
      return output;
    }

    // Accept a sting as input, output decoded number.
    function formatFrom(
        decimals, thousand, mark, prefix, suffix, encoder, decoder,
        negativeBefore, negative, edit, undo, input) {

      var originalInput = input, inputIsNegative, output = '';

      // User defined pre-decoder. Result must be a non empty string.
      if (undo) {
        input = undo(input);
      }

      // Test the input. Can't be empty.
      if (!input || typeof input !== 'string') {
        return false;
      }

      // If the string starts with the negativeBefore value: remove it.
      // Remember is was there, the number is negative.
      if (negativeBefore && strStartsWith(input, negativeBefore)) {
        input = input.replace(negativeBefore, '');
        inputIsNegative = true;
      }

      // Repeat the same procedure for the prefix.
      if (prefix && strStartsWith(input, prefix)) {
        input = input.replace(prefix, '');
      }

      // And again for negative.
      if (negative && strStartsWith(input, negative)) {
        input = input.replace(negative, '');
        inputIsNegative = true;
      }

      // Remove the suffix.
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice
      if (suffix && strEndsWith(input, suffix)) {
        input = input.slice(0, -1 * suffix.length);
      }

      // Remove the thousand grouping.
      if (thousand) {
        input = input.split(thousand).join('');
      }

      // Set the decimal separator back to period.
      if (mark) {
        input = input.replace(mark, '.');
      }

      // Prepend the negative symbol.
      if (inputIsNegative) {
        output += '-';
      }

      // Add the number
      output += input;

      // Trim all non-numeric characters (allow '.' and '-');
      output = output.replace(/[^0-9\.\-.]/g, '');

      // The value contains no parse-able number.
      if (output === '') {
        return false;
      }

      // Covert to number.
      output = Number(output);

      // Run the user-specified post-decoder.
      if (decoder) {
        output = decoder(output);
      }

      // Check is the output is valid, otherwise: return false.
      if (!isValidNumber(output)) {
        return false;
      }

      return output;
    }

    // Framework

    // Validate formatting options
    function validate(inputOptions) {

      var i, optionName, optionValue,
          filteredOptions = {};

      if (inputOptions['suffix'] === undefined) {
        inputOptions['suffix'] = inputOptions['postfix'];
      }

      for (i = 0; i < FormatOptions.length; i += 1) {

        optionName = FormatOptions[i];
        optionValue = inputOptions[optionName];

        if (optionValue === undefined) {

          // Only default if negativeBefore isn't set.
          if (optionName === 'negative' && !filteredOptions.negativeBefore) {
            filteredOptions[optionName] = '-';
            // Don't set a default for mark when 'thousand' is set.
          } else if (optionName === 'mark' && filteredOptions.thousand !==
              '.') {
            filteredOptions[optionName] = '.';
          } else {
            filteredOptions[optionName] = false;
          }

          // Floating points in JS are stable up to 7 decimals.
        } else if (optionName === 'decimals') {
          if (optionValue >= 0 && optionValue < 8) {
            filteredOptions[optionName] = optionValue;
          } else {
            throw new Error(optionName);
          }

          // These options, when provided, must be functions.
        } else if (optionName === 'encoder' || optionName === 'decoder' ||
            optionName === 'edit' || optionName === 'undo') {
          if (typeof optionValue === 'function') {
            filteredOptions[optionName] = optionValue;
          } else {
            throw new Error(optionName);
          }

          // Other options are strings.
        } else {

          if (typeof optionValue === 'string') {
            filteredOptions[optionName] = optionValue;
          } else {
            throw new Error(optionName);
          }
        }
      }

      // Some values can't be extracted from a
      // string if certain combinations are present.
      throwEqualError(filteredOptions, 'mark', 'thousand');
      throwEqualError(filteredOptions, 'prefix', 'negative');
      throwEqualError(filteredOptions, 'prefix', 'negativeBefore');

      return filteredOptions;
    }

    // Pass all options as function arguments
    function passAll(options, method, input) {
      var i, args = [];

      // Add all options in order of FormatOptions
      for (i = 0; i < FormatOptions.length; i += 1) {
        args.push(options[FormatOptions[i]]);
      }

      // Append the input, then call the method, presenting all
      // options as arguments.
      args.push(input);
      return method.apply('', args);
    }

    function wNumb(options) {

      if (!(this instanceof wNumb)) {
        return new wNumb(options);
      }

      if (typeof options !== 'object') {
        return;
      }

      options = validate(options);

      // Call 'formatTo' with proper arguments.
      this.to = function(input) {
        return passAll(options, formatTo, input);
      };

      // Call 'formatFrom' with proper arguments.
      this.from = function(input) {
        return passAll(options, formatFrom, input);
      };
    }

    return wNumb;

  }));

  provide(window.wNumb);

});

/* end: ../../5th.blocks/common.blocks/wnumb/wnumb.js */
/* begin: ../../5th.blocks/common.blocks/polyfill/__isinteger/polyfill__isinteger.js */
Number.isInteger = Number.isInteger || function(value) {
  return typeof value === 'number' &&
      isFinite(value) &&
      Math.floor(value) === value;
};

/* end: ../../5th.blocks/common.blocks/polyfill/__isinteger/polyfill__isinteger.js */
/* begin: ../../design/common.blocks/range-slider/_theme/range-slider_theme_finza.js */
modules.define('range-slider', ['i-bem-dom', 'BEMHTML', 'jquery', 'next-tick'],
    function(provide, bemDom, BEMHTML, $, nextTick, RangeSlider) {

      provide(RangeSlider.declMod({modName: 'theme', modVal: 'finza'}, {

        _init: function() {
          this.__base.apply(this, arguments);

          this._setHandleIcon();
        },

        _setHandleIcon: function() {
          var icon = this.params.hangleIcon,
              handle = this.domElem.find('.noUi-handle');

          if (!icon || !handle) return;

          bemDom.append(handle, BEMHTML.apply(icon));
        },
      }));

    });

/* end: ../../design/common.blocks/range-slider/_theme/range-slider_theme_finza.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_select.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['select'],
    function(provide, Select, FormField) {
      /**
       * Select field
       *
       * @exports
       * @class form-field
       * @bem
       */
      provide(FormField.declMod({modName: 'type', modVal: 'select'}, {

        getControl: function() {
          return this._control || (this._control = this.findChildBlock(Select));
        },

      }, /** @lends form-field_type_checkbox */{
        lazyInit: true,

        onInit: function() {
          var ptp = this.prototype;

          this.__base();
          this._events(Select).
              on('change', ptp._onControlChange).
              on({modName: 'focused', modVal: true}, ptp._onControlFocus).
              on({modName: 'focused', modVal: ''}, ptp._onControlBlur);
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_select.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/select/select.js */
/**
 * @module select
 */

modules.define(
    'select',
    [
      'i-bem-dom',
      'popup',
      'menu',
      'menu__item',
      'button',
      'jquery',
      'dom',
      'keyboard__codes',
      'strings__escape'],
    function(
        provide, bemDom, Popup, Menu, MenuItem, Button, $, dom, keyCodes,
        escape) {

      /**
       * @exports
       * @class select
       * @bem
       *
       * @bemmod opened Represents opened state
       */
      provide(bemDom.declBlock(this.name, /** @lends select.prototype */{
        beforeSetMod: {
          'opened': {
            'true': function() {
              return !this.hasMod('disabled');
            },
          },

          'focused': {
            '': function() {
              return !this._isPointerPressInProgress;
            },
          },
        },

        onSetMod: {
          'js': {
            'inited': function() {
              this._button = this.findChildBlock(Button);
              this._events(Button).on('click', this._onButtonClick, this);

              this._popup = this.findChildBlock(Popup).setAnchor(this._button);
              this._events(Popup).
                  on({modName: 'visible', modVal: ''}, this._onPopupHide, this);

              this._menu = this._popup.findChildBlock(Menu);
              this._events(this._menu).
                  on('change', this._onMenuChange, this).
                  on('item-click', this._onMenuItemClick, this).
                  on('item-hover', this._onMenuItemHover, this);

              this._isPointerPressInProgress = false;
              this._buttonWidth = null;

              this.hasMod('focused') && this._focus();
            },
          },

          'focused': {
            'true': function() {
              this._focus();
            },

            '': function() {
              this._blur();
            },
          },

          'opened': {
            '*': function(_, modVal) {
              this._menu.setMod('focused', modVal);
            },

            'true': function() {
              this._buttonWidth === null && this._updateMenuWidth();

              this._updateMenuHeight();
              this._popup.setMod('visible');
              this._domEvents(bemDom.doc).
                  on('pointerpress', this._onDocPointerPress);
              this.setMod('focused')._hoverCheckedOrFirstItem();
            },

            '': function() {
              this._domEvents(bemDom.doc).
                  un('pointerpress', this._onDocPointerPress);
              this._popup.delMod('visible');
            },
          },

          'disabled': {
            '*': function(modName, modVal) {
              this._button.setMod(modName, modVal);
              this._menu.setMod(modName, modVal);
            },

            'true': function() {
              this._elems('control').forEach(function(control) {
                control.domElem.attr('disabled', true);
              });
              this._popup.delMod('visible');
            },

            '': function() {
              this._elems('control').forEach(function(control) {
                control.domElem.removeAttr('disabled');
              });
            },
          },
        },

        /**
         * Get value
         * @returns {*}
         */
        getVal: function() {
          return this._menu.getVal();
        },

        /**
         * Set value
         * @param {*} val
         * @returns {select} this
         */
        setVal: function(val) {
          this._menu.setVal(val);
          return this;
        },

        /**
         * Get name
         * @returns {String}
         */
        getName: function() {
          return this.params.name;
        },

        _getDefaultParams: function() {
          return {
            optionsMaxHeight: Number.POSITIVE_INFINITY,
          };
        },

        _focus: function() {
          this._domEvents('button').
              on('keydown', this._onKeyDown).
              on('keypress', this._onKeyPress);

          this._button.setMod('focused');
        },

        _blur: function() {
          this._domEvents('button').
              un('keydown', this._onKeyDown).
              un('keypress', this._onKeyPress);

          this.delMod('opened');
          this._button.delMod('focused');
        },

        _updateMenuWidth: function() {
          this._menu.domElem.css('min-width',
              this._buttonWidth = this._button.domElem.outerWidth());

          this._popup.redraw();
        },

        _updateMenuHeight: function() {
          var drawingParams = this._popup.calcPossibleDrawingParams(),
              menuDomElem = this._menu.domElem,
              menuWidth = menuDomElem.outerWidth(),
              bestHeight = 0;

          drawingParams.forEach(function(params) {
            params.width >= menuWidth && params.height > bestHeight &&
            (bestHeight = params.height);
          });

          bestHeight && menuDomElem.css('max-height',
              Math.min(this.params.optionsMaxHeight, bestHeight));
        },

        _getCheckedItems: function() {
          return this._menu.getItems().filter(function(item) {
            return item.hasMod('checked');
          });
        },

        _hoverCheckedOrFirstItem: function() { // NOTE: may be it should be moved to menu
          (this._getCheckedItems().get(0) ||
              this._menu.getItems().get(0)).setMod('hovered');
        },

        _onKeyDown: function(e) {
          if (this.hasMod('opened')) {
            if (e.keyCode === keyCodes.ESC) {
              // NOTE: stop propagation to prevent from being listened by global handlers
              e.stopPropagation();
              this.delMod('opened');
            }
          } else if ((e.keyCode === keyCodes.UP || e.keyCode ===
              keyCodes.DOWN) && !e.shiftKey) {
            e.preventDefault();
            this.setMod('opened');
          }
        },

        _onKeyPress: function(e) {
          // press a key: closed select - set value, opened select - set hover on menu-item.
          if (!this.hasMod('opened')) {
            var item = this._menu.searchItemByKeyboardEvent(e);
            item && this._setSingleVal(item.getVal());
          }
        },

        _setSingleVal: function(value) {
          this.setVal(value);
        },

        _onMenuChange: function() {
          this._updateControl();
          this._updateButton();

          this.hasMod('opened') ?
              this._updateMenuWidth() :
              this._buttonWidth = null;

          this._emit('change');
        },

        _onMenuItemClick: function() {
        },

        _onMenuItemHover: function(e, data) {
          var item = data.item;
          item.hasMod('hovered') ?
              this._button.domElem.attr('aria-activedescendant',
                  item.domElem.attr('id')) :
              this._button.domElem.removeAttr('aria-activedescendant');
        },

        _updateControl: function() {
        },

        _updateButton: function() {
        },

        _onButtonClick: function() {
          this.toggleMod('opened');
        },

        _onButtonFocusChange: function(e, data) {
          this.setMod('focused', data.modVal);
        },

        _onPopupHide: function() {
          this.delMod('opened');
        },

        _onDocPointerPress: function(e) {
          if (this._isEventInPopup(e)) {
            e.pointerType === 'mouse' && e.preventDefault(); // prevents button blur in most desktop browsers
            this._isPointerPressInProgress = true;
            this._domEvents(bemDom.doc).on(
                'pointerrelease',
                {focusedHardMod: this._button.getMod('focused-hard')},
                this._onDocPointerRelease);
          }
        },

        _onDocPointerRelease: function(e) {
          this._isPointerPressInProgress = false;
          this._domEvents().un('pointerrelease', this._onDocPointerRelease);
          this._button.toggleMod('focused', true, '', this._isEventInPopup(e)).
              setMod('focused-hard', e.data.focusedHardMod);
        },

        _isEventInPopup: function(e) {
          return dom.contains(this._popup.domElem, $(e.target));
        },
      }, /** @lends select */{
        lazyInit: true,
        onInit: function() {
          this._events(Button).on(
              {modName: 'focused', modVal: '*'},
              this.prototype._onButtonFocusChange);
        },

        _createControlHTML: function(name, val) {
          // Using string concatenation to not depend on template engines
          return '<input ' +
              'type="hidden" ' +
              'name="' + name + '" ' +
              'class="' + this._buildClassName('control') + '" ' +
              'value="' + escape.attr(val) + '"/>';
        },
      }));

    });

/* end: ../../node_modules/bem-components/common.blocks/select/select.js */
/* begin: ../../node_modules/bem-components/common.blocks/menu/menu.js */
/**
 * @module menu
 */

modules.define(
    'menu',
    ['i-bem-dom', 'control', 'keyboard__codes', 'menu__item'],
    function(provide, bemDom, Control, keyCodes, MenuItem) {

      /** @const Number */
      var TIMEOUT_KEYBOARD_SEARCH = 1500;

      /**
       * @exports
       * @class menu
       * @augments control
       * @bem
       */
      provide(bemDom.declBlock(this.name, Control, /** @lends menu.prototype */{
        onSetMod: {
          'js': {
            'inited': function() {
              this.__base.apply(this, arguments);
              this._hoveredItem = null;
              this._items = null;

              this._lastTyping = {
                char: '',
                text: '',
                index: 0,
                time: 0,
              };
            },
          },

          'disabled': {
            '*': function(modName, modVal) {
              this.__base.apply(this, arguments);
              this.getItems().setMod(modName, modVal);
            },
            'true': function() {
              this.__base.apply(this, arguments);
              this.domElem.attr('aria-disabled', true);
            },
            '': function() {
              this.__base.apply(this, arguments);
              this.domElem.removeAttr('aria-disabled');
            },
          },
        },

        /**
         * Returns items
         * @returns {menu__item[]}
         */
        getItems: function() {
          return this._items || (this._items = this.findChildElems('item'));
        },

        /**
         * Sets content
         * @param {String|jQuery} content
         * @returns {menu} this
         */
        setContent: function(content) {
          bemDom.update(this.domElem, content);
          this._hoveredItem = null;
          this._items = null;
          return this;
        },

        /**
         * Search menu item by keyboard event
         * @param {jQuery.Event} e
         * @returns {menu__item}
         */
        searchItemByKeyboardEvent: function(e) {
          var currentTime = +new Date(),
              charCode = e.charCode,
              char = String.fromCharCode(charCode).toLowerCase(),
              lastTyping = this._lastTyping,
              index = lastTyping.index,
              isSameChar = char === lastTyping.char &&
                  lastTyping.text.length === 1,
              items = this.getItems();

          if (charCode <= keyCodes.SPACE || e.ctrlKey || e.altKey ||
              e.metaKey) {
            lastTyping.time = currentTime;
            return null;
          }

          if (currentTime - lastTyping.time > TIMEOUT_KEYBOARD_SEARCH ||
              isSameChar) {
            lastTyping.text = char;
          } else {
            lastTyping.text += char;
          }

          lastTyping.char = char;
          lastTyping.time = currentTime;

          // If key is pressed again, then continue to search to next menu item
          if (isSameChar &&
              items.get(index).getText().search(lastTyping.char) === 0) {
            index = index >= items.size() - 1 ? 0 : index + 1;
          }

          // 2 passes: from index to items.size() and from 0 to index.
          var i = index, len = items.size();
          while (i < len) {
            if (this._doesItemMatchText(items.get(i), lastTyping.text)) {
              lastTyping.index = i;
              return items.get(i);
            }

            i++;

            if (i === items.size()) {
              i = 0;
              len = index;
            }
          }

          return null;
        },

        /** @override **/
        _onFocus: function() {
          this.__base.apply(this, arguments);
          this._domEvents(bemDom.doc) // NOTE: should be called after __base
              .on('keydown', this._onKeyDown).on('keypress', this._onKeyPress);
        },

        /** @override **/
        _onBlur: function() {
          this._domEvents(bemDom.doc).
              un('keydown', this._onKeyDown).
              un('keypress', this._onKeyPress);

          this.__base.apply(this, arguments);
          this._hoveredItem && this._hoveredItem.delMod('hovered');
        },

        /**
         * @param {Object} item
         * @private
         */
        _onItemHover: function(item) {
          if (item.hasMod('hovered')) {
            this._hoveredItem && this._hoveredItem.delMod('hovered');
            this._scrollToItem(this._hoveredItem = item);
            this.domElem.attr('aria-activedescendant', item.domElem.attr('id'));
          } else if (this._hoveredItem === item) {
            this._hoveredItem = null;
            this.domElem.removeAttr('aria-activedescendant');
          }
          this._emit('item-hover', {item: item});
        },

        /**
         * @param {Object} item
         * @private
         */
        _scrollToItem: function(item) {
          var domElemOffsetTop = this.domElem.offset().top,
              itemDomElemOffsetTop = item.domElem.offset().top,
              relativeScroll;

          if ((relativeScroll = itemDomElemOffsetTop - domElemOffsetTop) < 0 ||
              (relativeScroll =
                  itemDomElemOffsetTop +
                  item.domElem.outerHeight() -
                  domElemOffsetTop -
                  this.domElem.outerHeight()) > 0) {
            this.domElem.scrollTop(this.domElem.scrollTop() + relativeScroll);
          }
        },

        /**
         * @param {Object} item
         * @param {Object} data
         * @private
         */
        _onItemClick: function(item, data) {
          this._emit('item-click', {item: item, source: data.source});
        },

        /**
         * @param {jQuery.Event} e
         * @private
         */
        _onKeyDown: function(e) {
          var keyCode = e.keyCode,
              isArrow = keyCode === keyCodes.UP || keyCode === keyCodes.DOWN;

          if (isArrow && !e.shiftKey) {
            e.preventDefault();

            var dir = keyCode - 39, // using the features of key codes for "up"/"down" ;-)
                items = this.getItems(),
                len = items.size(),
                hoveredIdx = items.toArray().indexOf(this._hoveredItem),
                nextIdx = hoveredIdx,
                i = 0;

            do {
              nextIdx += dir;
              nextIdx = nextIdx < 0 ? len - 1 : nextIdx >= len ? 0 : nextIdx;
              if (++i === len) return; // if we have no next item to hover
            } while (items.get(nextIdx).hasMod('disabled'));

            this._lastTyping.index = nextIdx;

            items.get(nextIdx).setMod('hovered');
          }
        },

        /**
         * @param {jQuery.Event} e
         * @private
         */
        _onKeyPress: function(e) {
          var item = this.searchItemByKeyboardEvent(e);
          item && item.setMod('hovered');
        },

        /**
         * @param {Object} item
         * @param {String} text
         * @private
         */
        _doesItemMatchText: function(item, text) {
          return !item.hasMod('disabled') &&
              item.getText().toLowerCase().search(text) === 0;
        },
      }, /** @lends menu */{
        lazyInit: true,
        onInit: function() {
          this._events(MenuItem).
              on({modName: 'hovered', modVal: '*'}, function(e) {
                this._onItemHover(e.target);
              }).
              on('click', function(e, data) {
                this._onItemClick(e.target, data);
              });

          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../node_modules/bem-components/common.blocks/menu/menu.js */
/* begin: ../../node_modules/bem-components/common.blocks/menu/__item/menu__item.js */
/**
 * @module menu__item
 */

modules.define('menu__item', ['i-bem-dom'], function(provide, bemDom) {

  /**
   * @exports
   * @class menu__item
   * @bem
   *
   * @param val Value of item
   */
  provide(bemDom.declElem('menu', 'item', /** @lends menu__item.prototype */{
    beforeSetMod: {
      'hovered': {
        'true': function() {
          return !this.hasMod('disabled');
        },
      },
    },

    onSetMod: {
      'js': {
        'inited': function() {
          this._domEvents().on('pointerleave', this._onPointerLeave);
        },
      },

      'disabled': {
        'true': function() {
          this.delMod('hovered').domElem.attr('aria-disabled', true);
        },
        '': function() {
          this.domElem.removeAttr('aria-disabled');
        },
      },

      'checked': {
        '*': function(_, modVal) {
          this.domElem.attr('aria-checked', !!modVal);
        },
      },
    },

    /**
     * Checks whether given value is equal to current value
     * @param {String|Number} val
     * @returns {Boolean}
     */
    isValEq: function(val) {
      // NOTE: String(true) == String(1) -> false
      return String(this.params.val) === String(val);
    },

    /**
     * Returns item value
     * @returns {*}
     */
    getVal: function() {
      return this.params.val;
    },

    /**
     * Returns item text
     * @returns {String}
     */
    getText: function() {
      return this.params.text || this.domElem.text();
    },

    _onPointerOver: function() {
      this.setMod('hovered');
    },

    _onPointerLeave: function() {
      this.delMod('hovered');
    },

    _onPointerClick: function() {
      this.hasMod('disabled') || this._emit('click', {source: 'pointer'});
    },
  }, /** @lends menu__item */{
    lazyInit: true,
    onInit: function() {
      var ptp = this.prototype;

      this._domEvents().
          on('pointerover', ptp._onPointerOver).
          on('pointerclick', ptp._onPointerClick);
    },
  }));

});

/* end: ../../node_modules/bem-components/common.blocks/menu/__item/menu__item.js */
/* begin: ../../node_modules/bem-components/common.blocks/popup/_autoclosable/popup_autoclosable.js */
/**
 * @module popup
 */

modules.define(
    'popup',
    ['jquery', 'i-bem-dom', 'ua', 'dom', 'keyboard__codes'],
    function(provide, $, bemDom, ua, dom, keyCodes, Popup) {

      var KEYDOWN_EVENT = ua.opera && ua.version < 12.10 ?
          'keypress' :
          'keydown',
          visiblePopupsStack = [];

      /**
       * @exports
       * @class popup
       * @bem
       */
      provide(Popup.declMod({modName: 'autoclosable', modVal: true},
          /** @lends popup.prototype */{
            onSetMod: {
              'visible': {
                'true': function() {
                  visiblePopupsStack.unshift(this);
                  // NOTE: nextTick because of event bubbling to document
                  this._nextTick(function() {
                    this._domEvents(bemDom.doc).
                        on('pointerclick', this._onDocPointerClick);
                  }).__base.apply(this, arguments);
                },

                '': function() {
                  visiblePopupsStack.splice(visiblePopupsStack.indexOf(this),
                      1);
                  this._domEvents(bemDom.doc).
                      un('pointerclick', this._onDocPointerClick);
                  this.__base.apply(this, arguments);
                },
              },
            },

            _onDocPointerClick: function(e) {
              if (this.hasMod('target', 'anchor') &&
                  dom.contains(this._anchor, $(e.target)))
                return;

              this._preventHideByClick ?
                  this._preventHideByClick = null :
                  this.delMod('visible');
            },
          }, /** @lends popup */{
            lazyInit: true,
            onInit: function() {
              // TODO: checkme!
              // this._domEvents(bemDom.doc).on(KEYDOWN_EVENT, onDocKeyPress);
              bemDom.doc.on(KEYDOWN_EVENT, onDocKeyPress);
            },
          }));

      function onDocKeyPress(e) {
        e.keyCode === keyCodes.ESC &&
        // omit ESC in inputs, selects and etc.
        visiblePopupsStack.length &&
        !dom.isEditable($(e.target)) &&
        visiblePopupsStack[0].delMod('visible');
      }

    });

/* end: ../../node_modules/bem-components/common.blocks/popup/_autoclosable/popup_autoclosable.js */
/* begin: ../../node_modules/bem-components/common.blocks/select/_mode/select_mode_radio-check.js */
/**
 * @module select
 */

modules.define('select', ['i-bem-dom', 'jquery'],
    function(provide, bemDom, $, Select) {

      /**
       * @exports
       * @class select
       * @bem
       */
      provide(Select.declMod({modName: 'mode', modVal: 'radio-check'},
          /** @lends select.prototype */{
            _updateControl: function() {
              var val = this.getVal(),
                  control = this._elem('control'),
                  controlDomElem = control && control.domElem;

              if (!controlDomElem || !controlDomElem.length) {
                controlDomElem = $(
                    Select._createControlHTML(this.getName(), val));
              }

              if (typeof val === 'undefined') {
                // NOTE: because there is a possibility of whole select disabling,
                // "destruct" is used instead of "disable"
                bemDom.destruct(controlDomElem);
              } else {
                if (!controlDomElem.parent().length) {
                  bemDom.prepend(this.domElem, controlDomElem);
                  this._dropElemCache('control');
                }
                controlDomElem.val(val);
              }
            },

            _updateButton: function() {
              var checkedItem = this._getCheckedItems().get(0);

              this._button.toggleMod('checked', true, '', !!checkedItem).
                  setText(
                      checkedItem ? checkedItem.getText() : this.params.text);
            },

            _onMenuItemClick: function(_, data) {
              data.source === 'pointer' && this.delMod('opened');
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/select/_mode/select_mode_radio-check.js */
/* begin: ../../node_modules/bem-components/common.blocks/menu/_mode/menu_mode.js */
/**
 * @module menu
 */

modules.define('menu', ['i-bem-dom', 'keyboard__codes'],
    function(provide, bemDom, keyCodes, Menu) {

      /**
       * @exports
       * @class menu
       * @bem
       */
      provide(Menu.declMod({modName: 'mode', modVal: '*'},
          /** @lends menu.prototype */{
            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);
                  this._val = null;
                  this._isValValid = false;
                },
              },
            },

            _onKeyDown: function(e) {
              if (e.keyCode === keyCodes.ENTER || e.keyCode ===
                  keyCodes.SPACE) {
                this._domEvents(bemDom.doc).
                    un('keydown', this._onKeyDown).
                    on('keyup', this._onKeyUp);

                e.keyCode === keyCodes.SPACE && e.preventDefault();
                this._onItemClick(this._hoveredItem, {source: 'keyboard'});
              }
              this.__base.apply(this, arguments);
            },

            _onKeyUp: function() {
              this._domEvents(bemDom.doc).un('keyup', this._onKeyUp);
              // it could be unfocused while is key being pressed
              this.hasMod('focused') &&
              this._domEvents(bemDom.doc).on('keydown', this._onKeyDown);
            },

            /**
             * Returns menu value
             * @returns {*}
             */
            getVal: function() {
              if (!this._isValValid) {
                this._val = this._getVal();
                this._isValValid = true;
              }
              return this._val;
            },

            /**
             * @abstract
             * @protected
             * @returns {*}
             */
            _getVal: function() {
              throw Error('_getVal is not implemented');
            },

            /**
             * Sets menu value
             * @param {*} val
             * @returns {menu} this
             */
            setVal: function(val) {
              if (this._setVal(val)) {
                this._val = val;
                this._isValValid = true;
                this._emit('change');
              }
              return this;
            },

            /**
             * @abstract
             * @protected
             * @param {*} val
             * @returns {Boolean} returns true if value was changed
             */
            _setVal: function() {
              throw Error('_setVal is not implemented');
            },

            _updateItemsCheckedMod: function(modVals) {
              var items = this.getItems();
              modVals.forEach(function(modVal, i) {
                items.get(i).setMod('checked', modVal);
              });
            },

            /**
             * Sets content
             * @override
             */
            setContent: function() {
              var res = this.__base.apply(this, arguments);
              this._isValValid = false;
              this._emit('change'); // NOTE: potentially unwanted event could be emitted
              return res;
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/menu/_mode/menu_mode.js */
/* begin: ../../5th.blocks/common.blocks/carousel/carousel.js */
modules.define('carousel', ['i-bem-dom', 'carousel__item'],
    function(provide, bemDom, Carousel__item) {

      provide(bemDom.declBlock(this.name, {
        beforeSetMod: {
          'lib': {
            'destroyed': function() {
              return this.hasMod('lib', 'inited');
            },
          },
        },

        onSetMod: {
          'js': {
            'inited': function() {
              this._instance; // lib instance
              this._activeIndex = -1;

              this._events().
                  on('inited', this._onInited).
                  on('change', this._onChange).
                  on('destroy', this._onDestroy);
            },
          },

          'lib': {
            'destroyed': function() {
              this._destroy();
            },
          },
        },

        reinit: function() {
        },
        _destroy: function() {
        },

        _onDestroy: function(e) {
          console.log(e.type);
          this.setMod('lib', 'destroyed');
        },

        /**
         * @return {Number}
         */
        getSlidesCount: function() {
          return this._elems(Carousel__item).size();
        },

        /**
         * @param {Number} index
         * @return {Object} BEM element
         */
        getSlide: function(index) {
          return this._elems(Carousel__item).get(index);
        },

        /**
         * Carousel lib inited
         * @param {Object} e event
         * @param {Object} data event data
         * @param {Number} data.activeIndex active slide
         */
        _onInited: function(e, data) {
          this._activeIndex = data.activeIndex;
          this.setMod('lib', 'inited');
        },

        /**
         * Carousel lib change slide
         * @param {Object} e event
         * @param {Object} data event data
         * @param {Number} data.activeIndex active slide
         */
        _onChange: function(e, data) {
          this._activeIndex = data.activeIndex;
        },
      }));
    });

/* end: ../../5th.blocks/common.blocks/carousel/carousel.js */
/* begin: ../../5th.blocks/common.blocks/carousel/__item/carousel__item.js */
modules.define('carousel__item', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declElem('carousel', 'item', {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },
  }, {
    lazyInit: true,
  }));

});

/* end: ../../5th.blocks/common.blocks/carousel/__item/carousel__item.js */
/* begin: ../../5th.blocks/common.blocks/carousel/_type/carousel_type_slick.js */
modules.define('carousel', ['i-bem-dom', 'jquery__slick'],
    function(provide, bemDom, $, Carousel) {

      provide(Carousel.declMod({modName: 'type', modVal: 'slick'}, {
        onSetMod: {
          'js': {
            'inited': function() {
              this.__base.apply(this, arguments);

              this._$container = null;
              this._$slick = null;
              this._initCarousel();
            },
          },
        },

        _destroy: function() {
          this.__base.apply(this, arguments);
          this._$container.slick('unslick');
          console.log('destroy');
        },

        reinit: function() {
          console.log('reinit slick');
          this.setMod('lib', 'destroyed');
          this._initCarousel();
        },

        /**
         * @returns {Number} current slide index
         */
        getCurrentSlide: function() {
          return this._$container.slick('slickCurrentSlide');
        },

        /**
         * @return {Object}
         */
        _getSettings: function() {
          var settings = this.params.settings,
              domElem = this.domElem;

          if (settings.appendArrows)
            settings.appendArrows = domElem.find(settings.appendArrows);

          if (settings.appendDots)
            settings.appendDots = domElem.find(settings.appendDots);

          return settings;
        },

        _initCarousel: function() {
          console.log('_initCarousel');
          this._$container = this.params.container ?
              this.domElem.find(this.params.container) :
              this.domElem;

          this._instance = this._$container.on('init',
              this._onSlickInit.bind(this));

          this._$slick = this._$container.slick(this._getSettings());
          this._$slick = this._$slick.get(0).slick;
          this._$container.on('afterChange', this._afterSlickChange.bind(this));
          this._$container.on('beforeChange',
              this._beforeSlickChange.bind(this));
          this._$container.on('swipe', this._onSwipeSlick.bind(this));
          this._$container.on('destroy', this._onDestroySlick.bind(this));

          this._setThemeMods();
        },

        _setThemeMods: function() {
          this._$container.addClass(function() {
            var theme = this.getMod('theme'),
                view = this.getMod('view'),
                className = theme ? 'slick-slider_theme_' + theme : '';

            (className && view) && (className += ' slick-slider_view_' + view);

            return className;
          }.bind(this));
        },

        _onSlickInit: function(e, slick) {
          this._emit('inited', {
            activeIndex: slick.currentSlide,
          });
        },

        _onDestroySlick: function() {
          this._emit('destroy');
        },

        _onSwipeSlick: function(e, slick, direction) {

        },

        /**
         * @see https://github.com/kenwheeler/slick/
         */
        _afterSlickChange: function(e, slick, currentSlide) {
          this._emit('change', {
            activeIndex: currentSlide,
          });
        },

        /**
         * @see https://github.com/kenwheeler/slick/
         */
        _beforeSlickChange: function(e, slick, currentSlide, nextSlide) {

        },

        _play: function() {
          this._$container.slick('slickPlay');
        },

        _pause: function() {
          this._$container.slick('slickPause');
        },
      }));
    });

/* end: ../../5th.blocks/common.blocks/carousel/_type/carousel_type_slick.js */
/* begin: ../../5th.blocks/common.blocks/jquery/__slick/jquery__slick.js */
modules.define('jquery__slick', ['jquery'], function(provide, $) {

  window.jQuery = jQuery = $;

  /* ../../node_modules/slick-carousel/slick/slick.js begin */
  /*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.1
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
  /* global window, document, define, jQuery, setInterval, clearInterval */
  ;(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
      define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
      module.exports = factory(require('jquery'));
    } else {
      factory(jQuery);
    }

  }(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

      var instanceUid = 0;

      function Slick(element, settings) {

        var _ = this, dataSettings;

        _.defaults = {
          accessibility: true,
          adaptiveHeight: false,
          appendArrows: $(element),
          appendDots: $(element),
          arrows: true,
          asNavFor: null,
          prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
          nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
          autoplay: false,
          autoplaySpeed: 3000,
          centerMode: false,
          centerPadding: '50px',
          cssEase: 'ease',
          customPaging: function(slider, i) {
            return $('<button type="button" />').text(i + 1);
          },
          dots: false,
          dotsClass: 'slick-dots',
          draggable: true,
          easing: 'linear',
          edgeFriction: 0.35,
          fade: false,
          focusOnSelect: false,
          focusOnChange: false,
          infinite: true,
          initialSlide: 0,
          lazyLoad: 'ondemand',
          mobileFirst: false,
          pauseOnHover: true,
          pauseOnFocus: true,
          pauseOnDotsHover: false,
          respondTo: 'window',
          responsive: null,
          rows: 1,
          rtl: false,
          slide: '',
          slidesPerRow: 1,
          slidesToShow: 1,
          slidesToScroll: 1,
          speed: 500,
          swipe: true,
          swipeToSlide: false,
          touchMove: true,
          touchThreshold: 5,
          useCSS: true,
          useTransform: true,
          variableWidth: false,
          vertical: false,
          verticalSwiping: false,
          waitForAnimate: true,
          zIndex: 1000,
        };

        _.initials = {
          animating: false,
          dragging: false,
          autoPlayTimer: null,
          currentDirection: 0,
          currentLeft: null,
          currentSlide: 0,
          direction: 1,
          $dots: null,
          listWidth: null,
          listHeight: null,
          loadIndex: 0,
          $nextArrow: null,
          $prevArrow: null,
          scrolling: false,
          slideCount: null,
          slideWidth: null,
          $slideTrack: null,
          $slides: null,
          sliding: false,
          slideOffset: 0,
          swipeLeft: null,
          swiping: false,
          $list: null,
          touchObject: {},
          transformsEnabled: false,
          unslicked: false,
        };

        $.extend(_, _.initials);

        _.activeBreakpoint = null;
        _.animType = null;
        _.animProp = null;
        _.breakpoints = [];
        _.breakpointSettings = [];
        _.cssTransitions = false;
        _.focussed = false;
        _.interrupted = false;
        _.hidden = 'hidden';
        _.paused = true;
        _.positionProp = null;
        _.respondTo = null;
        _.rowCount = 1;
        _.shouldClick = true;
        _.$slider = $(element);
        _.$slidesCache = null;
        _.transformType = null;
        _.transitionType = null;
        _.visibilityChange = 'visibilitychange';
        _.windowWidth = 0;
        _.windowTimer = null;

        dataSettings = $(element).data('slick') || {};

        _.options = $.extend({}, _.defaults, settings, dataSettings);

        _.currentSlide = _.options.initialSlide;

        _.originalSettings = _.options;

        if (typeof document.mozHidden !== 'undefined') {
          _.hidden = 'mozHidden';
          _.visibilityChange = 'mozvisibilitychange';
        } else if (typeof document.webkitHidden !== 'undefined') {
          _.hidden = 'webkitHidden';
          _.visibilityChange = 'webkitvisibilitychange';
        }

        _.autoPlay = $.proxy(_.autoPlay, _);
        _.autoPlayClear = $.proxy(_.autoPlayClear, _);
        _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
        _.changeSlide = $.proxy(_.changeSlide, _);
        _.clickHandler = $.proxy(_.clickHandler, _);
        _.selectHandler = $.proxy(_.selectHandler, _);
        _.setPosition = $.proxy(_.setPosition, _);
        _.swipeHandler = $.proxy(_.swipeHandler, _);
        _.dragHandler = $.proxy(_.dragHandler, _);
        _.keyHandler = $.proxy(_.keyHandler, _);

        _.instanceUid = instanceUid++;

        // A simple way to check for HTML strings
        // Strict HTML recognition (must start with <)
        // Extracted from jQuery v1.11 source
        _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

        _.registerBreakpoints();
        _.init(true);

      }

      return Slick;

    }());

    Slick.prototype.activateADA = function() {
      var _ = this;

      _.$slideTrack.find('.slick-active').attr({
        'aria-hidden': 'false',
      }).find('a, input, button, select').attr({
        'tabindex': '0',
      });

    };

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(
        markup, index, addBefore) {

      var _ = this;

      if (typeof(index) === 'boolean') {
        addBefore = index;
        index = null;
      } else if (index < 0 || (index >= _.slideCount)) {
        return false;
      }

      _.unload();

      if (typeof(index) === 'number') {
        if (index === 0 && _.$slides.length === 0) {
          $(markup).appendTo(_.$slideTrack);
        } else if (addBefore) {
          $(markup).insertBefore(_.$slides.eq(index));
        } else {
          $(markup).insertAfter(_.$slides.eq(index));
        }
      } else {
        if (addBefore === true) {
          $(markup).prependTo(_.$slideTrack);
        } else {
          $(markup).appendTo(_.$slideTrack);
        }
      }

      _.$slides = _.$slideTrack.children(this.options.slide);

      _.$slideTrack.children(this.options.slide).detach();

      _.$slideTrack.append(_.$slides);

      _.$slides.each(function(index, element) {
        $(element).attr('data-slick-index', index);
      });

      _.$slidesCache = _.$slides;

      _.reinit();

    };

    Slick.prototype.animateHeight = function() {
      var _ = this;
      if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true &&
          _.options.vertical === false) {
        var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
        _.$list.animate({
          height: targetHeight,
        }, _.options.speed);
      }
    };

    Slick.prototype.animateSlide = function(targetLeft, callback) {

      var animProps = {},
          _ = this;

      _.animateHeight();

      if (_.options.rtl === true && _.options.vertical === false) {
        targetLeft = -targetLeft;
      }
      if (_.transformsEnabled === false) {
        if (_.options.vertical === false) {
          _.$slideTrack.animate({
            left: targetLeft,
          }, _.options.speed, _.options.easing, callback);
        } else {
          _.$slideTrack.animate({
            top: targetLeft,
          }, _.options.speed, _.options.easing, callback);
        }

      } else {

        if (_.cssTransitions === false) {
          if (_.options.rtl === true) {
            _.currentLeft = -(_.currentLeft);
          }
          $({
            animStart: _.currentLeft,
          }).animate({
            animStart: targetLeft,
          }, {
            duration: _.options.speed,
            easing: _.options.easing,
            step: function(now) {
              now = Math.ceil(now);
              if (_.options.vertical === false) {
                animProps[_.animType] = 'translate(' +
                    now + 'px, 0px)';
                _.$slideTrack.css(animProps);
              } else {
                animProps[_.animType] = 'translate(0px,' +
                    now + 'px)';
                _.$slideTrack.css(animProps);
              }
            },
            complete: function() {
              if (callback) {
                callback.call();
              }
            },
          });

        } else {

          _.applyTransition();
          targetLeft = Math.ceil(targetLeft);

          if (_.options.vertical === false) {
            animProps[_.animType] = 'translate3d(' + targetLeft +
                'px, 0px, 0px)';
          } else {
            animProps[_.animType] = 'translate3d(0px,' + targetLeft +
                'px, 0px)';
          }
          _.$slideTrack.css(animProps);

          if (callback) {
            setTimeout(function() {

              _.disableTransition();

              callback.call();
            }, _.options.speed);
          }

        }

      }

    };

    Slick.prototype.getNavTarget = function() {

      var _ = this,
          asNavFor = _.options.asNavFor;

      if (asNavFor && asNavFor !== null) {
        asNavFor = $(asNavFor).not(_.$slider);
      }

      return asNavFor;

    };

    Slick.prototype.asNavFor = function(index) {

      var _ = this,
          asNavFor = _.getNavTarget();

      if (asNavFor !== null && typeof asNavFor === 'object') {
        asNavFor.each(function() {
          var target = $(this).slick('getSlick');
          if (!target.unslicked) {
            target.slideHandler(index, true);
          }
        });
      }

    };

    Slick.prototype.applyTransition = function(slide) {

      var _ = this,
          transition = {};

      if (_.options.fade === false) {
        transition[_.transitionType] = _.transformType + ' ' + _.options.speed +
            'ms ' + _.options.cssEase;
      } else {
        transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' +
            _.options.cssEase;
      }

      if (_.options.fade === false) {
        _.$slideTrack.css(transition);
      } else {
        _.$slides.eq(slide).css(transition);
      }

    };

    Slick.prototype.autoPlay = function() {

      var _ = this;

      _.autoPlayClear();

      if (_.slideCount > _.options.slidesToShow) {
        _.autoPlayTimer = setInterval(_.autoPlayIterator,
            _.options.autoplaySpeed);
      }

    };

    Slick.prototype.autoPlayClear = function() {

      var _ = this;

      if (_.autoPlayTimer) {
        clearInterval(_.autoPlayTimer);
      }

    };

    Slick.prototype.autoPlayIterator = function() {

      var _ = this,
          slideTo = _.currentSlide + _.options.slidesToScroll;

      if (!_.paused && !_.interrupted && !_.focussed) {

        if (_.options.infinite === false) {

          if (_.direction === 1 && (_.currentSlide + 1) ===
              (_.slideCount - 1)) {
            _.direction = 0;
          }

          else if (_.direction === 0) {

            slideTo = _.currentSlide - _.options.slidesToScroll;

            if (_.currentSlide - 1 === 0) {
              _.direction = 1;
            }

          }

        }

        _.slideHandler(slideTo);

      }

    };

    Slick.prototype.buildArrows = function() {

      var _ = this;

      if (_.options.arrows === true) {

        _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
        _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

        if (_.slideCount > _.options.slidesToShow) {

          _.$prevArrow.removeClass('slick-hidden').
              removeAttr('aria-hidden tabindex');
          _.$nextArrow.removeClass('slick-hidden').
              removeAttr('aria-hidden tabindex');

          if (_.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.prependTo(_.options.appendArrows);
          }

          if (_.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.appendTo(_.options.appendArrows);
          }

          if (_.options.infinite !== true) {
            _.$prevArrow.addClass('slick-disabled').
                attr('aria-disabled', 'true');
          }

        } else {

          _.$prevArrow.add(_.$nextArrow).addClass('slick-hidden').attr({
            'aria-disabled': 'true',
            'tabindex': '-1',
          });

        }

      }

    };

    Slick.prototype.buildDots = function() {

      var _ = this,
          i, dot;

      if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

        _.$slider.addClass('slick-dotted');

        dot = $('<ul />').addClass(_.options.dotsClass);

        for (i = 0; i <= _.getDotCount(); i += 1) {
          dot.append(
              $('<li />').append(_.options.customPaging.call(this, _, i)));
        }

        _.$dots = dot.appendTo(_.options.appendDots);

        _.$dots.find('li').first().addClass('slick-active');

      }

    };

    Slick.prototype.buildOut = function() {

      var _ = this;

      _.$slides =
          _.$slider.children(_.options.slide + ':not(.slick-cloned)').
              addClass('slick-slide');

      _.slideCount = _.$slides.length;

      _.$slides.each(function(index, element) {
        $(element).
            attr('data-slick-index', index).
            data('originalStyling', $(element).attr('style') || '');
      });

      _.$slider.addClass('slick-slider');

      _.$slideTrack = (_.slideCount === 0) ?
          $('<div class="slick-track"/>').appendTo(_.$slider) :
          _.$slides.wrapAll('<div class="slick-track"/>').parent();

      _.$list = _.$slideTrack.wrap(
          '<div class="slick-list"/>').parent();
      _.$slideTrack.css('opacity', 0);

      if (_.options.centerMode === true || _.options.swipeToSlide === true) {
        _.options.slidesToScroll = 1;
      }

      $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

      _.setupInfinite();

      _.buildArrows();

      _.buildDots();

      _.updateDots();

      _.setSlideClasses(
          typeof _.currentSlide === 'number' ? _.currentSlide : 0);

      if (_.options.draggable === true) {
        _.$list.addClass('draggable');
      }

    };

    Slick.prototype.buildRows = function() {

      var _ = this, a, b, c, newSlides, numOfSlides, originalSlides,
          slidesPerSection;

      newSlides = document.createDocumentFragment();
      originalSlides = _.$slider.children();

      if (_.options.rows > 0) {

        slidesPerSection = _.options.slidesPerRow * _.options.rows;
        numOfSlides = Math.ceil(
            originalSlides.length / slidesPerSection,
        );

        for (a = 0; a < numOfSlides; a++) {
          var slide = document.createElement('div');
          for (b = 0; b < _.options.rows; b++) {
            var row = document.createElement('div');
            for (c = 0; c < _.options.slidesPerRow; c++) {
              var target = (a * slidesPerSection +
                  ((b * _.options.slidesPerRow) + c));
              if (originalSlides.get(target)) {
                row.appendChild(originalSlides.get(target));
              }
            }
            slide.appendChild(row);
          }
          newSlides.appendChild(slide);
        }

        _.$slider.empty().append(newSlides);
        _.$slider.children().children().children().css({
          'width': (100 / _.options.slidesPerRow) + '%',
          'display': 'inline-block',
        });

      }

    };

    Slick.prototype.checkResponsive = function(initial, forceUpdate) {

      var _ = this,
          breakpoint, targetBreakpoint, respondToWidth,
          triggerBreakpoint = false;
      var sliderWidth = _.$slider.width();
      var windowWidth = window.innerWidth || $(window).width();

      if (_.respondTo === 'window') {
        respondToWidth = windowWidth;
      } else if (_.respondTo === 'slider') {
        respondToWidth = sliderWidth;
      } else if (_.respondTo === 'min') {
        respondToWidth = Math.min(windowWidth, sliderWidth);
      }

      if (_.options.responsive &&
          _.options.responsive.length &&
          _.options.responsive !== null) {

        targetBreakpoint = null;

        for (breakpoint in _.breakpoints) {
          if (_.breakpoints.hasOwnProperty(breakpoint)) {
            if (_.originalSettings.mobileFirst === false) {
              if (respondToWidth < _.breakpoints[breakpoint]) {
                targetBreakpoint = _.breakpoints[breakpoint];
              }
            } else {
              if (respondToWidth > _.breakpoints[breakpoint]) {
                targetBreakpoint = _.breakpoints[breakpoint];
              }
            }
          }
        }

        if (targetBreakpoint !== null) {
          if (_.activeBreakpoint !== null) {
            if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
              _.activeBreakpoint =
                  targetBreakpoint;
              if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                _.unslick(targetBreakpoint);
              } else {
                _.options = $.extend({}, _.originalSettings,
                    _.breakpointSettings[
                        targetBreakpoint]);
                if (initial === true) {
                  _.currentSlide = _.options.initialSlide;
                }
                _.refresh(initial);
              }
              triggerBreakpoint = targetBreakpoint;
            }
          } else {
            _.activeBreakpoint = targetBreakpoint;
            if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
              _.unslick(targetBreakpoint);
            } else {
              _.options = $.extend({}, _.originalSettings,
                  _.breakpointSettings[
                      targetBreakpoint]);
              if (initial === true) {
                _.currentSlide = _.options.initialSlide;
              }
              _.refresh(initial);
            }
            triggerBreakpoint = targetBreakpoint;
          }
        } else {
          if (_.activeBreakpoint !== null) {
            _.activeBreakpoint = null;
            _.options = _.originalSettings;
            if (initial === true) {
              _.currentSlide = _.options.initialSlide;
            }
            _.refresh(initial);
            triggerBreakpoint = targetBreakpoint;
          }
        }

        // only trigger breakpoints during an actual break. not on initialize.
        if (!initial && triggerBreakpoint !== false) {
          _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
        }
      }

    };

    Slick.prototype.changeSlide = function(event, dontAnimate) {

      var _ = this,
          $target = $(event.currentTarget),
          indexOffset, slideOffset, unevenOffset;

      // If target is a link, prevent default action.
      if ($target.is('a')) {
        event.preventDefault();
      }

      // If target is not the <li> element (ie: a child), find the <li>.
      if (!$target.is('li')) {
        $target = $target.closest('li');
      }

      unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
      indexOffset = unevenOffset ?
          0 :
          (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

      switch (event.data.message) {

        case 'previous':
          slideOffset = indexOffset === 0 ?
              _.options.slidesToScroll :
              _.options.slidesToShow - indexOffset;
          if (_.slideCount > _.options.slidesToShow) {
            _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
          }
          break;

        case 'next':
          slideOffset = indexOffset === 0 ?
              _.options.slidesToScroll :
              indexOffset;
          if (_.slideCount > _.options.slidesToShow) {
            _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
          }
          break;

        case 'index':
          var index = event.data.index === 0 ? 0 :
              event.data.index || $target.index() * _.options.slidesToScroll;

          _.slideHandler(_.checkNavigable(index), false, dontAnimate);
          $target.children().trigger('focus');
          break;

        default:
          return;
      }

    };

    Slick.prototype.checkNavigable = function(index) {

      var _ = this,
          navigables, prevNavigable;

      navigables = _.getNavigableIndexes();
      prevNavigable = 0;
      if (index > navigables[navigables.length - 1]) {
        index = navigables[navigables.length - 1];
      } else {
        for (var n in navigables) {
          if (index < navigables[n]) {
            index = prevNavigable;
            break;
          }
          prevNavigable = navigables[n];
        }
      }

      return index;
    };

    Slick.prototype.cleanUpEvents = function() {

      var _ = this;

      if (_.options.dots && _.$dots !== null) {

        $('li', _.$dots).
            off('click.slick', _.changeSlide).
            off('mouseenter.slick', $.proxy(_.interrupt, _, true)).
            off('mouseleave.slick', $.proxy(_.interrupt, _, false));

        if (_.options.accessibility === true) {
          _.$dots.off('keydown.slick', _.keyHandler);
        }
      }

      _.$slider.off('focus.slick blur.slick');

      if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
        _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
        _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

        if (_.options.accessibility === true) {
          _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
          _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
        }
      }

      _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
      _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
      _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
      _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

      _.$list.off('click.slick', _.clickHandler);

      $(document).off(_.visibilityChange, _.visibility);

      _.cleanUpSlideEvents();

      if (_.options.accessibility === true) {
        _.$list.off('keydown.slick', _.keyHandler);
      }

      if (_.options.focusOnSelect === true) {
        $(_.$slideTrack).children().off('click.slick', _.selectHandler);
      }

      $(window).
          off('orientationchange.slick.slick-' + _.instanceUid,
              _.orientationChange);

      $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

      $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

      $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);

    };

    Slick.prototype.cleanUpSlideEvents = function() {

      var _ = this;

      _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
      _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

    };

    Slick.prototype.cleanUpRows = function() {

      var _ = this, originalSlides;

      if (_.options.rows > 0) {
        originalSlides = _.$slides.children().children();
        originalSlides.removeAttr('style');
        _.$slider.empty().append(originalSlides);
      }

    };

    Slick.prototype.clickHandler = function(event) {

      var _ = this;

      if (_.shouldClick === false) {
        event.stopImmediatePropagation();
        event.stopPropagation();
        event.preventDefault();
      }

    };

    Slick.prototype.destroy = function(refresh) {

      var _ = this;

      _.autoPlayClear();

      _.touchObject = {};

      _.cleanUpEvents();

      $('.slick-cloned', _.$slider).detach();

      if (_.$dots) {
        _.$dots.remove();
      }

      if (_.$prevArrow && _.$prevArrow.length) {

        _.$prevArrow.removeClass('slick-disabled slick-arrow slick-hidden').
            removeAttr('aria-hidden aria-disabled tabindex').
            css('display', '');

        if (_.htmlExpr.test(_.options.prevArrow)) {
          _.$prevArrow.remove();
        }
      }

      if (_.$nextArrow && _.$nextArrow.length) {

        _.$nextArrow.removeClass('slick-disabled slick-arrow slick-hidden').
            removeAttr('aria-hidden aria-disabled tabindex').
            css('display', '');

        if (_.htmlExpr.test(_.options.nextArrow)) {
          _.$nextArrow.remove();
        }
      }

      if (_.$slides) {

        _.$slides.removeClass(
            'slick-slide slick-active slick-center slick-visible slick-current').
            removeAttr('aria-hidden').
            removeAttr('data-slick-index').
            each(function() {
              $(this).attr('style', $(this).data('originalStyling'));
            });

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.detach();

        _.$list.detach();

        _.$slider.append(_.$slides);
      }

      _.cleanUpRows();

      _.$slider.removeClass('slick-slider');
      _.$slider.removeClass('slick-initialized');
      _.$slider.removeClass('slick-dotted');

      _.unslicked = true;

      if (!refresh) {
        _.$slider.trigger('destroy', [_]);
      }

    };

    Slick.prototype.disableTransition = function(slide) {

      var _ = this,
          transition = {};

      transition[_.transitionType] = '';

      if (_.options.fade === false) {
        _.$slideTrack.css(transition);
      } else {
        _.$slides.eq(slide).css(transition);
      }

    };

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

      var _ = this;

      if (_.cssTransitions === false) {

        _.$slides.eq(slideIndex).css({
          zIndex: _.options.zIndex,
        });

        _.$slides.eq(slideIndex).animate({
          opacity: 1,
        }, _.options.speed, _.options.easing, callback);

      } else {

        _.applyTransition(slideIndex);

        _.$slides.eq(slideIndex).css({
          opacity: 1,
          zIndex: _.options.zIndex,
        });

        if (callback) {
          setTimeout(function() {

            _.disableTransition(slideIndex);

            callback.call();
          }, _.options.speed);
        }

      }

    };

    Slick.prototype.fadeSlideOut = function(slideIndex) {

      var _ = this;

      if (_.cssTransitions === false) {

        _.$slides.eq(slideIndex).animate({
          opacity: 0,
          zIndex: _.options.zIndex - 2,
        }, _.options.speed, _.options.easing);

      } else {

        _.applyTransition(slideIndex);

        _.$slides.eq(slideIndex).css({
          opacity: 0,
          zIndex: _.options.zIndex - 2,
        });

      }

    };

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

      var _ = this;

      if (filter !== null) {

        _.$slidesCache = _.$slides;

        _.unload();

        _.$slideTrack.children(this.options.slide).detach();

        _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

        _.reinit();

      }

    };

    Slick.prototype.focusHandler = function() {

      var _ = this;

      _.$slider.off('focus.slick blur.slick').
          on('focus.slick blur.slick', '*', function(event) {

            event.stopImmediatePropagation();
            var $sf = $(this);

            setTimeout(function() {

              if (_.options.pauseOnFocus) {
                _.focussed = $sf.is(':focus');
                _.autoPlay();
              }

            }, 0);

          });
    };

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

      var _ = this;
      return _.currentSlide;

    };

    Slick.prototype.getDotCount = function() {

      var _ = this;

      var breakPoint = 0;
      var counter = 0;
      var pagerQty = 0;

      if (_.options.infinite === true) {
        if (_.slideCount <= _.options.slidesToShow) {
          ++pagerQty;
        } else {
          while (breakPoint < _.slideCount) {
            ++pagerQty;
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ?
                _.options.slidesToScroll :
                _.options.slidesToShow;
          }
        }
      } else if (_.options.centerMode === true) {
        pagerQty = _.slideCount;
      } else if (!_.options.asNavFor) {
        pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) /
            _.options.slidesToScroll);
      } else {
        while (breakPoint < _.slideCount) {
          ++pagerQty;
          breakPoint = counter + _.options.slidesToScroll;
          counter += _.options.slidesToScroll <= _.options.slidesToShow ?
              _.options.slidesToScroll :
              _.options.slidesToShow;
        }
      }

      return pagerQty - 1;

    };

    Slick.prototype.getLeft = function(slideIndex) {

      var _ = this,
          targetLeft,
          verticalHeight,
          verticalOffset = 0,
          targetSlide,
          coef;

      _.slideOffset = 0;
      verticalHeight = _.$slides.first().outerHeight(true);

      if (_.options.infinite === true) {
        if (_.slideCount > _.options.slidesToShow) {
          _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
          coef = -1;

          if (_.options.vertical === true && _.options.centerMode === true) {
            if (_.options.slidesToShow === 2) {
              coef = -1.5;
            } else if (_.options.slidesToShow === 1) {
              coef = -2;
            }
          }
          verticalOffset = (verticalHeight * _.options.slidesToShow) * coef;
        }
        if (_.slideCount % _.options.slidesToScroll !== 0) {
          if (slideIndex + _.options.slidesToScroll > _.slideCount &&
              _.slideCount > _.options.slidesToShow) {
            if (slideIndex > _.slideCount) {
              _.slideOffset = ((_.options.slidesToShow -
                  (slideIndex - _.slideCount)) * _.slideWidth) * -1;
              verticalOffset = ((_.options.slidesToShow -
                  (slideIndex - _.slideCount)) * verticalHeight) * -1;
            } else {
              _.slideOffset = ((_.slideCount % _.options.slidesToScroll) *
                  _.slideWidth) * -1;
              verticalOffset = ((_.slideCount % _.options.slidesToScroll) *
                  verticalHeight) * -1;
            }
          }
        }
      } else {
        if (slideIndex + _.options.slidesToShow > _.slideCount) {
          _.slideOffset = ((slideIndex + _.options.slidesToShow) -
              _.slideCount) * _.slideWidth;
          verticalOffset = ((slideIndex + _.options.slidesToShow) -
              _.slideCount) * verticalHeight;
        }
      }

      if (_.slideCount <= _.options.slidesToShow) {
        _.slideOffset = 0;
        verticalOffset = 0;
      }

      if (_.options.centerMode === true && _.slideCount <=
          _.options.slidesToShow) {
        _.slideOffset = ((_.slideWidth * Math.floor(_.options.slidesToShow)) /
            2) - ((_.slideWidth * _.slideCount) / 2);
      } else if (_.options.centerMode === true && _.options.infinite === true) {
        _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) -
            _.slideWidth;
      } else if (_.options.centerMode === true) {
        _.slideOffset = 0;
        _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
      }

      if (_.options.vertical === false) {
        targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
      } else {
        targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
      }

      if (_.options.variableWidth === true) {

        if (_.slideCount <= _.options.slidesToShow || _.options.infinite ===
            false) {
          targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
        } else {
          targetSlide = _.$slideTrack.children('.slick-slide').
              eq(slideIndex + _.options.slidesToShow);
        }

        if (_.options.rtl === true) {
          if (targetSlide[0]) {
            targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft -
                targetSlide.width()) * -1;
          } else {
            targetLeft = 0;
          }
        } else {
          targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
        }

        if (_.options.centerMode === true) {
          if (_.slideCount <= _.options.slidesToShow || _.options.infinite ===
              false) {
            targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
          } else {
            targetSlide = _.$slideTrack.children('.slick-slide').
                eq(slideIndex + _.options.slidesToShow + 1);
          }

          if (_.options.rtl === true) {
            if (targetSlide[0]) {
              targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft -
                  targetSlide.width()) * -1;
            } else {
              targetLeft = 0;
            }
          } else {
            targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
          }

          targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
        }
      }

      return targetLeft;

    };

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

      var _ = this;

      return _.options[option];

    };

    Slick.prototype.getNavigableIndexes = function() {

      var _ = this,
          breakPoint = 0,
          counter = 0,
          indexes = [],
          max;

      if (_.options.infinite === false) {
        max = _.slideCount;
      } else {
        breakPoint = _.options.slidesToScroll * -1;
        counter = _.options.slidesToScroll * -1;
        max = _.slideCount * 2;
      }

      while (breakPoint < max) {
        indexes.push(breakPoint);
        breakPoint = counter + _.options.slidesToScroll;
        counter += _.options.slidesToScroll <= _.options.slidesToShow ?
            _.options.slidesToScroll :
            _.options.slidesToShow;
      }

      return indexes;

    };

    Slick.prototype.getSlick = function() {

      return this;

    };

    Slick.prototype.getSlideCount = function() {

      var _ = this,
          slidesTraversed, swipedSlide, centerOffset;

      centerOffset = _.options.centerMode === true ?
          _.slideWidth * Math.floor(_.options.slidesToShow / 2) :
          0;

      if (_.options.swipeToSlide === true) {
        _.$slideTrack.find('.slick-slide').each(function(index, slide) {
          if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) >
              (_.swipeLeft * -1)) {
            swipedSlide = slide;
            return false;
          }
        });

        slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') -
            _.currentSlide) || 1;

        return slidesTraversed;

      } else {
        return _.options.slidesToScroll;
      }

    };

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(
        slide, dontAnimate) {

      var _ = this;

      _.changeSlide({
        data: {
          message: 'index',
          index: parseInt(slide),
        },
      }, dontAnimate);

    };

    Slick.prototype.init = function(creation) {

      var _ = this;

      if (!$(_.$slider).hasClass('slick-initialized')) {

        $(_.$slider).addClass('slick-initialized');

        _.buildRows();
        _.buildOut();
        _.setProps();
        _.startLoad();
        _.loadSlider();
        _.initializeEvents();
        _.updateArrows();
        _.updateDots();
        _.checkResponsive(true);
        _.focusHandler();

      }

      if (creation) {
        _.$slider.trigger('init', [_]);
      }

      if (_.options.accessibility === true) {
        _.initADA();
      }

      if (_.options.autoplay) {

        _.paused = false;
        _.autoPlay();

      }

    };

    Slick.prototype.initADA = function() {
      var _ = this,
          numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
          tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
            return (val >= 0) && (val < _.slideCount);
          });

      _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
        'aria-hidden': 'true',
        'tabindex': '-1',
      }).find('a, input, button, select').attr({
        'tabindex': '-1',
      });

      if (_.$dots !== null) {
        _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
          var slideControlIndex = tabControlIndexes.indexOf(i);

          $(this).attr({
            'role': 'tabpanel',
            'id': 'slick-slide' + _.instanceUid + i,
            'tabindex': -1,
          });

          if (slideControlIndex !== -1) {
            var ariaButtonControl = 'slick-slide-control' + _.instanceUid +
                slideControlIndex;
            if ($('#' + ariaButtonControl).length) {
              $(this).attr({
                'aria-describedby': ariaButtonControl,
              });
            }
          }
        });

        _.$dots.attr('role', 'tablist').find('li').each(function(i) {
          var mappedSlideIndex = tabControlIndexes[i];

          $(this).attr({
            'role': 'presentation',
          });

          $(this).find('button').first().attr({
            'role': 'tab',
            'id': 'slick-slide-control' + _.instanceUid + i,
            'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
            'aria-label': (i + 1) + ' of ' + numDotGroups,
            'aria-selected': null,
            'tabindex': '-1',
          });

        }).eq(_.currentSlide).find('button').attr({
          'aria-selected': 'true',
          'tabindex': '0',
        }).end();
      }

      for (var i = _.currentSlide, max = i + _.options.slidesToShow; i <
      max; i++) {
        if (_.options.focusOnChange) {
          _.$slides.eq(i).attr({'tabindex': '0'});
        } else {
          _.$slides.eq(i).removeAttr('tabindex');
        }
      }

      _.activateADA();

    };

    Slick.prototype.initArrowEvents = function() {

      var _ = this;

      if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
        _.$prevArrow.off('click.slick').on('click.slick', {
          message: 'previous',
        }, _.changeSlide);
        _.$nextArrow.off('click.slick').on('click.slick', {
          message: 'next',
        }, _.changeSlide);

        if (_.options.accessibility === true) {
          _.$prevArrow.on('keydown.slick', _.keyHandler);
          _.$nextArrow.on('keydown.slick', _.keyHandler);
        }
      }

    };

    Slick.prototype.initDotEvents = function() {

      var _ = this;

      if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
        $('li', _.$dots).on('click.slick', {
          message: 'index',
        }, _.changeSlide);

        if (_.options.accessibility === true) {
          _.$dots.on('keydown.slick', _.keyHandler);
        }
      }

      if (_.options.dots === true && _.options.pauseOnDotsHover === true &&
          _.slideCount > _.options.slidesToShow) {

        $('li', _.$dots).
            on('mouseenter.slick', $.proxy(_.interrupt, _, true)).
            on('mouseleave.slick', $.proxy(_.interrupt, _, false));

      }

    };

    Slick.prototype.initSlideEvents = function() {

      var _ = this;

      if (_.options.pauseOnHover) {

        _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

      }

    };

    Slick.prototype.initializeEvents = function() {

      var _ = this;

      _.initArrowEvents();

      _.initDotEvents();
      _.initSlideEvents();

      _.$list.on('touchstart.slick mousedown.slick', {
        action: 'start',
      }, _.swipeHandler);
      _.$list.on('touchmove.slick mousemove.slick', {
        action: 'move',
      }, _.swipeHandler);
      _.$list.on('touchend.slick mouseup.slick', {
        action: 'end',
      }, _.swipeHandler);
      _.$list.on('touchcancel.slick mouseleave.slick', {
        action: 'end',
      }, _.swipeHandler);

      _.$list.on('click.slick', _.clickHandler);

      $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

      if (_.options.accessibility === true) {
        _.$list.on('keydown.slick', _.keyHandler);
      }

      if (_.options.focusOnSelect === true) {
        $(_.$slideTrack).children().on('click.slick', _.selectHandler);
      }

      $(window).
          on('orientationchange.slick.slick-' + _.instanceUid,
              $.proxy(_.orientationChange, _));

      $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

      $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

      $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
      $(_.setPosition);

    };

    Slick.prototype.initUI = function() {

      var _ = this;

      if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

        _.$prevArrow.show();
        _.$nextArrow.show();

      }

      if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

        _.$dots.show();

      }

    };

    Slick.prototype.keyHandler = function(event) {

      var _ = this;
      //Dont slide if the cursor is inside the form fields and arrow keys are pressed
      if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
        if (event.keyCode === 37 && _.options.accessibility === true) {
          _.changeSlide({
            data: {
              message: _.options.rtl === true ? 'next' : 'previous',
            },
          });
        } else if (event.keyCode === 39 && _.options.accessibility === true) {
          _.changeSlide({
            data: {
              message: _.options.rtl === true ? 'previous' : 'next',
            },
          });
        }
      }

    };

    Slick.prototype.lazyLoad = function() {

      var _ = this,
          loadRange, cloneRange, rangeStart, rangeEnd;

      function loadImages(imagesScope) {

        $('img[data-lazy]', imagesScope).each(function() {

          var image = $(this),
              imageSource = $(this).attr('data-lazy'),
              imageSrcSet = $(this).attr('data-srcset'),
              imageSizes = $(this).attr('data-sizes') ||
                  _.$slider.attr('data-sizes'),
              imageToLoad = document.createElement('img');

          imageToLoad.onload = function() {

            image.animate({opacity: 0}, 100, function() {

              if (imageSrcSet) {
                image.attr('srcset', imageSrcSet);

                if (imageSizes) {
                  image.attr('sizes', imageSizes);
                }
              }

              image.attr('src', imageSource).
                  animate({opacity: 1}, 200, function() {
                    image.removeAttr('data-lazy data-srcset data-sizes').
                        removeClass('slick-loading');
                  });
              _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
            });

          };

          imageToLoad.onerror = function() {

            image.removeAttr('data-lazy').
                removeClass('slick-loading').
                addClass('slick-lazyload-error');

            _.$slider.trigger('lazyLoadError', [_, image, imageSource]);

          };

          imageToLoad.src = imageSource;

        });

      }

      if (_.options.centerMode === true) {
        if (_.options.infinite === true) {
          rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
          rangeEnd = rangeStart + _.options.slidesToShow + 2;
        } else {
          rangeStart = Math.max(0, _.currentSlide -
              (_.options.slidesToShow / 2 + 1));
          rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
        }
      } else {
        rangeStart = _.options.infinite ?
            _.options.slidesToShow + _.currentSlide :
            _.currentSlide;
        rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
        if (_.options.fade === true) {
          if (rangeStart > 0) rangeStart--;
          if (rangeEnd <= _.slideCount) rangeEnd++;
        }
      }

      loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

      if (_.options.lazyLoad === 'anticipated') {
        var prevSlide = rangeStart - 1,
            nextSlide = rangeEnd,
            $slides = _.$slider.find('.slick-slide');

        for (var i = 0; i < _.options.slidesToScroll; i++) {
          if (prevSlide < 0) prevSlide = _.slideCount - 1;
          loadRange = loadRange.add($slides.eq(prevSlide));
          loadRange = loadRange.add($slides.eq(nextSlide));
          prevSlide--;
          nextSlide++;
        }
      }

      loadImages(loadRange);

      if (_.slideCount <= _.options.slidesToShow) {
        cloneRange = _.$slider.find('.slick-slide');
        loadImages(cloneRange);
      } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
        cloneRange = _.$slider.find('.slick-cloned').
            slice(0, _.options.slidesToShow);
        loadImages(cloneRange);
      } else if (_.currentSlide === 0) {
        cloneRange = _.$slider.find('.slick-cloned').
            slice(_.options.slidesToShow * -1);
        loadImages(cloneRange);
      }

    };

    Slick.prototype.loadSlider = function() {

      var _ = this;

      _.setPosition();

      _.$slideTrack.css({
        opacity: 1,
      });

      _.$slider.removeClass('slick-loading');

      _.initUI();

      if (_.options.lazyLoad === 'progressive') {
        _.progressiveLazyLoad();
      }

    };

    Slick.prototype.next = Slick.prototype.slickNext = function() {

      var _ = this;

      _.changeSlide({
        data: {
          message: 'next',
        },
      });

    };

    Slick.prototype.orientationChange = function() {

      var _ = this;

      _.checkResponsive();
      _.setPosition();

    };

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

      var _ = this;

      _.autoPlayClear();
      _.paused = true;

    };

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

      var _ = this;

      _.autoPlay();
      _.options.autoplay = true;
      _.paused = false;
      _.focussed = false;
      _.interrupted = false;

    };

    Slick.prototype.postSlide = function(index) {

      var _ = this;

      if (!_.unslicked) {

        _.$slider.trigger('afterChange', [_, index]);

        _.animating = false;

        if (_.slideCount > _.options.slidesToShow) {
          _.setPosition();
        }

        _.swipeLeft = null;

        if (_.options.autoplay) {
          _.autoPlay();
        }

        if (_.options.accessibility === true) {
          _.initADA();

          if (_.options.focusOnChange) {
            var $currentSlide = $(_.$slides.get(_.currentSlide));
            $currentSlide.attr('tabindex', 0).focus();
          }
        }

      }

    };

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

      var _ = this;

      _.changeSlide({
        data: {
          message: 'previous',
        },
      });

    };

    Slick.prototype.preventDefault = function(event) {

      event.preventDefault();

    };

    Slick.prototype.progressiveLazyLoad = function(tryCount) {

      tryCount = tryCount || 1;

      var _ = this,
          $imgsToLoad = $('img[data-lazy]', _.$slider),
          image,
          imageSource,
          imageSrcSet,
          imageSizes,
          imageToLoad;

      if ($imgsToLoad.length) {

        image = $imgsToLoad.first();
        imageSource = image.attr('data-lazy');
        imageSrcSet = image.attr('data-srcset');
        imageSizes = image.attr('data-sizes') || _.$slider.attr('data-sizes');
        imageToLoad = document.createElement('img');

        imageToLoad.onload = function() {

          if (imageSrcSet) {
            image.attr('srcset', imageSrcSet);

            if (imageSizes) {
              image.attr('sizes', imageSizes);
            }
          }

          image.attr('src', imageSource).
              removeAttr('data-lazy data-srcset data-sizes').
              removeClass('slick-loading');

          if (_.options.adaptiveHeight === true) {
            _.setPosition();
          }

          _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
          _.progressiveLazyLoad();

        };

        imageToLoad.onerror = function() {

          if (tryCount < 3) {

            /**
             * try to load the image 3 times,
             * leave a slight delay so we don't get
             * servers blocking the request.
             */
            setTimeout(function() {
              _.progressiveLazyLoad(tryCount + 1);
            }, 500);

          } else {

            image.removeAttr('data-lazy').
                removeClass('slick-loading').
                addClass('slick-lazyload-error');

            _.$slider.trigger('lazyLoadError', [_, image, imageSource]);

            _.progressiveLazyLoad();

          }

        };

        imageToLoad.src = imageSource;

      } else {

        _.$slider.trigger('allImagesLoaded', [_]);

      }

    };

    Slick.prototype.refresh = function(initializing) {

      var _ = this, currentSlide, lastVisibleIndex;

      lastVisibleIndex = _.slideCount - _.options.slidesToShow;

      // in non-infinite sliders, we don't want to go past the
      // last visible index.
      if (!_.options.infinite && (_.currentSlide > lastVisibleIndex)) {
        _.currentSlide = lastVisibleIndex;
      }

      // if less slides than to show, go to start.
      if (_.slideCount <= _.options.slidesToShow) {
        _.currentSlide = 0;

      }

      currentSlide = _.currentSlide;

      _.destroy(true);

      $.extend(_, _.initials, {currentSlide: currentSlide});

      _.init();

      if (!initializing) {

        _.changeSlide({
          data: {
            message: 'index',
            index: currentSlide,
          },
        }, false);

      }

    };

    Slick.prototype.registerBreakpoints = function() {

      var _ = this, breakpoint, currentBreakpoint, l,
          responsiveSettings = _.options.responsive || null;

      if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {

        _.respondTo = _.options.respondTo || 'window';

        for (breakpoint in responsiveSettings) {

          l = _.breakpoints.length - 1;

          if (responsiveSettings.hasOwnProperty(breakpoint)) {
            currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

            // loop through the breakpoints and cut out any existing
            // ones with the same breakpoint number, we don't want dupes.
            while (l >= 0) {
              if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
                _.breakpoints.splice(l, 1);
              }
              l--;
            }

            _.breakpoints.push(currentBreakpoint);
            _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

          }

        }

        _.breakpoints.sort(function(a, b) {
          return (_.options.mobileFirst) ? a - b : b - a;
        });

      }

    };

    Slick.prototype.reinit = function() {

      var _ = this;

      _.$slides =
          _.$slideTrack.children(_.options.slide).addClass('slick-slide');

      _.slideCount = _.$slides.length;

      if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
        _.currentSlide = _.currentSlide - _.options.slidesToScroll;
      }

      if (_.slideCount <= _.options.slidesToShow) {
        _.currentSlide = 0;
      }

      _.registerBreakpoints();

      _.setProps();
      _.setupInfinite();
      _.buildArrows();
      _.updateArrows();
      _.initArrowEvents();
      _.buildDots();
      _.updateDots();
      _.initDotEvents();
      _.cleanUpSlideEvents();
      _.initSlideEvents();

      _.checkResponsive(false, true);

      if (_.options.focusOnSelect === true) {
        $(_.$slideTrack).children().on('click.slick', _.selectHandler);
      }

      _.setSlideClasses(
          typeof _.currentSlide === 'number' ? _.currentSlide : 0);

      _.setPosition();
      _.focusHandler();

      _.paused = !_.options.autoplay;
      _.autoPlay();

      _.$slider.trigger('reInit', [_]);

    };

    Slick.prototype.resize = function() {

      var _ = this;

      if ($(window).width() !== _.windowWidth) {
        clearTimeout(_.windowDelay);
        _.windowDelay = window.setTimeout(function() {
          _.windowWidth = $(window).width();
          _.checkResponsive();
          if (!_.unslicked) {
            _.setPosition();
          }
        }, 50);
      }
    };

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(
        index, removeBefore, removeAll) {

      var _ = this;

      if (typeof(index) === 'boolean') {
        removeBefore = index;
        index = removeBefore === true ? 0 : _.slideCount - 1;
      } else {
        index = removeBefore === true ? --index : index;
      }

      if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
        return false;
      }

      _.unload();

      if (removeAll === true) {
        _.$slideTrack.children().remove();
      } else {
        _.$slideTrack.children(this.options.slide).eq(index).remove();
      }

      _.$slides = _.$slideTrack.children(this.options.slide);

      _.$slideTrack.children(this.options.slide).detach();

      _.$slideTrack.append(_.$slides);

      _.$slidesCache = _.$slides;

      _.reinit();

    };

    Slick.prototype.setCSS = function(position) {

      var _ = this,
          positionProps = {},
          x, y;

      if (_.options.rtl === true) {
        position = -position;
      }
      x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
      y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

      positionProps[_.positionProp] = position;

      if (_.transformsEnabled === false) {
        _.$slideTrack.css(positionProps);
      } else {
        positionProps = {};
        if (_.cssTransitions === false) {
          positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
          _.$slideTrack.css(positionProps);
        } else {
          positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
          _.$slideTrack.css(positionProps);
        }
      }

    };

    Slick.prototype.setDimensions = function() {

      var _ = this;

      if (_.options.vertical === false) {
        if (_.options.centerMode === true) {
          _.$list.css({
            padding: ('0px ' + _.options.centerPadding),
          });
        }
      } else {
        _.$list.height(_.$slides.first().outerHeight(true) *
            _.options.slidesToShow);
        if (_.options.centerMode === true) {
          _.$list.css({
            padding: (_.options.centerPadding + ' 0px'),
          });
        }
      }

      _.listWidth = _.$list.width();
      _.listHeight = _.$list.height();

      if (_.options.vertical === false && _.options.variableWidth === false) {
        _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
        _.$slideTrack.width(Math.ceil(
            (_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

      } else if (_.options.variableWidth === true) {
        _.$slideTrack.width(5000 * _.slideCount);
      } else {
        _.slideWidth = Math.ceil(_.listWidth);
        _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) *
            _.$slideTrack.children('.slick-slide').length)));
      }

      var offset = _.$slides.first().outerWidth(true) -
          _.$slides.first().width();
      if (_.options.variableWidth === false) _.$slideTrack.children(
          '.slick-slide').width(_.slideWidth - offset);

    };

    Slick.prototype.setFade = function() {

      var _ = this,
          targetLeft;

      _.$slides.each(function(index, element) {
        targetLeft = (_.slideWidth * index) * -1;
        if (_.options.rtl === true) {
          $(element).css({
            position: 'relative',
            right: targetLeft,
            top: 0,
            zIndex: _.options.zIndex - 2,
            opacity: 0,
          });
        } else {
          $(element).css({
            position: 'relative',
            left: targetLeft,
            top: 0,
            zIndex: _.options.zIndex - 2,
            opacity: 0,
          });
        }
      });

      _.$slides.eq(_.currentSlide).css({
        zIndex: _.options.zIndex - 1,
        opacity: 1,
      });

    };

    Slick.prototype.setHeight = function() {

      var _ = this;

      if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true &&
          _.options.vertical === false) {
        var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
        _.$list.css('height', targetHeight);
      }

    };

    Slick.prototype.setOption =
        Slick.prototype.slickSetOption = function() {

          /**
           * accepts arguments in format of:
           *
           *  - for changing a single option's value:
           *     .slick("setOption", option, value, refresh )
           *
           *  - for changing a set of responsive options:
           *     .slick("setOption", 'responsive', [{}, ...], refresh )
           *
           *  - for updating multiple values at once (not responsive)
           *     .slick("setOption", { 'option': value, ... }, refresh )
           */

          var _ = this, l, item, option, value, refresh = false, type;

          if ($.type(arguments[0]) === 'object') {

            option = arguments[0];
            refresh = arguments[1];
            type = 'multiple';

          } else if ($.type(arguments[0]) === 'string') {

            option = arguments[0];
            value = arguments[1];
            refresh = arguments[2];

            if (arguments[0] === 'responsive' && $.type(arguments[1]) ===
                'array') {

              type = 'responsive';

            } else if (typeof arguments[1] !== 'undefined') {

              type = 'single';

            }

          }

          if (type === 'single') {

            _.options[option] = value;

          } else if (type === 'multiple') {

            $.each(option, function(opt, val) {

              _.options[opt] = val;

            });

          } else if (type === 'responsive') {

            for (item in value) {

              if ($.type(_.options.responsive) !== 'array') {

                _.options.responsive = [value[item]];

              } else {

                l = _.options.responsive.length - 1;

                // loop through the responsive object and splice out duplicates.
                while (l >= 0) {

                  if (_.options.responsive[l].breakpoint ===
                      value[item].breakpoint) {

                    _.options.responsive.splice(l, 1);

                  }

                  l--;

                }

                _.options.responsive.push(value[item]);

              }

            }

          }

          if (refresh) {

            _.unload();
            _.reinit();

          }

        };

    Slick.prototype.setPosition = function() {

      var _ = this;

      _.setDimensions();

      _.setHeight();

      if (_.options.fade === false) {
        _.setCSS(_.getLeft(_.currentSlide));
      } else {
        _.setFade();
      }

      _.$slider.trigger('setPosition', [_]);

    };

    Slick.prototype.setProps = function() {

      var _ = this,
          bodyStyle = document.body.style;

      _.positionProp = _.options.vertical === true ? 'top' : 'left';

      if (_.positionProp === 'top') {
        _.$slider.addClass('slick-vertical');
      } else {
        _.$slider.removeClass('slick-vertical');
      }

      if (bodyStyle.WebkitTransition !== undefined ||
          bodyStyle.MozTransition !== undefined ||
          bodyStyle.msTransition !== undefined) {
        if (_.options.useCSS === true) {
          _.cssTransitions = true;
        }
      }

      if (_.options.fade) {
        if (typeof _.options.zIndex === 'number') {
          if (_.options.zIndex < 3) {
            _.options.zIndex = 3;
          }
        } else {
          _.options.zIndex = _.defaults.zIndex;
        }
      }

      if (bodyStyle.OTransform !== undefined) {
        _.animType = 'OTransform';
        _.transformType = '-o-transform';
        _.transitionType = 'OTransition';
        if (bodyStyle.perspectiveProperty === undefined &&
            bodyStyle.webkitPerspective === undefined) _.animType = false;
      }
      if (bodyStyle.MozTransform !== undefined) {
        _.animType = 'MozTransform';
        _.transformType = '-moz-transform';
        _.transitionType = 'MozTransition';
        if (bodyStyle.perspectiveProperty === undefined &&
            bodyStyle.MozPerspective === undefined) _.animType = false;
      }
      if (bodyStyle.webkitTransform !== undefined) {
        _.animType = 'webkitTransform';
        _.transformType = '-webkit-transform';
        _.transitionType = 'webkitTransition';
        if (bodyStyle.perspectiveProperty === undefined &&
            bodyStyle.webkitPerspective === undefined) _.animType = false;
      }
      if (bodyStyle.msTransform !== undefined) {
        _.animType = 'msTransform';
        _.transformType = '-ms-transform';
        _.transitionType = 'msTransition';
        if (bodyStyle.msTransform === undefined) _.animType = false;
      }
      if (bodyStyle.transform !== undefined && _.animType !== false) {
        _.animType = 'transform';
        _.transformType = 'transform';
        _.transitionType = 'transition';
      }
      _.transformsEnabled = _.options.useTransform &&
          (_.animType !== null && _.animType !== false);
    };

    Slick.prototype.setSlideClasses = function(index) {

      var _ = this,
          centerOffset, allSlides, indexOffset, remainder;

      allSlides = _.$slider.find('.slick-slide').
          removeClass('slick-active slick-center slick-current').
          attr('aria-hidden', 'true');

      _.$slides.eq(index).addClass('slick-current');

      if (_.options.centerMode === true) {

        var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if (_.options.infinite === true) {

          if (index >= centerOffset && index <= (_.slideCount - 1) -
              centerOffset) {
            _.$slides.slice(index - centerOffset + evenCoef, index +
                centerOffset + 1).
                addClass('slick-active').
                attr('aria-hidden', 'false');

          } else {

            indexOffset = _.options.slidesToShow + index;
            allSlides.slice(indexOffset - centerOffset + 1 +
                evenCoef, indexOffset + centerOffset + 2).
                addClass('slick-active').
                attr('aria-hidden', 'false');

          }

          if (index === 0) {

            allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).
                addClass('slick-center');

          } else if (index === _.slideCount - 1) {

            allSlides.eq(_.options.slidesToShow).addClass('slick-center');

          }

        }

        _.$slides.eq(index).addClass('slick-center');

      } else {

        if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

          _.$slides.slice(index, index + _.options.slidesToShow).
              addClass('slick-active').
              attr('aria-hidden', 'false');

        } else if (allSlides.length <= _.options.slidesToShow) {

          allSlides.addClass('slick-active').attr('aria-hidden', 'false');

        } else {

          remainder = _.slideCount % _.options.slidesToShow;
          indexOffset = _.options.infinite === true ?
              _.options.slidesToShow + index :
              index;

          if (_.options.slidesToShow == _.options.slidesToScroll &&
              (_.slideCount - index) < _.options.slidesToShow) {

            allSlides.slice(indexOffset -
                (_.options.slidesToShow - remainder), indexOffset + remainder).
                addClass('slick-active').
                attr('aria-hidden', 'false');

          } else {

            allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).
                addClass('slick-active').
                attr('aria-hidden', 'false');

          }

        }

      }

      if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad ===
          'anticipated') {
        _.lazyLoad();
      }
    };

    Slick.prototype.setupInfinite = function() {

      var _ = this,
          i, slideIndex, infiniteCount;

      if (_.options.fade === true) {
        _.options.centerMode = false;
      }

      if (_.options.infinite === true && _.options.fade === false) {

        slideIndex = null;

        if (_.slideCount > _.options.slidesToShow) {

          if (_.options.centerMode === true) {
            infiniteCount = _.options.slidesToShow + 1;
          } else {
            infiniteCount = _.options.slidesToShow;
          }

          for (i = _.slideCount; i > (_.slideCount -
              infiniteCount); i -= 1) {
            slideIndex = i - 1;
            $(_.$slides[slideIndex]).
                clone(true).
                attr('id', '').
                attr('data-slick-index', slideIndex - _.slideCount).
                prependTo(_.$slideTrack).
                addClass('slick-cloned');
          }
          for (i = 0; i < infiniteCount + _.slideCount; i += 1) {
            slideIndex = i;
            $(_.$slides[slideIndex]).
                clone(true).
                attr('id', '').
                attr('data-slick-index', slideIndex + _.slideCount).
                appendTo(_.$slideTrack).
                addClass('slick-cloned');
          }
          _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
            $(this).attr('id', '');
          });

        }

      }

    };

    Slick.prototype.interrupt = function(toggle) {

      var _ = this;

      if (!toggle) {
        _.autoPlay();
      }
      _.interrupted = toggle;

    };

    Slick.prototype.selectHandler = function(event) {

      var _ = this;

      var targetElement =
          $(event.target).is('.slick-slide') ?
              $(event.target) :
              $(event.target).parents('.slick-slide');

      var index = parseInt(targetElement.attr('data-slick-index'));

      if (!index) index = 0;

      if (_.slideCount <= _.options.slidesToShow) {

        _.slideHandler(index, false, true);
        return;

      }

      _.slideHandler(index);

    };

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

      var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null,
          _ = this, navTarget;

      sync = sync || false;

      if (_.animating === true && _.options.waitForAnimate === true) {
        return;
      }

      if (_.options.fade === true && _.currentSlide === index) {
        return;
      }

      if (sync === false) {
        _.asNavFor(index);
      }

      targetSlide = index;
      targetLeft = _.getLeft(targetSlide);
      slideLeft = _.getLeft(_.currentSlide);

      _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

      if (_.options.infinite === false && _.options.centerMode === false &&
          (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
        if (_.options.fade === false) {
          targetSlide = _.currentSlide;
          if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
            _.animateSlide(slideLeft, function() {
              _.postSlide(targetSlide);
            });
          } else {
            _.postSlide(targetSlide);
          }
        }
        return;
      } else if (_.options.infinite === false && _.options.centerMode ===
          true &&
          (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
        if (_.options.fade === false) {
          targetSlide = _.currentSlide;
          if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
            _.animateSlide(slideLeft, function() {
              _.postSlide(targetSlide);
            });
          } else {
            _.postSlide(targetSlide);
          }
        }
        return;
      }

      if (_.options.autoplay) {
        clearInterval(_.autoPlayTimer);
      }

      if (targetSlide < 0) {
        if (_.slideCount % _.options.slidesToScroll !== 0) {
          animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
        } else {
          animSlide = _.slideCount + targetSlide;
        }
      } else if (targetSlide >= _.slideCount) {
        if (_.slideCount % _.options.slidesToScroll !== 0) {
          animSlide = 0;
        } else {
          animSlide = targetSlide - _.slideCount;
        }
      } else {
        animSlide = targetSlide;
      }

      _.animating = true;

      _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

      oldSlide = _.currentSlide;
      _.currentSlide = animSlide;

      _.setSlideClasses(_.currentSlide);

      if (_.options.asNavFor) {

        navTarget = _.getNavTarget();
        navTarget = navTarget.slick('getSlick');

        if (navTarget.slideCount <= navTarget.options.slidesToShow) {
          navTarget.setSlideClasses(_.currentSlide);
        }

      }

      _.updateDots();
      _.updateArrows();

      if (_.options.fade === true) {
        if (dontAnimate !== true) {

          _.fadeSlideOut(oldSlide);

          _.fadeSlide(animSlide, function() {
            _.postSlide(animSlide);
          });

        } else {
          _.postSlide(animSlide);
        }
        _.animateHeight();
        return;
      }

      if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
        _.animateSlide(targetLeft, function() {
          _.postSlide(animSlide);
        });
      } else {
        _.postSlide(animSlide);
      }

    };

    Slick.prototype.startLoad = function() {

      var _ = this;

      if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

        _.$prevArrow.hide();
        _.$nextArrow.hide();

      }

      if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

        _.$dots.hide();

      }

      _.$slider.addClass('slick-loading');

    };

    Slick.prototype.swipeDirection = function() {

      var xDist, yDist, r, swipeAngle, _ = this;

      xDist = _.touchObject.startX - _.touchObject.curX;
      yDist = _.touchObject.startY - _.touchObject.curY;
      r = Math.atan2(yDist, xDist);

      swipeAngle = Math.round(r * 180 / Math.PI);
      if (swipeAngle < 0) {
        swipeAngle = 360 - Math.abs(swipeAngle);
      }

      if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
        return (_.options.rtl === false ? 'left' : 'right');
      }
      if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
        return (_.options.rtl === false ? 'left' : 'right');
      }
      if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
        return (_.options.rtl === false ? 'right' : 'left');
      }
      if (_.options.verticalSwiping === true) {
        if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
          return 'down';
        } else {
          return 'up';
        }
      }

      return 'vertical';

    };

    Slick.prototype.swipeEnd = function(event) {

      var _ = this,
          slideCount,
          direction;

      _.dragging = false;
      _.swiping = false;

      if (_.scrolling) {
        _.scrolling = false;
        return false;
      }

      _.interrupted = false;
      _.shouldClick = (_.touchObject.swipeLength > 10) ? false : true;

      if (_.touchObject.curX === undefined) {
        return false;
      }

      if (_.touchObject.edgeHit === true) {
        _.$slider.trigger('edge', [_, _.swipeDirection()]);
      }

      if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {

        direction = _.swipeDirection();

        switch (direction) {

          case 'left':
          case 'down':

            slideCount =
                _.options.swipeToSlide ?
                    _.checkNavigable(_.currentSlide + _.getSlideCount()) :
                    _.currentSlide + _.getSlideCount();

            _.currentDirection = 0;

            break;

          case 'right':
          case 'up':

            slideCount =
                _.options.swipeToSlide ?
                    _.checkNavigable(_.currentSlide - _.getSlideCount()) :
                    _.currentSlide - _.getSlideCount();

            _.currentDirection = 1;

            break;

          default:

        }

        if (direction != 'vertical') {

          _.slideHandler(slideCount);
          _.touchObject = {};
          _.$slider.trigger('swipe', [_, direction]);

        }

      } else {

        if (_.touchObject.startX !== _.touchObject.curX) {

          _.slideHandler(_.currentSlide);
          _.touchObject = {};

        }

      }

    };

    Slick.prototype.swipeHandler = function(event) {

      var _ = this;

      if ((_.options.swipe === false) ||
          ('ontouchend' in document && _.options.swipe === false)) {
        return;
      } else if (_.options.draggable === false &&
          event.type.indexOf('mouse') !== -1) {
        return;
      }

      _.touchObject.fingerCount = event.originalEvent &&
      event.originalEvent.touches !== undefined ?
          event.originalEvent.touches.length : 1;

      _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;

      if (_.options.verticalSwiping === true) {
        _.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;
      }

      switch (event.data.action) {

        case 'start':
          _.swipeStart(event);
          break;

        case 'move':
          _.swipeMove(event);
          break;

        case 'end':
          _.swipeEnd(event);
          break;

      }

    };

    Slick.prototype.swipeMove = function(event) {

      var _ = this,
          edgeWasHit = false,
          curLeft, swipeDirection, swipeLength, positionOffset, touches,
          verticalSwipeLength;

      touches = event.originalEvent !== undefined ?
          event.originalEvent.touches :
          null;

      if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
        return false;
      }

      curLeft = _.getLeft(_.currentSlide);

      _.touchObject.curX = touches !== undefined ?
          touches[0].pageX :
          event.clientX;
      _.touchObject.curY = touches !== undefined ?
          touches[0].pageY :
          event.clientY;

      _.touchObject.swipeLength = Math.round(Math.sqrt(
          Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

      verticalSwipeLength = Math.round(Math.sqrt(
          Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

      if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
        _.scrolling = true;
        return false;
      }

      if (_.options.verticalSwiping === true) {
        _.touchObject.swipeLength = verticalSwipeLength;
      }

      swipeDirection = _.swipeDirection();

      if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
        _.swiping = true;
        event.preventDefault();
      }

      positionOffset = (_.options.rtl === false ? 1 : -1) *
          (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
      if (_.options.verticalSwiping === true) {
        positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
      }

      swipeLength = _.touchObject.swipeLength;

      _.touchObject.edgeHit = false;

      if (_.options.infinite === false) {
        if ((_.currentSlide === 0 && swipeDirection === 'right') ||
            (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
          swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
          _.touchObject.edgeHit = true;
        }
      }

      if (_.options.vertical === false) {
        _.swipeLeft = curLeft + swipeLength * positionOffset;
      } else {
        _.swipeLeft = curLeft +
            (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
      }
      if (_.options.verticalSwiping === true) {
        _.swipeLeft = curLeft + swipeLength * positionOffset;
      }

      if (_.options.fade === true || _.options.touchMove === false) {
        return false;
      }

      if (_.animating === true) {
        _.swipeLeft = null;
        return false;
      }

      _.setCSS(_.swipeLeft);

    };

    Slick.prototype.swipeStart = function(event) {

      var _ = this,
          touches;

      _.interrupted = true;

      if (_.touchObject.fingerCount !== 1 || _.slideCount <=
          _.options.slidesToShow) {
        _.touchObject = {};
        return false;
      }

      if (event.originalEvent !== undefined && event.originalEvent.touches !==
          undefined) {
        touches = event.originalEvent.touches[0];
      }

      _.touchObject.startX = _.touchObject.curX = touches !== undefined ?
          touches.pageX :
          event.clientX;
      _.touchObject.startY = _.touchObject.curY = touches !== undefined ?
          touches.pageY :
          event.clientY;

      _.dragging = true;

    };

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

      var _ = this;

      if (_.$slidesCache !== null) {

        _.unload();

        _.$slideTrack.children(this.options.slide).detach();

        _.$slidesCache.appendTo(_.$slideTrack);

        _.reinit();

      }

    };

    Slick.prototype.unload = function() {

      var _ = this;

      $('.slick-cloned', _.$slider).remove();

      if (_.$dots) {
        _.$dots.remove();
      }

      if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
        _.$prevArrow.remove();
      }

      if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
        _.$nextArrow.remove();
      }

      _.$slides.removeClass(
          'slick-slide slick-active slick-visible slick-current').
          attr('aria-hidden', 'true').
          css('width', '');

    };

    Slick.prototype.unslick = function(fromBreakpoint) {

      var _ = this;
      _.$slider.trigger('unslick', [_, fromBreakpoint]);
      _.destroy();

    };

    Slick.prototype.updateArrows = function() {

      var _ = this,
          centerOffset;

      centerOffset = Math.floor(_.options.slidesToShow / 2);

      if (_.options.arrows === true &&
          _.slideCount > _.options.slidesToShow &&
          !_.options.infinite) {

        _.$prevArrow.removeClass('slick-disabled').
            attr('aria-disabled', 'false');
        _.$nextArrow.removeClass('slick-disabled').
            attr('aria-disabled', 'false');

        if (_.currentSlide === 0) {

          _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
          _.$nextArrow.removeClass('slick-disabled').
              attr('aria-disabled', 'false');

        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow &&
            _.options.centerMode === false) {

          _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
          _.$prevArrow.removeClass('slick-disabled').
              attr('aria-disabled', 'false');

        } else if (_.currentSlide >= _.slideCount - 1 &&
            _.options.centerMode === true) {

          _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
          _.$prevArrow.removeClass('slick-disabled').
              attr('aria-disabled', 'false');

        }

      }

    };

    Slick.prototype.updateDots = function() {

      var _ = this;

      if (_.$dots !== null) {

        _.$dots.find('li').removeClass('slick-active').end();

        _.$dots.find('li').
            eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).
            addClass('slick-active');

      }

    };

    Slick.prototype.visibility = function() {

      var _ = this;

      if (_.options.autoplay) {

        if (document[_.hidden]) {

          _.interrupted = true;

        } else {

          _.interrupted = false;

        }

      }

    };

    $.fn.slick = function() {
      var _ = this,
          opt = arguments[0],
          args = Array.prototype.slice.call(arguments, 1),
          l = _.length,
          i,
          ret;
      for (i = 0; i < l; i++) {
        if (typeof opt == 'object' || typeof opt == 'undefined')
          _[i].slick = new Slick(_[i], opt);
        else
          ret = _[i].slick[opt].apply(_[i].slick, args);
        if (typeof ret != 'undefined') return ret;
      }
      return _;
    };

  }));

  /* ../../node_modules/slick-carousel/slick/slick.js end */

  provide($);
});

/* end: ../../5th.blocks/common.blocks/jquery/__slick/jquery__slick.js */
/* begin: ../../common.blocks/carousel/_view/carousel_view_how.js */
modules.define('carousel', ['i-bem-dom'], function(provide, bemDom, Carousel) {

  provide(Carousel.declMod({modName: 'view', modVal: 'how'}, {
    onSetMod: {
      js: {
        inited: function() {
          this.__base.apply(this, arguments);
          this._toggleCarousel();
          this._domEvents(bemDom.win).on('resize', this._toggleCarousel);
        },
      },
    },
    _toggleCarousel: function() {
      var libIsInited = this.hasMod('lib', 'inited');
      window.matchMedia(this.params.mq || '').matches ?
          (!libIsInited && this.reinit()) :
          (libIsInited && this.setMod('lib', 'destroyed'));
    },
  }));

});

/* end: ../../common.blocks/carousel/_view/carousel_view_how.js */
/* begin: ../../common.blocks/step-group/step-group.js */
modules.define('step-group', ['i-bem-dom', 'step'],
    function(provide, bemDom, Step) {

      provide(bemDom.declBlock(this.name, {
        onSetMod: {
          'js': {
            'inited': function() {
              this._steps = this.findChildBlocks(Step);
            },
          },
        },

        /**
         * @param {Object} e bem event
         * @param {Object} data data event
         * @param {String} data.modName modName
         * @param {String} data.modVal modVal
         * @param {String} data.oldModVal oldModVal
         */
        _onStepActiveChange: function(e, data) {
          var bemTarget = e.bemTarget;

          this._steps.forEach(function(step) {
            step.setMod('active', step == bemTarget);
          }, this);
        },
      }, {
        lazyInit: true,
        onInit: function() {
          this._events(Step).
              on({modName: 'active', modVal: true},
                  this.prototype._onStepActiveChange);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../common.blocks/step-group/step-group.js */
/* begin: ../../common.blocks/step/step.js */
modules.define('step', ['i-bem-dom', 'link'], function(provide, bemDom, Link) {

  provide(bemDom.declBlock(this.name, {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },

    _onLinkClick: function(e) {
      this.setMod('active');
    },

    /**
     * @param {Object} e bem event
     * @param {Object} data data event
     * @param {String} data.modName modName
     * @param {String} data.modVal modVal
     * @param {String} data.oldModVal oldModVal
     */
    _onLinkHoveredChange: function(e, data) {
      this.setMod(data.modName, data.modVal);
    },
  }, {
    lazyInit: true,
    onInit: function() {
      this._events(Link).
          on('click', this.prototype._onLinkClick).
          on({modName: 'hovered', modVal: '*'},
              this.prototype._onLinkHoveredChange);
      return this.__base.apply(this, arguments);
    },
  }));

});

/* end: ../../common.blocks/step/step.js */
/* begin: ../../5th.blocks/common.blocks/carousel/__inner/carousel__inner.js */
modules.define('carousel__inner', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declElem('carousel', 'inner', {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },
  }, {
    lazyInit: true,
  }));

});

/* end: ../../5th.blocks/common.blocks/carousel/__inner/carousel__inner.js */
/* begin: ../../node_modules/bem-components/common.blocks/button/_type/button_type_link.js */
/**
 * @module button
 */

modules.define('button', function(provide, Button) {

  /**
   * @exports
   * @class button
   * @bem
   */
  provide(Button.declMod({modName: 'type', modVal: 'link'},
      /** @lends button.prototype */{
        onSetMod: {
          'js': {
            'inited': function() {
              this.__base.apply(this, arguments);
              this._url = this.params.url || this.domElem.attr('href');

              this.hasMod('disabled') && this.domElem.removeAttr('href');
            },
          },

          'disabled': {
            'true': function() {
              this.__base.apply(this, arguments);
              this.domElem.removeAttr('href').attr('aria-disabled', true);
            },

            '': function() {
              this.__base.apply(this, arguments);
              this.domElem.attr('href', this._url).removeAttr('aria-disabled');
            },
          },
        },

        /**
         * Returns url
         * @returns {String}
         */
        getUrl: function() {
          return this._url;
        },

        /**
         * Sets url
         * @param {String} url
         * @returns {button} this
         */
        setUrl: function(url) {
          this._url = url;
          this.hasMod('disabled') || this.domElem.attr('href', url);
          return this;
        },

        _doAction: function() {
          this._url && (document.location = this._url);
        },
      }));

});

/* end: ../../node_modules/bem-components/common.blocks/button/_type/button_type_link.js */
/* begin: ../../5th.blocks/common.blocks/tab/tab.js */
modules.define('tab',
    ['i-bem-dom', 'jquery__hasScrollBar', 'tab__control', 'tab__option'],
    function(provide, bemDom, $, Tab__control, Tab__option) {

      provide(bemDom.declBlock(this.name, {
        onSetMod: {
          'js': {
            'inited': function() {
              this._control = this.findChildElem(Tab__control);
              this._options = this.findChildElems(Tab__option);
            },
          },
        },

        /**
         * @param {Object} e bem event
         * @param {String} val value
         */
        _onControlChange: function(e, val) {
          this._changeActiveOption(val);
          this._emit('change', val);
          e.bemTarget.getMod('type') == 'radio' && this._scrolling();
        },

        /**
         * @param {String} val value
         */
        _changeActiveOption: function(val) {
          this._options.forEach(function(option) {
            option.setMod('active', option.params.val == val);
          }, this);
        },

        getActiveOption: function() {
          return this._options.filter(function(option) {
            return option.hasMod('active');
          }, this);
        },

        /**
         * Скроллинг к активному табу, если есть горизонтальный скроллбар
         */
        _scrolling: function() {
          if (!this._control.domElem.hasScrollBar().horizontal) return;

          var offset = 0,
              radios = this._control.getRadios(),
              radio_checked = this._control.getActiveControlEl();

          radios.forEach(function(radio) {
            if (radio == radio_checked.get(0) ||
                radio_checked.get(0).domElem.index() <
                radio.domElem.index()) return;

            offset += radio.domElem.outerWidth(true);
          }, this);

          this._control.domElem.scrollLeft(offset);
        },
      }, {
        lazyInit: true,
        onInit: function() {
          this._events(Tab__control).
              on('change', this.prototype._onControlChange);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/tab/tab.js */
/* begin: ../../5th.blocks/common.blocks/tab/__control/tab__control.js */
modules.define('tab__control', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declElem('tab', 'control', {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },

    getRadios: function() {
    },

    /**
     * @param {Object} e bem events
     */
    _onControlChange: function(e) {
      this._emit('change', e.bemTarget.getVal());
    },
  }, {
    lazyInit: true,
  }));

});

/* end: ../../5th.blocks/common.blocks/tab/__control/tab__control.js */
/* begin: ../../5th.blocks/common.blocks/tab/__control/_type/tab__control_type_menu.js */
modules.define('tab__control', ['i-bem-dom', 'menu'],
    function(provide, bemDom, Menu, Tab__control) {

      provide(Tab__control.declMod({modName: 'type', modVal: 'menu'}, {
        onSetMod: {
          'js': {
            'inited': function() {
              this.__base.apply(this, arguments);
            },
          },
        },
      }, {
        lazyInit: true,
        onInit: function() {
          this._events(Menu).on('change', this.prototype._onControlChange);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/tab/__control/_type/tab__control_type_menu.js */
/* begin: ../../5th.blocks/common.blocks/tab/__option/tab__option.js */
modules.define('tab__option', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declElem('tab', 'option', {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },
  }, {
    lazyInit: true,
  }));

});

/* end: ../../5th.blocks/common.blocks/tab/__option/tab__option.js */
/* begin: ../../5th.blocks/common.blocks/jquery/__hasScrollBar/jquery__hasScrollBar.js */
modules.define('jquery__hasScrollBar', ['jquery'], function(provide, $) {

  window.jQuery = jQuery = $;

  /**
   * Проверка наличия скролла у элемента
   * @example
   * $('html').hasScrollBar().vertical
   * $('html').hasScrollBar().horizontal
   * @return {Object}
   */
  $.fn.hasScrollBar = function() {
    var hasScrollBar = {},
        elem = this.get(0);

    hasScrollBar.vertical = elem.scrollHeight > elem.clientHeight;
    hasScrollBar.horizontal = elem.scrollWidth > elem.clientWidth;

    return hasScrollBar;
  };

  provide($);
});

/* end: ../../5th.blocks/common.blocks/jquery/__hasScrollBar/jquery__hasScrollBar.js */
/* begin: ../../design/common.blocks/tab/_theme/tab_theme_finza.js */
modules.define('tab', ['i-bem-dom', 'radio'],
    function(provide, bemDom, Radio, Tab) {

      provide(Tab.declMod({modName: 'theme', modVal: 'finza'}, {
        _onControlChange: function(e, val) {
          this.__base.apply(this, arguments);
          this.setMod('val', val);
        },
      }));

    });

/* end: ../../design/common.blocks/tab/_theme/tab_theme_finza.js */
/* begin: ../../common.blocks/tab/_view/tab_view_links.js */
modules.define('tab', ['carousel', 'next-tick'],
    function(provide, Carousel, nextTick, Tab) {

      provide(Tab.declMod({modName: 'view', modVal: 'links'}, {
        onSetMod: {
          js: {
            inited: function() {
              this.__base.apply(this, arguments);
              this._carousel = this.findChildBlock(Carousel);
            },
          },
        },
        _changeActiveOption: function(e, val) {
          this.__base.apply(this, arguments);
          setTimeout(function() {
            this._carousel.reinit();
          }.bind(this), 200);
        },
      }));

    });

/* end: ../../common.blocks/tab/_view/tab_view_links.js */
/* begin: ../../node_modules/bem-components/common.blocks/button/_togglable/button_togglable.js */
/**
 * @module button
 */

modules.define('button', function(provide, Button) {

  /**
   * @exports
   * @class button
   * @bem
   */

  provide(Button.declMod({modName: 'togglable', modVal: '*'},
      /** @lends button.prototype */{
        onSetMod: {
          'checked': function(_, modVal) {
            this.__base.apply(this, arguments);
            this.domElem.attr('aria-pressed', !!modVal);
          },
        },
      }));

});

/* end: ../../node_modules/bem-components/common.blocks/button/_togglable/button_togglable.js */
/* begin: ../../5th.blocks/common.blocks/footer/footer.js */
modules.define('footer', ['i-bem-dom'], function(provide, bemDom) {

  provide(bemDom.declBlock(this.name, {
    onSetMod: {
      'js': {
        'inited': function() {

        },
      },
    },
  }, {
    lazyInit: false,
  }));

});

/* end: ../../5th.blocks/common.blocks/footer/footer.js */
/* begin: ../../node_modules/bem-core/common.blocks/loader/_type/loader_type_js.js */
/**
 * @module loader_type_js
 * @description Load JS from external URL.
 */

modules.define('loader_type_js', function(provide) {

  var loading = {},
      loaded = {},
      head = document.getElementsByTagName('head')[0],
      runCallbacks = function(path, type) {
        var cbs = loading[path], cb, i = 0;
        delete loading[path];
        while (cb = cbs[i++]) {
          cb[type] && cb[type]();
        }
      },
      onSuccess = function(path) {
        loaded[path] = true;
        runCallbacks(path, 'success');
      },
      onError = function(path) {
        runCallbacks(path, 'error');
      };

  provide(
      /**
       * @exports
       * @param {String} path resource link
       * @param {Function} [success] to be called if the script succeeds
       * @param {Function} [error] to be called if the script fails
       */
      function(path, success, error) {
        if (loaded[path]) {
          success && success();
          return;
        }

        if (loading[path]) {
          loading[path].push({success: success, error: error});
          return;
        }

        loading[path] = [{success: success, error: error}];

        var script = document.createElement('script');
        script.type = 'text/javascript';
        script.charset = 'utf-8';
        script.src = (location.protocol === 'file:' && !path.indexOf('//') ?
            'http:' :
            '') + path;

        if ('onload' in script) {
          script.onload = function() {
            script.onload = script.onerror = null;
            onSuccess(path);
          };

          script.onerror = function() {
            script.onload = script.onerror = null;
            onError(path);
          };
        } else {
          script.onreadystatechange = function() {
            var readyState = this.readyState;
            if (readyState === 'loaded' || readyState === 'complete') {
              script.onreadystatechange = null;
              onSuccess(path);
            }
          };
        }

        head.insertBefore(script, head.lastChild);
      },
  );

});

/* end: ../../node_modules/bem-core/common.blocks/loader/_type/loader_type_js.js */
/* begin: ../../node_modules/bem-core/common.blocks/i-bem-dom/__events/_type/i-bem-dom__events_type_dom.js */
/**
 * @module i-bem-dom__events_type_dom
 */
modules.define(
    'i-bem-dom__events_type_dom',
    [
      'i-bem-dom__events',
      'inherit',
      'jquery',
    ],
    function(
        provide,
        bemDomEvents,
        inherit,
        $) {

      var eventBuilder = function(e) {
            return e;
          },
          /**
           * @class EventManagerFactory
           * @augments i-bem-dom__events:EventManagerFactory
           * @exports i-bem-dom__events_type_dom:EventManagerFactory
           */
          EventManagerFactory = inherit(bemDomEvents.EventManagerFactory,
              /** @lends EventManagerFactory.prototype */{
                /** @override */
                _createEventManager: function(ctx, params, isInstance) {
                  function wrapperFn(fn) {
                    return function(e) {
                      var instance;

                      if (isInstance) {
                        instance = ctx;
                      } else {
                        // TODO: we could optimize all these "closest" to a single traversing
                        var entityDomNode = $(e.target).
                            closest(params.ctxSelector);
                        entityDomNode.length &&
                        (instance = entityDomNode.bem(ctx));
                      }

                      if (instance) {
                        params.bindEntityCls &&
                        (e.bemTarget = $(this).bem(params.bindEntityCls));
                        fn.apply(instance, arguments);
                      }
                    };
                  }

                  return new this._eventManagerCls(params, wrapperFn,
                      eventBuilder);
                },
              });

      provide({EventManagerFactory: EventManagerFactory});

    });

/* end: ../../node_modules/bem-core/common.blocks/i-bem-dom/__events/_type/i-bem-dom__events_type_dom.js */
/* begin: ../../node_modules/bem-components/common.blocks/modal/modal.js */
/**
 * @module modal
 */

modules.define(
    'modal',
    ['i-bem-dom', 'popup'],
    function(provide, bemDom, Popup) {

      /**
       * @exports
       * @class modal
       * @bem
       *
       * @bemmod visible Represents visible state
       */
      provide(bemDom.declBlock(this.name, /** @lends modal.prototype */{
        onSetMod: {
          'js': {
            'inited': function() {
              this._popup = this.findMixedBlock(Popup);
            },

            '': function() {
              this.delMod('visible');
            },
          },

          'visible': function(modName, modVal) {
            this._popup.setMod(modName, modVal);
          },
        },

        /**
         * Sets content
         * @param {String|jQuery} content
         * @returns {modal} this
         */
        setContent: function(content) {
          bemDom.update(this._elem('content').domElem, content);
          return this;
        },
      }, /** @lends modal */{
        lazyInit: true,
      }));

    });

/* end: ../../node_modules/bem-components/common.blocks/modal/modal.js */
/* begin: ../../node_modules/bem-core/common.blocks/jquery/__event/_type/jquery__event_type_pointerpressrelease.js */
modules.define('jquery', function(provide, $) {

  $.each({
    pointerpress: 'pointerdown',
    pointerrelease: 'pointerup pointercancel',
  }, function(fix, origEvent) {
    function eventHandler(e) {
      if (e.which === 1) {
        var fixedEvent = cloneEvent(e);
        fixedEvent.type = fix;
        fixedEvent.originalEvent = e;
        return $.event.dispatch.call(this, fixedEvent);
      }
    }

    $.event.special[fix] = {
      setup: function() {
        $(this).on(origEvent, eventHandler);
        return false;
      },
      teardown: function() {
        $(this).off(origEvent, eventHandler);
        return false;
      },
    };
  });

  function cloneEvent(event) {
    var eventCopy = $.extend(new $.Event(), event);
    if (event.preventDefault) {
      eventCopy.preventDefault = function() {
        event.preventDefault();
      };
    }
    return eventCopy;
  }

  provide($);

});

/* end: ../../node_modules/bem-core/common.blocks/jquery/__event/_type/jquery__event_type_pointerpressrelease.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form/_message/form_message_popup.browser.js */
/**
 * @module form
 */
modules.define('form',
    function(provide, Form) {
      /**
       *
       * @exports
       * @class form
       * @bem
       */
      Form.declMod({modName: 'message', modVal: 'popup'},
          /** @lends form.prototype */{

            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);

                  this.setMessageAnchor(this);
                },
              },
            },

            setMessageAnchor: function(anchor) {
              this.getMessage().setAnchor(anchor);
            },

          });

      provide(Form);

    });

/* end: ../../node_modules/bem-forms/common.blocks/form/_message/form_message_popup.browser.js */
/* begin: ../../node_modules/bem-forms/common.blocks/message/_type/message_type_popup.browser.js */
/**
 * @module message
 */
modules.define('message', ['popup'],
    function(provide, Popup, Message) {
      /**
       * Message type popup
       *
       * @exports
       * @class message
       * @bem
       */
      Message.declMod({modName: 'type', modVal: 'popup'},
          /** @lends message.prototype */{

            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);

                  this.getPopup().setAnchor(this.domElem);
                },
              },
            },
            /**
             * Returns message val
             * @protected
             * @returns {BEM}
             */
            setAnchor: function(anchor) {
              this.getPopup().setAnchor(anchor);
            },
            /**
             * Returns reference to popup block (cached).
             * @returns {BEM}
             */
            getPopup: function() {
              return this._popup || (this._popup = this.findChildBlock(Popup));
            },
            /**
             * Returns message val
             * @protected
             * @returns {BEM}
             */
            getVal: function() {
              return this._val;
            },
            /**
             * Set message val
             * @protected
             * @returns {BEM}
             */
            setVal: function() {
              this.__base.apply(this, arguments);

              this.getPopup().setContent(this._val);
            },
            /**
             * Show message in popup
             */
            show: function() {
              this.__base.apply(this, arguments);

              this.getPopup().setMod('visible');
            },
            /**
             * Hide message in popup
             */
            hide: function() {
              this.__base.apply(this, arguments);

              this.getPopup().delMod('visible');
            },
            /**
             * Toggle message in popup
             */
            toggle: function() {
              this.__base.apply(this, arguments);

              this.getPopup().toggleMod('visible');
            },
          });

      provide(Message);

    });

/* end: ../../node_modules/bem-forms/common.blocks/message/_type/message_type_popup.browser.js */
/* begin: ../../node_modules/bem-forms/common.blocks/message/_type/message_type_text.browser.js */
/**
 * @module message
 */
modules.define('message',
    function(provide, Message) {
      /**
       * Message type text
       *
       * @exports
       * @class message
       * @bem
       */
      Message.declMod({modName: 'type', modVal: 'text'},
          /** @lends message.prototype */{
            /**
             * Set message val
             * @protected
             * @returns {BEM}
             */
            setVal: function() {
              this.__base.apply(this, arguments);

              this.domElem.html(this.getVal());

              return this;
            },
          });

      provide(Message);

    });

/* end: ../../node_modules/bem-forms/common.blocks/message/_type/message_type_text.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/popup/_target/popup_target_anchor.js */
/**
 * @module popup
 */

modules.define(
    'popup',
    ['i-bem-dom', 'jquery', 'objects', 'functions__throttle', 'z-index-group'],
    function(provide, bemDom, $, objects, throttle, zIndexGroup, Popup) {

      var body = $(bemDom.doc[0].body),
          UPDATE_TARGET_VISIBILITY_THROTTLING_INTERVAL = 100,
          undef;

      /**
       * @exports
       * @class popup
       * @bem
       */
      provide(Popup.declMod({modName: 'target', modVal: 'anchor'},
          /** @lends popup.prototype */{
            beforeSetMod: {
              'visible': {
                'true': function() {
                  if (!this._anchor)
                    throw Error('Can\'t show popup without anchor');
                },
              },
            },

            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);

                  this._destructorClass = bemDom.declBlock('_' +
                      this.__self.getName() + '-destructor');

                  this._anchor = null;
                  this._anchorParents = null;
                  this._destructor = null;
                  this._isAnchorVisible = undef;
                  this._updateIsAnchorVisible = throttle(
                      this._updateIsAnchorVisible,
                      UPDATE_TARGET_VISIBILITY_THROTTLING_INTERVAL,
                      false,
                      this);
                },

                '': function() {
                  this.__base.apply(this, arguments);
                  this._unbindFromDestructor(); // don't destruct anchor as it might be the same anchor for several popups
                },
              },

              'visible': {
                'true': function() {
                  this._anchorParents = this._anchor.parents();
                  this._bindToAnchorParents();

                  this.__base.apply(this, arguments);
                },

                '': function() {
                  this.__base.apply(this, arguments);

                  this._unbindFromAnchorParents();
                  this._anchorParents = null;
                  this._isAnchorVisible = undef;
                },
              },
            },

            /**
             * Sets target
             * @param {jQuery|bemDom} anchor DOM elem or anchor bemDom block
             * @returns {popup} this
             */
            setAnchor: function(anchor) {
              this._unbindFromAnchorParents().
                  _unbindFromParentPopup().
                  _unbindFromDestructor();

              this._anchor = anchor.domElem || anchor;

              this._destructor = this._anchor.bem(this._destructorClass);
              this._isAnchorVisible = undef;

              this._bindToDestructor();

              if (this.hasMod('visible')) {
                this._anchorParents = this._anchor.parents();
                this._recaptureZIndex().
                    _bindToAnchorParents().
                    _bindToParentPopup().
                    redraw();
              } else {
                this._anchorParents = null;
                this._zIndexGroupLevel = null;
              }

              return this;
            },

            /**
             * @override
             */
            _calcTargetDimensions: function() {
              var anchor = this._anchor,
                  anchorOffset = anchor.offset(),
                  bodyOffset = body.css('position') === 'static' ?
                      {left: 0, top: 0} :
                      body.offset();

              return {
                left: anchorOffset.left - bodyOffset.left,
                top: anchorOffset.top - bodyOffset.top,
                width: anchor.outerWidth(),
                height: anchor.outerHeight(),
              };
            },

            /**
             * @override
             */
            _calcDrawingCss: function(drawingParams) {
              typeof this._isAnchorVisible === 'undefined' &&
              (this._isAnchorVisible = this._calcIsAnchorVisible());

              return objects.extend(
                  this.__base(drawingParams),
                  {display: this._isAnchorVisible ? '' : 'none'});
            },

            /**
             * Calculates target visibility state
             * @private
             * @returns {Boolean} Whether state is visible
             */
            _calcIsAnchorVisible: function() {
              var anchor = this._anchor,
                  anchorOffset = anchor.offset(),
                  anchorLeft = anchorOffset.left,
                  anchorTop = anchorOffset.top,
                  anchorRight = anchorLeft + anchor.outerWidth(),
                  anchorBottom = anchorTop + anchor.outerHeight(),
                  direction = this.getMod('direction'),
                  vertBorder = this._checkMainDirection(direction, 'top') ||
                  this._checkSecondaryDirection(direction, 'top') ?
                      anchorTop :
                      anchorBottom,
                  horizBorder = this._checkMainDirection(direction, 'left') ||
                  this._checkSecondaryDirection(direction, 'left') ?
                      anchorLeft :
                      anchorRight,
                  res = true;

              this._anchorParents.each(function() {
                if (this.tagName === 'BODY') return false;

                var parent = $(this),
                    overflowY = parent.css('overflow-y'),
                    checkOverflowY = overflowY === 'scroll' || overflowY ===
                        'hidden' || overflowY === 'auto',
                    overflowX = parent.css('overflow-x'),
                    checkOverflowX = overflowX === 'scroll' || overflowX ===
                        'hidden' || overflowX === 'auto';

                if (checkOverflowY || checkOverflowX) {
                  var parentOffset = parent.offset();

                  if (checkOverflowY) {
                    var parentTopOffset = parentOffset.top;
                    if (vertBorder < parentTopOffset || parentTopOffset +
                        parent.outerHeight() < vertBorder) {
                      return res = false;
                    }
                  }

                  if (checkOverflowX) {
                    var parentLeftOffset = parentOffset.left;
                    return res = !(
                        horizBorder < parentLeftOffset ||
                        parentLeftOffset + parent.outerWidth() < horizBorder);
                  }
                }
              });

              return res;
            },

            _calcZIndexGroupLevel: function() {
              var res = this.__base.apply(this, arguments);

              return this._destructor.findParentBlocks(zIndexGroup).reduce(
                  function(res, zIndexGroupInstance) {
                    return res + Number(zIndexGroupInstance.getMod('level'));
                  },
                  res);
            },

            _bindToAnchorParents: function() {
              this._domEvents(this._anchorParents).
                  on('scroll', this._onAnchorParentsScroll);
              return this;
            },

            _unbindFromAnchorParents: function() {
              this._anchorParents && this._domEvents(this._anchorParents).un(
                  'scroll',
                  this._onAnchorParentsScroll);
              return this;
            },

            _onAnchorParentsScroll: function() {
              this.redraw()._updateIsAnchorVisible();
            },

            /**
             * @override
             */
            _onWinScrollAndResize: function() {
              this.__base.apply(this, arguments);
              this._updateIsAnchorVisible();
            },

            _updateIsAnchorVisible: function() {
              if (!this.hasMod('js', 'inited') || !this.hasMod('visible'))
                return;

              var isAnchorVisible = this._calcIsAnchorVisible();
              if (isAnchorVisible !== this._isAnchorVisible) {
                this._isAnchorVisible = isAnchorVisible;
                this.redraw();
              }
            },

            _bindToDestructor: function() {
              this._events(this._destructor).
                  on({modName: 'js', modVal: ''}, this._onPopupAnchorDestruct,
                      this);
              return this;
            },

            _unbindFromDestructor: function() {
              this._destructor &&
              this._events(this._destructor).
                  un({modName: 'js', modVal: ''}, this._onPopupAnchorDestruct,
                      this);
              return this;
            },

            _onPopupAnchorDestruct: function() {
              bemDom.destruct(this.domElem);
            },

            _getParentPopup: function() {
              if (this._parentPopup) return this._parentPopup;

              var parentPopupDomElem = this._anchor.closest(
                  Popup._buildSelector());

              return this._parentPopup = !!parentPopupDomElem.length &&
                  parentPopupDomElem.bem(Popup);
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/popup/_target/popup_target_anchor.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_message/form-field_message_popup.browser.js */
/**
 * @module form-field
 */
modules.define('form-field',
    function(provide, FormField) {
      /**
       *
       * @exports
       * @class form-field
       * @bem
       */
      FormField.declMod({modName: 'message', modVal: 'popup'},
          /** @lends form-field.prototype */{

            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);

                  this.setMessageAnchor(this.getControl());
                },
              },
            },

            setMessageAnchor: function(anchor) {
              this.getMessage().setAnchor(anchor);
            },

          });

      provide(FormField);

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_message/form-field_message_popup.browser.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_input.browser.js */
/**
 * @module form-field
 */
modules.define('form-field', ['input'],
    function(provide, Input, FormField) {
      /**
       * Input field
       *
       * @exports
       * @class form-field
       * @bem
       */
      provide(FormField.declMod({modName: 'type', modVal: 'input'}, {

        getControl: function() {
          return this._control || (this._control = this.findChildBlock(Input));
        },

      }, /** @lends form-field_type_input */{
        lazyInit: true,

        onInit: function() {
          var ptp = this.prototype;

          this.__base();
          this._events(Input).
              on('change', ptp._onControlChange).
              on({modName: 'focused', modVal: true}, ptp._onControlFocus).
              on({modName: 'focused', modVal: ''}, ptp._onControlBlur);
        },
      }));

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_type/form-field_type_input.browser.js */
/* begin: ../../node_modules/bem-components/common.blocks/attach/attach.js */
/**
 * @module attach
 */

modules.define(
    'attach',
    [
      'i-bem-dom',
      'i-bem__internal',
      'control',
      'button',
      'jquery',
      'strings__escape'],
    function(provide, bemDom, INTERNAL, Control, Button, $, escape) {

      /**
       * @exports
       * @class attach
       * @augments control
       * @bem
       */
      provide(
          bemDom.declBlock(this.name, Control, /** @lends attach.prototype */{
            onSetMod: {
              'disabled': function(modName, modVal) {
                this.__base.apply(this, arguments);
                this._getButton().setMod(modName, modVal);
              },
            },

            /**
             * Clear control value
             * @param {Object} [data] additional data
             * @returns {attach} this
             */
            clear: function(data) {
              if (!this.getVal()) return this;
              return this._clear(data);
            },

            _clear: function(data) {
              var control = this._elem('control').domElem,
                  name = control.attr('name'),
                  tabIndex = control.attr('tabindex');

              bemDom.replace(
                  control,
                  '<input' +
                  ' class="' + control.attr('class') + '"' +
                  ' type="file"' +
                  (name ? ' name="' + name + '"' : '') +
                  (tabIndex ? ' tabindex="' + tabIndex + '"' : '') +
                  '/>');

              bemDom.destruct(this.findChildElem('file').domElem);

              this.domElem.append(this._elem('no-file').domElem); // use append because only detached before

              return this._emitChange(data);
            },

            _onClearClick: function() {
              this.clear({source: 'clear'});
            },

            _onChange: function() {
              this._elem('no-file').domElem.detach();
              this.getVal() ?
                  this._updateFileElem()._emitChange() :
                  this._clear();
            },

            _emitChange: function(data) {
              return this._emit('change', data);
            },

            _updateFileElem: function() {
              var fileName = extractFileNameFromPath(this.getVal());

              this.findChildElem('file') &&
              bemDom.destruct(this._elem('file').domElem);

              bemDom.append(
                  this.domElem,
                  '<span class="' +
                  this.__self._buildClassName('file') + '">' +
                  '<span class="' +
                  this.__self._buildClassName('text') + '">' +
                  escape.html(fileName) +
                  '</span>' +
                  '<span class="' + this.__self._buildClassName('clear') +
                  '"/>' +
                  '</span>');

              return this;
            },

            _getButton: function() {
              return this.findChildBlock(Button);
            },
          }, /** @lends attach */{
            lazyInit: true,
            onInit: function() {
              this._domEvents('clear').
                  on('pointerclick', this.prototype._onClearClick);
              this._domEvents('control').on('change', this.prototype._onChange);

              return this.__base.apply(this, arguments);
            },
          }));

      function extractFileNameFromPath(path) {
        return path.split('\\').pop(); // we need this only in windows
      }

    });

/* end: ../../node_modules/bem-components/common.blocks/attach/attach.js */
/* begin: ../../5th.blocks/common.blocks/attach/attach.js */
modules.define('attach', ['i-bem-dom'], function(provide, bemDom, Attach) {

  provide(bemDom.declBlock(this.name, Attach, {
    /**
     * Расширение метода модификатором has-val
     */
    _emitChange: function(data) {
      this.setMod('has-val', !!this.getVal());
      return this._emit('change', data);
    },
  }));

});

/* end: ../../5th.blocks/common.blocks/attach/attach.js */
/* begin: ../../node_modules/bem-forms/common.blocks/form-field/_validate/form-field_validate_email.browser.js */
/**
 * @module form-field
 */
modules.define('form-field',
    ['validation_email', 'objects'],
    function(provide, validateEmail, objects, FormField) {
      /**
       * E-mail form-field validation
       * @exports
       * @class form-field
       * @bem
       */
      FormField.declMod({modName: 'validate', modVal: 'email'},
          /** @lends form-field.prototype */{

            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);

                  this.params.email && this.setValidationMessages({
                    email: this.params.email.message,
                  });

                  this.getValidator().push(validateEmail(this));
                },
              },
            },

          });

      provide(FormField);

    });

/* end: ../../node_modules/bem-forms/common.blocks/form-field/_validate/form-field_validate_email.browser.js */
/* begin: ../../5th.blocks/common.blocks/input-mask/_type/input-mask_type_phone.js */
modules.define('input-mask', ['i-bem-dom', 'jquery__inputmask'],
    function(provide, bemDom, $, InputMask) {

      provide(InputMask.declMod({modName: 'type', modVal: 'phone'}, {
        _setMask: function() {
          this._inputControl.domElem.inputmask('+7 999 999 99 99');
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/input-mask/_type/input-mask_type_phone.js */
/* begin: ../../5th.blocks/common.blocks/nav/_view/nav_view_main.js */
modules.define('nav', ['i-bem-dom', 'jquery', 'nav__item'],
    function(provide, bemDom, $, Nav__item, Nav) {

      provide(Nav.declMod({modName: 'view', modVal: 'main'}, {

        /**
         * @param {Object} e event
         * @param {Object} data event data
         * @param {String} data.modName
         * @param {Bool} data.modVal
         * @param {Bool} data.oldModVal
         */
        _onItemHoveredChange: function(e, data) {
          if (!e.bemTarget.hasMod('has-subnav')) return;
          var $prevItem = e.bemTarget.domElem.prev('.nav__item');
          $prevItem.length &&
          $prevItem.bem(Nav__item).setMod('hovered-neighbor', data.modVal);
        },

      }, {
        lazyInit: true,
        onInit: function() {
          this._events(Nav__item).
              on({modName: 'hovered', modVal: '*'},
                  this.prototype._onItemHoveredChange);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/nav/_view/nav_view_main.js */
/* begin: ../../node_modules/bem-components/common.blocks/menu/_mode/menu_mode_radio-check.js */
/**
 * @module menu
 */

modules.define('menu', function(provide, Menu) {

  /**
   * @exports
   * @class menu
   * @bem
   */
  provide(Menu.declMod({modName: 'mode', modVal: 'radio-check'},
      /** @lends menu.prototype */{
        /**
         * @override
         */
        _getVal: function() {
          var items = this.getItems(),
              i = 0, item;
          while (item = items.get(i++))
            if (item.hasMod('checked'))
              return item.getVal();
        },

        /**
         * @override
         */
        _setVal: function(val) {
          var isValUndefined = typeof val === 'undefined',
              wasChanged = false,
              hasVal = false,
              itemsCheckedVals = this.getItems().map(function(item) {
                if (isValUndefined) {
                  item.hasMod('checked') && (wasChanged = true);
                  return false;
                }

                if (!item.isValEq(val)) return false;

                item.hasMod('checked') || (wasChanged = true);
                return hasVal = true;
              });

          if (!isValUndefined && !hasVal) return false;

          this._updateItemsCheckedMod(itemsCheckedVals);

          return wasChanged;
        },

        /**
         * @override
         */
        _onItemClick: function(clickedItem) {
          this.__base.apply(this, arguments);

          this.getItems().forEach(function(item) {
            item === clickedItem ?
                item.toggleMod('checked') :
                item.delMod('checked');
          });
          this._isValValid = false;
          this._emit('change');
        },
      }));

});

/* end: ../../node_modules/bem-components/common.blocks/menu/_mode/menu_mode_radio-check.js */
/* begin: ../../5th.blocks/common.blocks/tab/__control/_type/tab__control_type_radio.js */
modules.define('tab__control', ['i-bem-dom', 'radio-group'],
    function(provide, bemDom, RadioGroup, Tab__control) {

      provide(Tab__control.declMod({modName: 'type', modVal: 'radio'}, {
        onSetMod: {
          'js': {
            'inited': function() {
              this.__base.apply(this, arguments);
              this._radioGroup = this.findMixedBlock(RadioGroup);
            },
          },
        },

        getRadios: function() {
          return this._radioGroup.getRadios();
        },

        getActiveControlEl: function() {
          var radios = this.getRadios();

          return radios.filter(function(radio) {
            return radio.hasMod('checked');
          }, this);
        },

      }, {
        lazyInit: true,
        onInit: function() {
          this._events(RadioGroup).
              on('change', this.prototype._onControlChange);
          return this.__base.apply(this, arguments);
        },
      }));

    });

/* end: ../../5th.blocks/common.blocks/tab/__control/_type/tab__control_type_radio.js */
/* begin: ../../node_modules/bem-components/common.blocks/radio/_type/radio_type_button.js */
/**
 * @module radio
 */

modules.define('radio', ['button', 'functions'],
    function(provide, Button, Functions, Radio) {

      /**
       * @exports
       * @class radio
       * @bem
       */
      provide(Radio.declMod({modName: 'type', modVal: 'button'},
          /** @lends radio.prototype */{
            onSetMod: {
              'js': {
                'inited': function() {
                  this.__base.apply(this, arguments);
                  this._button = this.findChildBlock(Button);
                  this._events(Button).on(
                      {modName: 'checked', modVal: '*'},
                      proxyModFromButton,
                      this).on(
                      {modName: 'focused', modVal: '*'},
                      proxyModFromButton,
                      this);
                },
              },

              'checked': proxyModToButton,
              'disabled': proxyModToButton,
              'focused': function(modName, modVal) {
                proxyModToButton.call(this, modName, modVal, false);
              },
            },
          }, /** @lends radio */{
            lazyInit: true,
            onInit: function() {
              this._events(Button).
                  on({modName: 'js', modVal: 'inited'}, Functions.noop);
              return this.__base.apply(this, arguments);
            },
          }));

      function proxyModToButton(modName, modVal, callBase) {
        callBase !== false && this.__base.apply(this, arguments);
        this._button.setMod(modName, modVal);
      }

      function proxyModFromButton(_, data) {
        this.setMod(data.modName, data.modVal);
      }

    });

/* end: ../../node_modules/bem-components/common.blocks/radio/_type/radio_type_button.js */
/* begin: ../../node_modules/bem-components/common.blocks/modal/_autoclosable/modal_autoclosable.js */
/**
 * @module modal
 */

modules.define(
    'modal',
    ['jquery', 'dom'],
    function(provide, $, dom, Modal) {

      /**
       * @exports
       * @class modal
       * @bem
       */
      provide(Modal.declMod({modName: 'autoclosable', modVal: true},
          /** @lends modal.prototype */{
            onSetMod: {
              'visible': {
                'true': function() {
                  this.__base.apply(this, arguments);

                  this._nextTick(function() {
                    this._domEvents().on('pointerclick', this._onPointerClick);
                  }).
                      _popup.
                      _events().
                      on({modName: 'visible', modVal: ''}, this._onPopupHide,
                          this);
                },
              },
            },

            _onPointerClick: function(e) {
              dom.contains(this._elem('content').domElem, $(e.target)) ||
              this.delMod('visible');
            },

            _onPopupHide: function() {
              this.delMod('visible');
            },
          }));

    });

/* end: ../../node_modules/bem-components/common.blocks/modal/_autoclosable/modal_autoclosable.js */
/* begin: ../../5th.blocks/common.blocks/modal/_has-close/modal_has-close.js */
modules.define('modal', ['i-bem-dom'], function(provide, bemDom, Modal) {

  provide(Modal.declMod({modName: 'has-close', modVal: true}, {

        /**
         * Sets content
         * @param {String|jQuery} content
         * @returns {modal} this
         */
        setContent: function(content) {
          var content = '<div class="modal__close"></div>' +
              '<div class="modal__inner">' + content + '</div>';
          bemDom.update(this._elem('content').domElem, content);
          return this;
        },

      }, {
        onInit: function() {
          this._domEvents('close').on('click', function() {
            this.delMod('visible');
          });
        },
      },
  ));

});

/* end: ../../5th.blocks/common.blocks/modal/_has-close/modal_has-close.js */

var BEMHTML;
(function(global) {
  function buildBemXjst(libs) {
    var exports;
    /* BEM-XJST Runtime Start */
    var BEMHTML = function(module, exports) {
      (function(f) {
        if (typeof exports === 'object' && typeof module !== 'undefined') {
          module.exports = f();
        } else if (typeof define === 'function' && define.amd) {
          define([], f);
        } else {
          var g;
          if (typeof window !== 'undefined') {
            g = window;
          } else if (typeof global !== 'undefined') {
            g = global;
          } else if (typeof self !== 'undefined') {
            g = self;
          } else {
            g = this;
          }
          g.bemhtml = f();
        }
      })(function() {
        var define, module, exports;
        return (function e(t, n, r) {
          function s(o, u) {
            if (!n[o]) {
              if (!t[o]) {
                var a = typeof require == 'function' && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error('Cannot find module \'' + o + '\'');
                throw f.code = 'MODULE_NOT_FOUND', f;
              }
              var l = n[o] = {exports: {}};
              t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
              }, l, l.exports, e, t, n, r);
            }
            return n[o].exports;
          }

          var i = typeof require == 'function' && require;
          for (var o = 0; o < r.length; o++) s(r[o]);
          return s;
        })({
          1: [
            function(require, module, exports) {
              var inherits = require('inherits');
              var Match = require('../bemxjst/match').Match;
              var BemxjstEntity = require('../bemxjst/entity').Entity;

              /**
               * @class Entity
               * @param {BEMXJST} bemxjst
               * @param {String} block
               * @param {String} elem
               * @param {Array} templates
               */
              function Entity(bemxjst) {
                this.bemxjst = bemxjst;

                this.jsClass = null;

                // "Fast modes" about HTML
                this.tag = new Match(this, 'tag');
                this.attrs = new Match(this, 'attrs');
                this.bem = new Match(this, 'bem');
                this.cls = new Match(this, 'cls');

                BemxjstEntity.apply(this, arguments);
              }

              inherits(Entity, BemxjstEntity);
              exports.Entity = Entity;

              Entity.prototype.init = function(block, elem) {
                this.block = block;
                this.elem = elem;

                // Class for jsParams
                this.jsClass = this.bemxjst.classBuilder.build(this.block,
                    this.elem);
              };

              Entity.prototype._keys = {
                tag: 1,
                content: 1,
                attrs: 1,
                mix: 1,
                js: 1,
                mods: 1,
                elemMods: 1,
                cls: 1,
                bem: 1,
              };

              Entity.prototype.defaultBody = function(context) {
                context.mods = this.mods.exec(context);
                if (context.ctx.elem) context.elemMods = this.elemMods.exec(
                    context);

                return this.bemxjst.render(context,
                    this,
                    this.tag.exec(context),
                    this.js.exec(context),
                    this.bem.exec(context),
                    this.cls.exec(context),
                    this.mix.exec(context),
                    this.attrs.exec(context),
                    this.content.exec(context),
                    context.mods,
                    context.elemMods);
              };

            }, {'../bemxjst/entity': 5, '../bemxjst/match': 8, 'inherits': 11}],
          2: [
            function(require, module, exports) {
              var inherits = require('inherits');
              var utils = require('../bemxjst/utils');
              var Entity = require('./entity').Entity;
              var BEMXJST = require('../bemxjst');

              function BEMHTML(options) {
                BEMXJST.apply(this, arguments);

                this._shortTagCloser = typeof options.xhtml !== 'undefined' &&
                options.xhtml ? '/>' : '>';

                this._elemJsInstances = options.elemJsInstances;
                this._omitOptionalEndTags = options.omitOptionalEndTags;
                this._singleQuotesForDataAttrs =
                    typeof options.singleQuotesForDataAttrs === 'undefined' ?
                        false :
                        options.singleQuotesForDataAttrs;
                this._unquotedAttrs = typeof options.unquotedAttrs ===
                'undefined' ?
                    false :
                    options.unquotedAttrs;
              }

              inherits(BEMHTML, BEMXJST);
              module.exports = BEMHTML;

              BEMHTML.prototype.Entity = Entity;

              BEMHTML.prototype.runMany = function(arr) {
                var out = '';
                var context = this.context;
                var prevPos = context.position;
                var prevNotNewList = context._notNewList;

                if (prevNotNewList) {
                  context._listLength += arr.length - 1;
                } else {
                  context.position = 0;
                  context._listLength = arr.length;
                }
                context._notNewList = true;

                if (this.canFlush) {
                  for (var i = 0; i < arr.length; i++)
                    out += context._flush(this._run(arr[i]));
                } else {
                  for (var i = 0; i < arr.length; i++)
                    out += this._run(arr[i]);
                }

                if (!prevNotNewList)
                  context.position = prevPos;

                return out;
              };

              BEMHTML.prototype.render = function(context, entity, tag, js, bem,
                                                  cls, mix,
                                                  attrs, content, mods,
                                                  elemMods) {
                var ctx = context.ctx;

                if (tag === undefined)
                  tag = 'div';
                else if (!tag)
                  return (content || content === 0) ? this._run(content) : '';

                var out = '<' + tag;

                if (js === true)
                  js = {};

                var jsParams;
                if (js) {
                  jsParams = {};
                  jsParams[entity.jsClass] = js;
                }

                var isBEM = typeof bem !== 'undefined' ?
                    bem :
                    entity.block || entity.elem;
                isBEM = !!isBEM;

                var addJSInitClass = isBEM && jsParams && (
                    this._elemJsInstances ?
                        entity.block :
                        (entity.block && !entity.elem)
                );

                if (!isBEM && !cls)
                  return this.renderClose(out, context, tag, attrs, isBEM, ctx,
                      content);

                out += ' class=';
                var classValue = '';
                if (isBEM) {
                  classValue += entity.jsClass;
                  classValue += this.buildModsClasses(entity.block, entity.elem,
                      entity.elem ? elemMods : mods);

                  if (mix) {
                    var m = this.renderMix(entity, mix, jsParams,
                        addJSInitClass);
                    classValue += m.out;
                    jsParams = m.jsParams;
                    addJSInitClass = m.addJSInitClass;
                  }

                  if (cls)
                    classValue += ' ' + (typeof cls === 'string' ?
                        utils.attrEscape(cls).trim() : cls);
                } else {
                  classValue += typeof cls === 'string' ?
                      utils.attrEscape(cls).trim() : cls;
                }

                if (addJSInitClass)
                  classValue += ' i-bem';

                out += this._unquotedAttrs && utils.isUnquotedAttr(classValue) ?
                    classValue :
                    ('"' + classValue + '"');

                if (isBEM && jsParams)
                  out += ' data-bem=\'' +
                      utils.jsAttrEscape(JSON.stringify(jsParams)) + '\'';

                return this.renderClose(out, context, tag, attrs, isBEM, ctx,
                    content);
              };

              var OPTIONAL_END_TAGS = {
                // https://www.w3.org/TR/html4/index/elements.html
                html: 1,
                head: 1,
                body: 1,
                p: 1,
                li: 1,
                dt: 1,
                dd: 1,
                colgroup: 1,
                thead: 1,
                tbody: 1,
                tfoot: 1,
                tr: 1,
                th: 1,
                td: 1,
                option: 1,

                // html5 https://www.w3.org/TR/html5/syntax.html#optional-tags
                /* dl — Neither tag is omissible */
                rb: 1,
                rt: 1,
                rtc: 1,
                rp: 1,
                optgroup: 1,
              };

              BEMHTML.prototype.renderClose = function(prefix, context, tag,
                                                       attrs, isBEM,
                                                       ctx, content) {
                var out = prefix;

                out += this.renderAttrs(attrs);

                if (utils.isShortTag(tag)) {
                  out += this._shortTagCloser;
                  if (this.canFlush)
                    out = context._flush(out);
                } else {
                  out += '>';
                  if (this.canFlush)
                    out = context._flush(out);

                  // TODO(indutny): skip apply next flags
                  if (content || content === 0)
                    out += this.renderContent(content, isBEM);

                  if (!this._omitOptionalEndTags ||
                      !OPTIONAL_END_TAGS.hasOwnProperty(tag))
                    out += '</' + tag + '>';
                }

                if (this.canFlush)
                  out = context._flush(out);
                return out;
              };

              BEMHTML.prototype.renderAttrs = function(attrs) {
                var out = '';

                // NOTE: maybe we need to make an array for quicker serialization
                if (utils.isObj(attrs)) {

                  /* jshint forin : false */
                  for (var name in attrs) {
                    var attr = attrs[name];
                    if (attr === undefined || attr === false || attr === null)
                      continue;

                    if (attr === true) {
                      out += ' ' + name;
                    } else {
                      var attrVal = utils.isSimple(attr) ?
                          attr :
                          this.run(attr);
                      out += ' ' + name + '=';
                      out += (this._singleQuotesForDataAttrs &&
                          name.indexOf('data-') === 0) ?
                          '\'' + utils.jsAttrEscape(attrVal) + '\'' :
                          this.getAttrValue(attrVal);
                    }
                  }
                }

                return out;
              };

              BEMHTML.prototype.getAttrValue = function(attrVal) {
                return this._unquotedAttrs && utils.isUnquotedAttr(attrVal) ?
                    attrVal :
                    ('"' + utils.attrEscape(attrVal) + '"');
              };

              BEMHTML.prototype.renderMix = function(
                  entity, mix, jsParams, addJSInitClass) {
                var visited = {};
                var context = this.context;
                var js = jsParams;
                var addInit = addJSInitClass;

                visited[entity.jsClass] = true;

                // Transform mix to the single-item array if it's not array
                if (!Array.isArray(mix))
                  mix = [mix];

                var classBuilder = this.classBuilder;

                var out = '';
                for (var i = 0; i < mix.length; i++) {
                  var item = mix[i];
                  if (!item)
                    continue;
                  if (typeof item === 'string')
                    item = {block: item, elem: undefined};

                  var hasItem = false;

                  if (item.elem) {
                    hasItem = item.elem !== entity.elem && item.elem !==
                        context.elem ||
                        item.block && item.block !== entity.block;
                  } else if (item.block) {
                    hasItem = !(item.block === entity.block && item.mods) ||
                        item.mods && entity.elem;
                  }

                  var block = item.block || item._block || context.block;
                  var elem = item.elem || item._elem || context.elem;
                  var key = classBuilder.build(block, elem);

                  var classElem = item.elem ||
                      item._elem ||
                      (item.block ? undefined : context.elem);
                  if (hasItem)
                    out += ' ' + classBuilder.build(block, classElem);

                  out += this.buildModsClasses(block, classElem,
                      (item.elem || !item.block &&
                          (item._elem || context.elem)) ?
                          item.elemMods : item.mods);

                  if (item.js) {
                    if (!js)
                      js = {};

                    js[classBuilder.build(block, item.elem)] =
                        item.js === true ? {} : item.js;
                    if (!addInit)
                      addInit = this._elemJsInstances ?
                          (item.elem || block) :
                          (block && !item.elem);
                  }

                  // Process nexted mixes from BEMJON
                  if (item.mix) {
                    var nested = this.renderMix(entity, item.mix, js, addInit);
                    js = utils.extend(js, nested.jsParams);
                    addInit = nested.addJSInitClass;
                    out += nested.out;
                  }

                  // Process nested mixes from templates
                  if (!hasItem || visited[key])
                    continue;

                  visited[key] = true;
                  var nestedEntity = this.entities[key];
                  if (!nestedEntity)
                    continue;

                  var oldBlock = context.block;
                  var oldElem = context.elem;
                  var nestedMix = nestedEntity.mix.exec(context);
                  context.elem = oldElem;
                  context.block = oldBlock;

                  if (!nestedMix)
                    continue;

                  for (var j = 0; j < nestedMix.length; j++) {
                    var nestedItem = nestedMix[j];
                    if (!nestedItem) continue;

                    if (!nestedItem.block &&
                        !nestedItem.elem ||
                        !visited[classBuilder.build(nestedItem.block,
                            nestedItem.elem)]) {
                      if (nestedItem.block) continue;

                      nestedItem._block = block;
                      nestedItem._elem = elem;
                      mix = mix.slice(0, i + 1).concat(
                          nestedItem,
                          mix.slice(i + 1),
                      );
                    }
                  }
                }

                return {
                  out: out,
                  jsParams: js,
                  addJSInitClass: addInit,
                };
              };

              BEMHTML.prototype.buildModsClasses = function(block, elem, mods) {
                if (!mods)
                  return '';

                var res = '';

                var modName;

                /*jshint -W089 */
                for (modName in mods) {
                  if (!mods.hasOwnProperty(modName) || modName === '')
                    continue;

                  var modVal = mods[modName];
                  if (!modVal && modVal !== 0) continue;
                  if (typeof modVal !== 'boolean')
                    modVal += '';

                  var builder = this.classBuilder;
                  res += ' ' + (elem ?
                      builder.buildElemClass(block, elem, modName, modVal) :
                      builder.buildBlockClass(block, modName, modVal));
                }

                return res;
              };

            },
            {
              '../bemxjst': 7,
              '../bemxjst/utils': 10,
              './entity': 1,
              'inherits': 11,
            }],
          3: [
            function(require, module, exports) {
              function ClassBuilder(options) {
                this.elemDelim = options.elem || '__';

                this.modDelim = typeof options.mod === 'string' ?
                    {
                      name: options.mod || '_',
                      val: options.mod || '_',
                    } :
                    {
                      name: options.mod && options.mod.name || '_',
                      val: options.mod && options.mod.val || '_',
                    };
              }

              exports.ClassBuilder = ClassBuilder;

              ClassBuilder.prototype.build = function(block, elem) {
                if (!elem)
                  return block;
                else
                  return block + this.elemDelim + elem;
              };

              ClassBuilder.prototype.buildModPostfix = function(
                  modName, modVal) {
                var res = this.modDelim.name + modName;
                if (modVal !== true) res += this.modDelim.val + modVal;
                return res;
              };

              ClassBuilder.prototype.buildBlockClass = function(
                  name, modName, modVal) {
                var res = name;
                if (modVal) res += this.buildModPostfix(modName, modVal);
                return res;
              };

              ClassBuilder.prototype.buildElemClass = function(
                  block, name, modName, modVal) {
                return this.buildBlockClass(block) +
                    this.elemDelim +
                    name +
                    this.buildModPostfix(modName, modVal);
              };

              ClassBuilder.prototype.split = function(key) {
                return key.split(this.elemDelim, 2);
              };

            }, {}],
          4: [
            function(require, module, exports) {
              var utils = require('./utils');

              function Context(bemxjst) {
                this._bemxjst = bemxjst;

                this.ctx = null;
                this.block = '';

                // Save current block until the next BEM entity
                this._currBlock = '';

                this.elem = null;
                this.mods = {};
                this.elemMods = {};

                this.position = 0;
                this._listLength = 0;
                this._notNewList = false;

                this.escapeContent = bemxjst.options.escapeContent !== false;
              }

              exports.Context = Context;

              Context.prototype._flush = null;

              Context.prototype.isSimple = utils.isSimple;

              Context.prototype.isShortTag = utils.isShortTag;
              Context.prototype.extend = utils.extend;
              Context.prototype.identify = utils.identify;

              Context.prototype.xmlEscape = utils.xmlEscape;
              Context.prototype.attrEscape = utils.attrEscape;
              Context.prototype.jsAttrEscape = utils.jsAttrEscape;

              Context.prototype.onError = function(context, e) {
                console.error('bem-xjst rendering error:', {
                  block: context.ctx.block,
                  elem: context.ctx.elem,
                  mods: context.ctx.mods,
                  elemMods: context.ctx.elemMods,
                }, e);
              };

              Context.prototype.isFirst = function() {
                return this.position === 1;
              };

              Context.prototype.isLast = function() {
                return this.position === this._listLength;
              };

              Context.prototype.generateId = function() {
                return utils.identify(this.ctx);
              };

              Context.prototype.reapply = function(ctx) {
                return this._bemxjst.run(ctx);
              };

            }, {'./utils': 10}],
          5: [
            function(require, module, exports) {
              var utils = require('./utils');
              var Match = require('./match').Match;
              var tree = require('./tree');
              var Template = tree.Template;
              var PropertyMatch = tree.PropertyMatch;
              var CompilerOptions = tree.CompilerOptions;

              function Entity(bemxjst, block, elem, templates) {
                this.bemxjst = bemxjst;

                this.block = null;
                this.elem = null;

                // Compiler options via `xjstOptions()`
                this.options = {};

                // `true` if entity has just a default renderer for `def()` mode
                this.canFlush = true;

                // "Fast modes"
                this.def = new Match(this);
                this.mix = new Match(this, 'mix');
                this.js = new Match(this, 'js');
                this.mods = new Match(this, 'mods');
                this.elemMods = new Match(this, 'elemMods');
                this.content = new Match(this, 'content');

                // "Slow modes"
                this.rest = {};

                // Initialize
                this.init(block, elem);
                this.initModes(templates);
              }

              exports.Entity = Entity;

              Entity.prototype.init = function(block, elem) {
                this.block = block;
                this.elem = elem;
              };

              Entity.prototype._keys = {
                content: 1,
                mix: 1,
                js: 1,
                mods: 1,
                elemMods: 1,
              };

              Entity.prototype._initRest = function(key) {
                if (key === 'default') {
                  this.rest[key] = this.def;
                } else if (this._keys[key]) {
                  this.rest[key] = this[key];
                } else {
                  this.rest[key] = this.rest[key] || new Match(this, key);
                }
              };

              Entity.prototype.initModes = function(templates) {
                /* jshint maxdepth : false */
                for (var i = 0; i < templates.length; i++) {
                  var template = templates[i];

                  for (var j = template.predicates.length - 1; j >= 0; j--) {
                    var pred = template.predicates[j];
                    if (!(pred instanceof PropertyMatch))
                      continue;

                    if (pred.key !== '_mode')
                      continue;

                    template.predicates.splice(j, 1);
                    this._initRest(pred.value);

                    // All templates should go there anyway
                    this.rest[pred.value].push(template);
                    break;
                  }

                  if (j === -1)
                    this.def.push(template);

                  // Merge compiler options
                  for (var j = template.predicates.length - 1; j >= 0; j--) {
                    var pred = template.predicates[j];
                    if (!(pred instanceof CompilerOptions))
                      continue;

                    this.options = utils.extend(this.options, pred.options);
                  }
                }
              };

              Entity.prototype.prepend = function(other) {
                // Prepend to the slow modes, fast modes are in this hashmap too anyway
                var keys = Object.keys(this.rest);
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  if (!other.rest[key])
                    continue;

                  this.rest[key].prepend(other.rest[key]);
                }

                // Add new slow modes
                keys = Object.keys(other.rest);
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  if (this.rest[key])
                    continue;

                  this._initRest(key);
                  this.rest[key].prepend(other.rest[key]);
                }
              };

// NOTE: This could be potentially compiled into inlined invokations
              Entity.prototype.run = function(context) {
                if (this.def.count !== 0)
                  return this.def.exec(context);

                return this.defaultBody(context);
              };

              function contentMode() {
                return this.ctx.content;
              }

              Entity.prototype.setDefaults = function() {
                // Default .content() template for applyNext()
                if (this.content.count !== 0)
                  this.content.push(new Template([], contentMode));

                // .def() default
                if (this.def.count !== 0) {
                  this.canFlush = this.options.flush || false;
                  var self = this;
                  this.def.push(new Template([], function defaultBodyProxy() {
                    return self.defaultBody(this);
                  }));
                }
              };

            }, {'./match': 8, './tree': 9, './utils': 10}],
          6: [
            function(require, module, exports) {
              function BEMXJSTError(msg, func) {
                this.name = 'BEMXJSTError';
                this.message = msg;

                if (Error.captureStackTrace)
                  Error.captureStackTrace(this, func || this.constructor);
                else
                  this.stack = (new Error()).stack;
              }

              BEMXJSTError.prototype = Object.create(Error.prototype);
              BEMXJSTError.prototype.constructor = BEMXJSTError;

              exports.BEMXJSTError = BEMXJSTError;

            }, {}],
          7: [
            function(require, module, exports) {
              var inherits = require('inherits');

              var Tree = require('./tree').Tree;
              var PropertyMatch = require('./tree').PropertyMatch;
              var AddMatch = require('./tree').AddMatch;
              var Context = require('./context').Context;
              var ClassBuilder = require('./class-builder').ClassBuilder;
              var utils = require('./utils');

              function BEMXJST(options) {
                this.options = options;

                this.entities = null;
                this.defaultEnt = null;

                // Current tree
                this.tree = null;

                // Current match
                this.match = null;

                // Create new Context constructor for overriding prototype
                this.contextConstructor = function ContextChild(bemxjst) {
                  Context.call(this, bemxjst);
                };
                inherits(this.contextConstructor, Context);
                this.context = null;

                this.classBuilder = new ClassBuilder(this.options.naming || {});

                // Execution depth, used to invalidate `applyNext` bitfields
                this.depth = 0;

                // Do not call `_flush` on overridden `def()` mode
                this.canFlush = false;

                // oninit templates
                this.oninit = null;

                // Initialize default entity (no block/elem match)
                this.defaultEnt = new this.Entity(this, '', '', []);
                this.defaultElemEnt = new this.Entity(this, '', '', []);
              }

              module.exports = BEMXJST;

              BEMXJST.prototype.locals = Tree.methods.concat('local',
                  'applyCtx', 'applyNext', 'apply');

              BEMXJST.prototype.runOninit = function(oninits, ret) {
                var self = ret || this;

                self.BEMContext = this.contextConstructor;
                for (var i = 0; i < oninits.length; i++) {
                  // NOTE: oninit has global context instead of BEMXJST
                  var oninit = oninits[i];
                  oninit(self, {BEMContext: self.BEMContext});
                }
              };

              BEMXJST.prototype.compile = function(code) {
                var self = this;

                function applyCtx() {
                  return self.run(self.context.ctx);
                }

                function _applyCtx() {
                  return self._run(self.context.ctx);
                }

                function applyCtxWrap(ctx, changes) {
                  // Fast case
                  if (!changes)
                    return self.local({ctx: ctx}, applyCtx);

                  return self.local(changes, function() {
                    return self.local({ctx: ctx}, _applyCtx);
                  });
                }

                function _applyCtxWrap(ctx, changes) {
                  // Fast case
                  if (!changes)
                    return self.local({ctx: ctx}, _applyCtx);

                  return self.local(changes, function() {
                    return self.local({ctx: ctx}, applyCtx);
                  });
                }

                function apply(mode, changes) {
                  return self.applyMode(mode, changes);
                }

                function localWrap(changes) {
                  return function localBody(body) {
                    return self.local(changes, body);
                  };
                }

                var tree = new Tree({
                  refs: {
                    applyCtx: applyCtxWrap,
                    _applyCtx: _applyCtxWrap,
                    apply: apply,
                  },
                });

                // Yeah, let people pass functions to us!
                var templates = this.recompileInput(code);

                var out = tree.build(templates, [
                  localWrap,
                  applyCtxWrap,
                  function applyNextWrap(changes) {
                    if (changes)
                      return self.local(changes, applyNextWrap);
                    return self.applyNext();
                  },
                  apply,
                ]);

                // Concatenate templates with existing ones
                // TODO(indutny): it should be possible to incrementally add templates
                if (this.tree) {
                  this.runOninit(out.oninit);

                  out = {
                    templates: out.templates.concat(this.tree.templates),
                    oninit: this.tree.oninit.concat(out.oninit),
                  };
                }
                this.tree = out;

                // Group block+elem entities into a hashmap
                var ent = this.groupEntities(out.templates);

                // Transform entities from arrays to Entity instances
                ent = this.transformEntities(ent);

                this.entities = ent;
                this.oninit = out.oninit;
              };

              BEMXJST.prototype.getTemplate = function(code, options) {
                this.compile(code, options);

                return this.exportApply();
              };

              BEMXJST.prototype.recompileInput = function(code) {
                var args = BEMXJST.prototype.locals;
                // Reuse function if it already has right arguments
                if (typeof code === 'function' && code.length === args.length)
                  return code;

                return new Function(args.join(', '), utils.fnToString(code));
              };

              BEMXJST.prototype.groupEntities = function(tree) {
                var res = {};
                for (var i = 0; i < tree.length; i++) {
                  // Make sure to change only the copy, the original is cached in `this.tree`
                  var template = tree[i].clone();
                  var block = null;
                  var elem;

                  elem = undefined;
                  for (var j = 0; j < template.predicates.length; j++) {
                    var pred = template.predicates[j];
                    if (!(pred instanceof PropertyMatch) &&
                        !(pred instanceof AddMatch))
                      continue;

                    if (pred.key === 'block')
                      block = pred.value;
                    else if (pred.key === 'elem')
                      elem = pred.value;
                    else
                      continue;

                    // Remove predicate, we won't much against it
                    template.predicates.splice(j, 1);
                    j--;
                  }

                  if (block === null) {
                    var msg = 'block(…) subpredicate is not found.\n' +
                        '    See template with subpredicates:\n     * ';

                    for (var j = 0; j < template.predicates.length; j++) {
                      var pred = template.predicates[j];

                      if (j !== 0)
                        msg += '\n     * ';

                      if (pred.key === '_mode') {
                        msg += pred.value + '()';
                      } else {
                        if (Array.isArray(pred.key)) {
                          msg += pred.key[0].replace('mods', 'mod').
                                  replace('elemMods', 'elemMod') +
                              '(\'' + pred.key[1] + '\', \'' + pred.value +
                              '\')';
                        } else {
                          msg += 'match(…)';
                        }
                      }
                    }

                    msg += '\n    And template body: \n    (' +
                        (typeof template.body === 'function' ?
                            template.body :
                            JSON.stringify(template.body)) + ')';

                    if (typeof BEMXJSTError === 'undefined') {
                      BEMXJSTError = require('./error').BEMXJSTError;
                    }

                    throw new BEMXJSTError(msg);
                  }

                  var key = this.classBuilder.build(block, elem);

                  if (!res[key])
                    res[key] = [];
                  res[key].push(template);
                }
                return res;
              };

              BEMXJST.prototype.transformEntities = function(entities) {
                var wildcardElems = [];

                var keys = Object.keys(entities);
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];

                  // TODO(indutny): pass this values over
                  var parts = this.classBuilder.split(key);
                  var block = parts[0];
                  var elem = parts[1];

                  if (elem === '*')
                    wildcardElems.push(block);

                  entities[key] = new this.Entity(
                      this, block, elem, entities[key]);
                }

                // Merge wildcard block templates
                if (entities.hasOwnProperty('*')) {
                  var wildcard = entities['*'];
                  for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (key === '*')
                      continue;

                    entities[key].prepend(wildcard);
                  }
                  this.defaultEnt.prepend(wildcard);
                  this.defaultElemEnt.prepend(wildcard);
                }

                // Merge wildcard elem templates
                for (var i = 0; i < wildcardElems.length; i++) {
                  var block = wildcardElems[i];
                  var wildcardKey = this.classBuilder.build(block, '*');
                  var wildcard = entities[wildcardKey];
                  for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (key === wildcardKey)
                      continue;

                    var entity = entities[key];
                    if (entity.block !== block || entity.elem === undefined)
                      continue;

                    entities[key].prepend(wildcard);
                  }
                  this.defaultElemEnt.prepend(wildcard);
                }

                // Set default templates after merging with wildcard
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  entities[key].setDefaults();
                  this.defaultEnt.setDefaults();
                  this.defaultElemEnt.setDefaults();
                }

                return entities;
              };

              BEMXJST.prototype._run = function(context) {
                if (context === undefined || context === '' || context === null)
                  return this.runEmpty();
                else if (Array.isArray(context))
                  return this.runMany(context);
                else if (
                    typeof context.html === 'string' &&
                    !context.tag &&
                    typeof context.block === 'undefined' &&
                    typeof context.elem === 'undefined' &&
                    typeof context.cls === 'undefined' &&
                    typeof context.attrs === 'undefined'
                )
                  return this.runUnescaped(context);
                else if (utils.isSimple(context))
                  return this.runSimple(context);

                return this.runOne(context);
              };

              BEMXJST.prototype.run = function(json) {
                var match = this.match;
                var context = this.context;
                var depth = this.depth;

                this.match = null;
                this.context = new this.contextConstructor(this);
                this.canFlush = this.context._flush !== null;
                this.depth = 0;
                var res = this._run(json);

                if (this.canFlush)
                  res = this.context._flush(res);

                this.match = match;
                this.context = context;
                this.depth = depth;

                return res;
              };

              BEMXJST.prototype.runEmpty = function() {
                this.context._listLength--;
                return '';
              };

              BEMXJST.prototype.runUnescaped = function(context) {
                this.context._listLength--;
                return '' + context.html;
              };

              BEMXJST.prototype.runSimple = function(simple) {
                this.context._listLength--;
                if (!simple && simple !== 0 || simple === true)
                  return '';

                return typeof simple === 'string' &&
                this.context.escapeContent ?
                    utils.xmlEscape(simple) :
                    simple;
              };

              BEMXJST.prototype.runOne = function(json) {
                var context = this.context;

                var oldCtx = context.ctx;
                var oldBlock = context.block;
                var oldCurrBlock = context._currBlock;
                var oldElem = context.elem;
                var oldMods = context.mods;
                var oldElemMods = context.elemMods;

                if (json.block || json.elem)
                  context._currBlock = '';
                else
                  context._currBlock = context.block;

                context.ctx = json;
                if (json.block) {
                  context.block = json.block;

                  if (json.mods)
                    context.mods = json.mods;
                  else if (json.block !== oldBlock || !json.elem)
                    context.mods = {};
                } else {
                  if (!json.elem)
                    context.block = '';
                  else if (oldCurrBlock)
                    context.block = oldCurrBlock;
                }

                context.elem = json.elem;
                if (json.elemMods)
                  context.elemMods = json.elemMods;
                else
                  context.elemMods = {};

                var block = context.block || '';
                var elem = context.elem;

                // Control list position
                if (block || elem)
                  context.position++;
                else
                  context._listLength--;

                // To invalidate `applyNext` flags
                this.depth++;

                var restoreFlush = false;
                var ent = this.entities[this.classBuilder.build(block, elem)];
                if (ent) {
                  if (this.canFlush && !ent.canFlush) {
                    // Entity does not support flushing, do not flush anything nested
                    restoreFlush = true;
                    this.canFlush = false;
                  }
                } else {
                  // No entity - use default one
                  ent = this.defaultEnt;
                  if (elem !== undefined)
                    ent = this.defaultElemEnt;
                  ent.init(block, elem);
                }

                var res = this.options.production === true ?
                    this.tryRun(context, ent) :
                    ent.run(context);

                context.ctx = oldCtx;
                context.block = oldBlock;
                context.elem = oldElem;
                context.mods = oldMods;
                context.elemMods = oldElemMods;
                context._currBlock = oldCurrBlock;
                this.depth--;
                if (restoreFlush)
                  this.canFlush = true;

                return res;
              };

              BEMXJST.prototype.tryRun = function(context, ent) {
                try {
                  return ent.run(context);
                } catch (e) {
                  return context.onError(context, e) || '';
                }
              };

              BEMXJST.prototype.renderContent = function(content, isBEM) {
                var context = this.context;
                var oldPos = context.position;
                var oldListLength = context._listLength;
                var oldNotNewList = context._notNewList;

                context._notNewList = false;
                if (isBEM) {
                  context.position = 0;
                  context._listLength = 1;
                }

                var res = this._run(content);

                context.position = oldPos;
                context._listLength = oldListLength;
                context._notNewList = oldNotNewList;

                return res;
              };

              BEMXJST.prototype.local = function(changes, body) {
                var keys = Object.keys(changes);
                var restore = [];
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  var parts = key.split('.');

                  var value = this.context;
                  for (var j = 0; j < parts.length - 1; j++)
                    value = value[parts[j]];

                  restore.push({
                    parts: parts,
                    value: value[parts[j]],
                  });
                  value[parts[j]] = changes[key];
                }

                var res = body.call(this.context);

                for (var i = 0; i < restore.length; i++) {
                  var parts = restore[i].parts;
                  var value = this.context;
                  for (var j = 0; j < parts.length - 1; j++)
                    value = value[parts[j]];

                  value[parts[j]] = restore[i].value;
                }

                return res;
              };

              BEMXJST.prototype.applyNext = function() {
                return this.match.exec(this.context);
              };

              BEMXJST.prototype.applyMode = function(mode, changes) {
                var key;
                var match = this.match;

                if (!match) {
                  var key = this.classBuilder.build(this.context.block,
                      this.context.elem);
                  match = this.entities[key].rest[mode];
                } else {
                  match = this.match.entity.rest[mode];
                }

                if (!match) {
                  if (mode === 'mods')
                    return this.context.mods;

                  if (mode === 'elemMods')
                    return this.context.elemMods;

                  return this.context.ctx[mode];
                }

                if (!changes)
                  return match.exec(this.context);

                var self = this;

                // Allocate function this way, to prevent allocation at the top of the
                // `applyMode`
                var localBody = function() {
                  return match.exec(self.context);
                };
                return this.local(changes, localBody);
              };

              BEMXJST.prototype.exportApply = function(exports) {
                var self = this;
                var ret = exports || {};

                ret.apply = function(context) {
                  return self.run(context);
                };

                // Add templates at run time
                ret.compile = function(templates) {
                  self.compile(templates);
                  return ret;
                };

                this.runOninit(self.oninit, ret);

                return ret;
              };

            },
            {
              './class-builder': 3,
              './context': 4,
              './error': 6,
              './tree': 9,
              './utils': 10,
              'inherits': 11,
            }],
          8: [
            function(require, module, exports) {
              var tree = require('./tree');
              var PropertyMatch = tree.PropertyMatch;
              var AddMatch = tree.AddMatch;
              var WrapMatch = tree.WrapMatch;
              var ExtendMatch = tree.ExtendMatch;
              var CustomMatch = tree.CustomMatch;

              function MatchNested(template, pred) {
                this.template = template;
                this.keys = pred.key;
                this.value = pred.value;
              }

              MatchNested.prototype.exec = function(context) {
                var val = context;

                for (var i = 0; i < this.keys.length - 1; i++) {
                  val = val[this.keys[i]];
                  if (!val)
                    return false;
                }

                val = val[this.keys[i]];

                if (this.value === true)
                  return val !== undefined && val !== '' && val !== false &&
                      val !== null;

                return String(val) === this.value;
              };

              function MatchCustom(template, pred) {
                this.template = template;
                this.body = pred.body;
              }

              MatchCustom.prototype.exec = function(context) {
                return this.body.call(context, context, context.ctx);
              };

              function MatchWrap(template) {
                this.template = template;
                this.wrap = null;
              }

              MatchWrap.prototype.exec = function(context) {
                var res = this.wrap !== context.ctx;
                this.wrap = context.ctx;
                return res;
              };

              function MatchExtend(template) {
                this.template = template;
                this.wrap = null;
              }

              MatchExtend.prototype.exec = function(context) {
                var res = this.ext !== context.ctx;
                this.ext = context.ctx;
                return res;
              };

              function AddWrap(template, pred) {
                this.template = template;
                this.key = pred.key;
                this.value = pred.value;
              }

              AddWrap.prototype.exec = function(context) {
                return context[this.key] === this.value;
              };

              function MatchTemplate(mode, template) {
                this.mode = mode;
                this.predicates = new Array(template.predicates.length);
                this.body = template.body;

                var postpone = [];

                for (var i = 0, j = 0; i < this.predicates.length; i++, j++) {
                  var pred = template.predicates[i];
                  if (pred instanceof PropertyMatch) {
                    this.predicates[j] = new MatchNested(this, pred);
                  } else if (pred instanceof ExtendMatch) {
                    j--;
                    postpone.push(new MatchExtend(this));
                  } else if (pred instanceof AddMatch) {
                    this.predicates[j] = new AddWrap(this, pred);
                  } else if (pred instanceof CustomMatch) {
                    this.predicates[j] = new MatchCustom(this, pred);

                    // Push MatchWrap later, they should not be executed first.
                    // Otherwise they will set flag too early, and body might not be executed
                  } else if (pred instanceof WrapMatch) {
                    j--;
                    postpone.push(new MatchWrap(this));
                  } else {
                    // Skip
                    j--;
                  }
                }

                // Insert late predicates
                for (var i = 0; i < postpone.length; i++, j++)
                  this.predicates[j] = postpone[i];

                if (this.predicates.length !== j)
                  this.predicates.length = j;
              }

              exports.MatchTemplate = MatchTemplate;

              function Match(entity, modeName) {
                this.entity = entity;
                this.modeName = modeName;
                this.bemxjst = this.entity.bemxjst;
                this.templates = [];

                // applyNext mask
                this.mask = [0];

                // We are going to create copies of mask for nested `applyNext()`
                this.maskSize = 0;
                this.maskOffset = 0;

                this.count = 0;
                this.depth = -1;

                this.thrownError = null;
              }

              exports.Match = Match;

              Match.prototype.prepend = function(other) {
                this.templates = other.templates.concat(this.templates);
                this.count += other.count;

                while (Math.ceil(this.count / 31) > this.mask.length)
                  this.mask.push(0);

                this.maskSize = this.mask.length;
              };

              Match.prototype.push = function(template) {
                this.templates.push(new MatchTemplate(this, template));
                this.count++;

                if (Math.ceil(this.count / 31) > this.mask.length)
                  this.mask.push(0);

                this.maskSize = this.mask.length;
              };

              Match.prototype.tryCatch = function(fn, ctx) {
                try {
                  return fn.call(ctx, ctx, ctx.ctx);
                } catch (e) {
                  this.thrownError = e;
                  if (this.modeName) {
                    this.thrownError.ctx = ctx;
                    this.thrownError.name = 'BEMXJST ERROR';
                    var classBuilder = this.entity.bemxjst.classBuilder;

                    var cause = e.stack.split('\n')[1];
                    this.thrownError.message = 'Template error in mode ' +
                        this.modeName + ' in block ' +
                        classBuilder.build(ctx.ctx.block, ctx.ctx.elem) +
                        '\n    ' + e.message + '\n';
                    this.thrownError.stack = this.thrownError.name + ': ' +
                        this.thrownError.message + ' ' + cause + '\n' + e.stack;
                  }
                }
              };

              Match.prototype.exec = function(context) {
                var save = this.checkDepth();

                var template;
                var bitIndex = this.maskOffset;
                var mask = this.mask[bitIndex];
                var bit = 1;
                for (var i = 0; i < this.count; i++) {
                  if ((mask & bit) === 0) {
                    template = this.templates[i];
                    for (var j = 0; j < template.predicates.length; j++) {
                      var pred = template.predicates[j];

                      /* jshint maxdepth : false */
                      if (!pred.exec(context))
                        break;
                    }

                    // All predicates matched!
                    if (j === template.predicates.length)
                      break;
                  }

                  if (bit === 0x40000000) {
                    bitIndex++;
                    mask = this.mask[bitIndex];
                    bit = 1;
                  } else {
                    bit <<= 1;
                  }
                }

                if (i === this.count) {
                  this.restoreDepth(save);

                  if (this.modeName === 'mods')
                    return context.mods;

                  if (this.modeName === 'elemMods')
                    return context.elemMods;

                  return context.ctx[this.modeName];
                }

                var oldMask = mask;
                var oldMatch = this.bemxjst.match;
                this.mask[bitIndex] |= bit;
                this.bemxjst.match = this;

                this.thrownError = null;

                var out;
                if (typeof template.body === 'function')
                  out = this.tryCatch(template.body, context);
                else
                  out = template.body;

                this.mask[bitIndex] = oldMask;
                this.bemxjst.match = oldMatch;
                this.restoreDepth(save);

                var e = this.thrownError;
                if (e !== null) {
                  this.thrownError = null;
                  throw e;
                }

                return out;
              };

              Match.prototype.checkDepth = function() {
                if (this.depth === -1) {
                  this.depth = this.bemxjst.depth;
                  return -1;
                }

                if (this.bemxjst.depth === this.depth)
                  return this.depth;

                var depth = this.depth;
                this.depth = this.bemxjst.depth;

                this.maskOffset += this.maskSize;

                while (this.mask.length < this.maskOffset + this.maskSize)
                  this.mask.push(0);

                return depth;
              };

              Match.prototype.restoreDepth = function(depth) {
                if (depth !== -1 && depth !== this.depth)
                  this.maskOffset -= this.maskSize;
                this.depth = depth;
              };

            }, {'./tree': 9}],
          9: [
            function(require, module, exports) {
              var inherits = require('inherits');
              var utils = require('./utils');

              function Template(predicates, body) {
                this.predicates = predicates;

                this.body = body;
              }

              exports.Template = Template;

              Template.prototype.wrap = function() {
                var body = this.body;
                for (var i = 0; i < this.predicates.length; i++) {
                  var pred = this.predicates[i];
                  body = pred.wrapBody(body);
                }
                this.body = body;
              };

              Template.prototype.clone = function() {
                return new Template(this.predicates.slice(), this.body);
              };

              function MatchBase() {
              }

              exports.MatchBase = MatchBase;

              MatchBase.prototype.wrapBody = function(body) {
                return body;
              };

              function Item(tree, children) {
                this.conditions = [];
                this.children = [];

                for (var i = children.length - 1; i >= 0; i--) {
                  var arg = children[i];
                  if (arg instanceof MatchBase)
                    this.conditions.push(arg);
                  else if (arg === tree.boundBody)
                    this.children[i] = tree.queue.pop();
                  else
                    this.children[i] = arg;
                }
              }

              function WrapMatch(refs) {
                MatchBase.call(this);

                this.refs = refs;
              }

              inherits(WrapMatch, MatchBase);
              exports.WrapMatch = WrapMatch;

              WrapMatch.prototype.wrapBody = function(body) {
                var _applyCtx = this.refs._applyCtx;

                if (typeof body !== 'function') {
                  return function() {
                    return _applyCtx(body);
                  };
                }

                return function() {
                  return _applyCtx(body.call(this, this, this.ctx));
                };
              };

              function ReplaceMatch(refs) {
                MatchBase.call(this);

                this.refs = refs;
              }

              inherits(ReplaceMatch, MatchBase);
              exports.ReplaceMatch = ReplaceMatch;

              ReplaceMatch.prototype.wrapBody = function(body) {
                var applyCtx = this.refs.applyCtx;

                if (typeof body !== 'function') {
                  return function() {
                    return applyCtx(body, {position: this.position - 1});
                  };
                }

                return function() {
                  return applyCtx(body.call(this, this, this.ctx),
                      {position: this.position - 1});
                };
              };

              function ExtendMatch(refs) {
                MatchBase.call(this);

                this.refs = refs;
              }

              inherits(ExtendMatch, MatchBase);
              exports.ExtendMatch = ExtendMatch;

              ExtendMatch.prototype.wrapBody = function(body) {
                var refs = this.refs;
                var applyCtx = refs.applyCtx;

                if (typeof body !== 'function') {
                  return function() {
                    var changes = {};

                    var keys = Object.keys(body);
                    for (var i = 0; i < keys.length; i++)
                      changes[keys[i]] = body[keys[i]];

                    return applyCtx(this.ctx, changes);
                  };
                }

                return function() {
                  var changes = {};

                  var obj = body.call(this, this, this.ctx);
                  var keys = Object.keys(obj);
                  for (var i = 0; i < keys.length; i++)
                    changes[keys[i]] = obj[keys[i]];

                  return applyCtx(this.ctx, changes);
                };
              };

              function AddMatch(mode, refs) {
                MatchBase.call(this);

                this.mode = mode;
                this.refs = refs;
              }

              inherits(AddMatch, MatchBase);
              exports.AddMatch = AddMatch;

              AddMatch.prototype.wrapBody = function(body) {
                return this[this.mode + 'WrapBody'](body);
              };

              AddMatch.prototype.appendContentWrapBody = function(body) {
                var apply = this.refs.apply;

                if (typeof body !== 'function') {
                  return function() {
                    return [apply('content'), body];
                  };
                }

                return function() {
                  return [apply('content'), body.call(this, this, this.ctx)];
                };
              };

              AddMatch.prototype.prependContentWrapBody = function(body) {
                var apply = this.refs.apply;

                if (typeof body !== 'function') {
                  return function() {
                    return [body, apply('content')];
                  };
                }

                return function() {
                  return [body.call(this, this, this.ctx), apply('content')];
                };
              };

              AddMatch.prototype.mixWrapBody = function(body) {
                var apply = this.refs.apply;

                if (typeof body !== 'function') {
                  return function() {
                    var ret = apply('mix');
                    /* istanbul ignore else */
                    if (!Array.isArray(ret)) ret = [ret];
                    return ret.concat(body);
                  };
                }

                return function() {
                  var ret = apply('mix');
                  if (!Array.isArray(ret)) ret = [ret];
                  return ret.concat(body.call(this, this, this.ctx));
                };
              };

              ['attrs', 'js', 'mods', 'elemMods'].forEach(function(method) {
                AddMatch.prototype[method + 'WrapBody'] = function(body) {
                  var apply = this.refs.apply;

                  return typeof body !== 'function' ?
                      function() {
                        return (this[method] = utils.extend(apply(method) || {},
                            body));
                      } :
                      function() {
                        return (this[method] = utils.extend(apply(method) || {},
                            body.call(this, this, this.ctx)));
                      };
                };
              });

              function CompilerOptions(options) {
                MatchBase.call(this);
                this.options = options;
              }

              inherits(CompilerOptions, MatchBase);
              exports.CompilerOptions = CompilerOptions;

              function PropertyMatch(key, value) {
                MatchBase.call(this);

                this.key = key;
                this.value = value;
              }

              inherits(PropertyMatch, MatchBase);
              exports.PropertyMatch = PropertyMatch;

              function CustomMatch(body) {
                MatchBase.call(this);

                this.body = body;
              }

              inherits(CustomMatch, MatchBase);
              exports.CustomMatch = CustomMatch;

              function Tree(options) {
                this.options = options;
                this.refs = this.options.refs;

                this.boundBody = this.body.bind(this);

                var methods = this.methods('body');
                for (var i = 0; i < methods.length; i++) {
                  var method = methods[i];
                  // NOTE: method.name is empty because of .bind()
                  this.boundBody[Tree.methods[i]] = method;
                }

                this.queue = [];
                this.templates = [];
                this.initializers = [];
              }

              exports.Tree = Tree;

              Tree.methods = [
                // Subpredicates:
                'match', 'block', 'elem', 'mod', 'elemMod',
                // Runtime related:
                'oninit', 'xjstOptions',
                // Output generators:
                'wrap', 'replace', 'extend', 'mode', 'def',
                'content', 'appendContent', 'prependContent',
                'attrs', 'addAttrs', 'js', 'addJs', 'mix', 'addMix',
                'mods', 'addMods', 'addElemMods', 'elemMods',
                'tag', 'cls', 'bem',
              ];

              Tree.prototype.build = function(templates, apply) {
                var methods = this.methods('global').concat(apply);
                methods[0] = this.match.bind(this);

                templates.apply({}, methods);

                return {
                  templates: this.templates.slice().reverse(),
                  oninit: this.initializers,
                };
              };

              function methodFactory(self, kind, name) {
                var method = self[name];
                var boundBody = self.boundBody;

                if (kind !== 'body') {
                  if (name === 'replace' || name === 'extend' || name ===
                      'wrap') {
                    return function() {
                      return method.apply(self, arguments);
                    };
                  }

                  return function() {
                    method.apply(self, arguments);
                    return boundBody;
                  };
                }

                return function() {
                  var res = method.apply(self, arguments);

                  // Insert body into last item
                  var child = self.queue.pop();
                  var last = self.queue[self.queue.length - 1];
                  last.conditions = last.conditions.concat(child.conditions);
                  last.children = last.children.concat(child.children);

                  if (name === 'replace' || name === 'extend' || name ===
                      'wrap')
                    return res;
                  return boundBody;
                };
              }

              Tree.prototype.methods = function(kind) {
                var out = new Array(Tree.methods.length);

                for (var i = 0; i < out.length; i++) {
                  var name = Tree.methods[i];
                  out[i] = methodFactory(this, kind, name);
                }

                return out;
              };

// Called after all matches
              Tree.prototype.flush = function(conditions, item) {
                var subcond = item.conditions ?
                    conditions.concat(item.conditions) :
                    item.conditions;

                for (var i = 0; i < item.children.length; i++) {
                  var arg = item.children[i];

                  // Go deeper
                  if (arg instanceof Item) {
                    this.flush(subcond, item.children[i]);

                    // Body
                  } else {
                    if (this.isShortcutAllowed(arg, conditions)) {
                      var keys = Object.keys(arg);
                      for (var n = 0; n < keys.length; n++)
                        this.addTemplate(
                            conditions.concat(this.createMatch(keys[n])),
                            arg[keys[n]],
                        );
                    } else {
                      this.addTemplate(conditions, arg);
                    }
                  }
                }
              };

              Tree.prototype.createMatch = function(modeName) {
                switch (modeName) {
                  case 'addAttrs':
                    return [
                      new PropertyMatch('_mode', 'attrs'),
                      new AddMatch('attrs', this.refs),
                    ];
                  case 'addJs':
                    return [
                      new PropertyMatch('_mode', 'js'),
                      new AddMatch('js', this.refs),
                    ];
                  case 'addMix':
                    return [
                      new PropertyMatch('_mode', 'mix'),
                      new AddMatch('mix', this.refs),
                    ];
                  case 'addMods':
                    return [
                      new PropertyMatch('_mode', 'mods'),
                      new AddMatch('mods', this.refs),
                    ];
                  case 'addElemMods':
                    return [
                      new PropertyMatch('_mode', 'elemMods'),
                      new AddMatch('elemMods', this.refs),
                    ];
                  case 'appendContent':
                  case 'prependContent':
                    return [
                      new PropertyMatch('_mode', 'content'),
                      new AddMatch(modeName, this.refs),
                    ];

                  case 'wrap':
                    return new WrapMatch(this.refs);

                  case 'replace':
                    return new ReplaceMatch(this.refs);

                  case 'extend':
                    return new ExtendMatch(this.refs);

                  case 'def':
                    return new PropertyMatch('_mode', 'default');

                  default:
                    return new PropertyMatch('_mode', modeName);
                }
              };

              Tree.prototype.addTemplate = function(conditions, arg) {
                var template = new Template(conditions, arg);
                template.wrap();
                this.templates.push(template);
              };

              Tree.prototype.body = function() {
                var children = new Array(arguments.length);
                for (var i = 0; i < arguments.length; i++)
                  children[i] = arguments[i];

                var child = new Item(this, children);
                this.queue[this.queue.length - 1].children.push(child);

                if (this.queue.length === 1)
                  this.flush([], this.queue.shift());

                return this.boundBody;
              };

              Tree.modsCheck = {mods: 1, elemMods: 1};

              Tree.checkConditions = function(conditions) {
                for (var i = 0; i < conditions.length; i++) {
                  var condition = conditions[i];
                  if (condition.key === 'block' ||
                      condition.key === 'elem' ||
                      (Array.isArray(condition.key) &&
                          Tree.modsCheck[condition.key[0]]) ||
                      condition instanceof CustomMatch) continue;
                  return false;
                }

                return true;
              };

              Tree.prototype.isShortcutAllowed = function(arg, conditions) {
                return typeof arg === 'object' &&
                    arg !== null &&
                    !Array.isArray(arg) &&
                    Tree.checkConditions(conditions);
              };

              Tree.prototype.match = function() {
                var children = new Array(arguments.length);

                if (!arguments.length)
                  throw new Error('.match() must have argument');

                for (var i = 0; i < arguments.length; i++) {
                  var arg = arguments[i];
                  if (typeof arg === 'function')
                    arg = new CustomMatch(arg);

                  if (!(arg instanceof MatchBase))
                    throw new Error('Wrong .match() argument');

                  children[i] = arg;
                }

                this.queue.push(new Item(this, children));

                return this.boundBody;
              };

              Tree.prototype.applyMode = function(args, mode) {
                if (args.length) {
                  throw new Error('Predicate should not have arguments but ' +
                      JSON.stringify(args) + ' passed');
                }

                return this.mode(mode);
              };

              Tree.prototype.xjstOptions = function(options) {
                this.queue.push(new Item(this, [
                  new CompilerOptions(options),
                ]));
                return this.boundBody;
              };

              ['mode', 'elem', 'block'].forEach(function(method) {
                Tree.prototype[method] = function(name) {
                  return this.match(new PropertyMatch(
                      method === 'mode' ? '_mode' : method, name));
                };
              });

              ['mod', 'elemMod'].forEach(function(method) {
                Tree.prototype[method] = function(name, value) {
                  return this.match(new PropertyMatch([method + 's', name],
                      value === undefined ? true : String(value)));
                };
              });

              Tree.prototype.def = function() {
                return this.applyMode(arguments, 'default');
              };

              [
                'content',
                'mix',
                'bem',
                'js',
                'cls',
                'attrs',
                'tag',
                'elemMods',
                'mods',
              ].forEach(function(method) {
                Tree.prototype[method] = function() {
                  return this.applyMode(arguments, method);
                };
              });

              ['appendContent', 'prependContent'].forEach(function(method) {
                Tree.prototype[method] = function() {
                  return this.content.apply(this, arguments).
                      match(new AddMatch(method, this.refs));
                };
              });

              function capitalize(s) {
                return s[0].toUpperCase() + s.slice(1);
              }

              ['mods', 'elemMods', 'attrs', 'js', 'mix'].forEach(
                  function(method) {
                    Tree.prototype['add' + capitalize(method)] = function() {
                      return this[method].apply(this, arguments).
                          match(new AddMatch(method, this.refs));
                    };
                  });

              Tree.prototype.wrap = function() {
                return this.def.apply(this, arguments).
                    match(new WrapMatch(this.refs));
              };

              Tree.prototype.replace = function() {
                return this.def.apply(this, arguments).
                    match(new ReplaceMatch(this.refs));
              };

              Tree.prototype.extend = function() {
                return this.def.apply(this, arguments).
                    match(new ExtendMatch(this.refs));
              };

              Tree.prototype.oninit = function(fn) {
                this.initializers.push(fn);
              };

            }, {'./utils': 10, 'inherits': 11}],
          10: [
            function(require, module, exports) {
              var amp = '&amp;';
              var lt = '&lt;';
              var gt = '&gt;';
              var quot = '&quot;';
              var singleQuot = '&#39;';

              var matchXmlRegExp = /[&<>]/;

              function isEmpty(string) {
                return typeof string === 'undefined' ||
                    string === null ||
                    (typeof string === 'number' && isNaN(string));
              }

              exports.xmlEscape = function(string) {
                if (isEmpty(string))
                  return '';

                var str = '' + string;
                var match = matchXmlRegExp.exec(str);

                if (!match)
                  return str;

                var escape;
                var html = '';
                var index = 0;
                var lastIndex = 0;

                for (index = match.index; index < str.length; index++) {
                  switch (str.charCodeAt(index)) {
                    case 38: // &
                      escape = amp;
                      break;
                    case 60: // <
                      escape = lt;
                      break;
                    case 62: // >
                      escape = gt;
                      break;
                    default:
                      continue;
                  }

                  if (lastIndex !== index)
                    html += str.substring(lastIndex, index);

                  lastIndex = index + 1;
                  html += escape;
                }

                return lastIndex !== index ?
                    html + str.substring(lastIndex, index) :
                    html;
              };

              var matchAttrRegExp = /["&]/;

              exports.attrEscape = function(string) {
                if (isEmpty(string))
                  return '';

                var str = '' + string;
                var match = matchAttrRegExp.exec(str);

                if (!match)
                  return str;

                var escape;
                var html = '';
                var index = 0;
                var lastIndex = 0;

                for (index = match.index; index < str.length; index++) {
                  switch (str.charCodeAt(index)) {
                    case 34: // "
                      escape = quot;
                      break;
                    case 38: // &
                      escape = amp;
                      break;
                    default:
                      continue;
                  }

                  if (lastIndex !== index)
                    html += str.substring(lastIndex, index);

                  lastIndex = index + 1;
                  html += escape;
                }

                return lastIndex !== index ?
                    html + str.substring(lastIndex, index) :
                    html;
              };

              var matchJsAttrRegExp = /['&]/;

              exports.jsAttrEscape = function(string) {
                if (isEmpty(string))
                  return '';

                var str = '' + string;
                var match = matchJsAttrRegExp.exec(str);

                if (!match)
                  return str;

                var escape;
                var html = '';
                var index = 0;
                var lastIndex = 0;

                for (index = match.index; index < str.length; index++) {
                  switch (str.charCodeAt(index)) {
                    case 38: // &
                      escape = amp;
                      break;
                    case 39: // '
                      escape = singleQuot;
                      break;
                    default:
                      continue;
                  }

                  if (lastIndex !== index)
                    html += str.substring(lastIndex, index);

                  lastIndex = index + 1;
                  html += escape;
                }

                return lastIndex !== index ?
                    html + str.substring(lastIndex, index) :
                    html;
              };

              exports.extend = function(o1, o2) {
                if (!o1 || !o2)
                  return o1 || o2;

                var res = {};
                var n;

                for (n in o1)
                    /* istanbul ignore else */
                  if (o1.hasOwnProperty(n))
                    res[n] = o1[n];
                for (n in o2)
                    /* istanbul ignore else */
                  if (o2.hasOwnProperty(n))
                    res[n] = o2[n];
                return res;
              };

              var SHORT_TAGS = { // hash for quick check if tag short
                area: 1,
                base: 1,
                br: 1,
                col: 1,
                command: 1,
                embed: 1,
                hr: 1,
                img: 1,
                input: 1,
                keygen: 1,
                link: 1,
                meta: 1,
                param: 1,
                source: 1,
                wbr: 1,
              };

              exports.isShortTag = function(t) {
                return SHORT_TAGS.hasOwnProperty(t);
              };

              exports.isSimple = function isSimple(obj) {
                if (!obj || obj === true) return true;
                if (!obj.block &&
                    !obj.elem &&
                    !obj.tag &&
                    !obj.cls &&
                    !obj.attrs &&
                    obj.hasOwnProperty('html') &&
                    isSimple(obj.html))
                  return true;
                return typeof obj === 'string' || typeof obj === 'number';
              };

              exports.isObj = function(val) {
                return val && typeof val === 'object' && !Array.isArray(val) &&
                    val !== null;
              };

              var uniqCount = 0;
              var uniqId = +new Date();
              var uniqExpando = '__' + uniqId;
              var uniqPrefix = 'uniq' + uniqId;

              function getUniq() {
                return uniqPrefix + (++uniqCount);
              }

              exports.getUniq = getUniq;

              exports.identify = function(obj, onlyGet) {
                if (!obj)
                  return getUniq();
                if (onlyGet || obj[uniqExpando])
                  return obj[uniqExpando];

                var u = getUniq();
                obj[uniqExpando] = u;
                return u;
              };

              exports.fnToString = function(code) {
                // It is fine to compile without templates at first
                if (!code)
                  return '';

                if (typeof code === 'function') {
                  // Examples for regular function
                  //   function () { … }
                  //   function name() { … }
                  //   function (a, b) { … }
                  //   function name(a, b) { … }
                  //
                  // Examples for arrow function
                  //   () => { … }
                  //   (a, b) => { … }
                  //   _ => { … }

                  code = code.toString();
                  code = code.replace(
                      code.indexOf('function') === 0 ?
                          /^function\s*[^{]+{|}$/g :
                          /^(_|\(\w|[^=>]+\))\s=>\s{|}$/g,
                      '');
                }

                return code;
              };

              /**
               * regexp for check may attribute be unquoted
               *
               * https://www.w3.org/TR/html4/intro/sgmltut.html#h-3.2.2
               * https://www.w3.org/TR/html5/syntax.html#attributes
               */
              var UNQUOTED_ATTR_REGEXP = /^[:\w.-]+$/;

              exports.isUnquotedAttr = function(str) {
                return str && UNQUOTED_ATTR_REGEXP.exec(str);
              };

            }, {}],
          11: [
            function(require, module, exports) {
              if (typeof Object.create === 'function') {
                // implementation from standard node.js 'util' module
                module.exports = function inherits(ctor, superCtor) {
                  ctor.super_ = superCtor;
                  ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                      value: ctor,
                      enumerable: false,
                      writable: true,
                      configurable: true,
                    },
                  });
                };
              } else {
                // old school shim for old browsers
                module.exports = function inherits(ctor, superCtor) {
                  ctor.super_ = superCtor;
                  var TempCtor = function() {
                  };
                  TempCtor.prototype = superCtor.prototype;
                  ctor.prototype = new TempCtor();
                  ctor.prototype.constructor = ctor;
                };
              }

            }, {}],
        }, {}, [2])(2);
      });
      ;
      return module.exports || exports.BEMHTML;
    }({}, {});
    var api = new BEMHTML({
      'elemJsInstances': true,
      'exportName': 'BEMHTML',
      'sourceMap': {'from': 'estate.browser.bemhtml.js'},
      'to': '/home/mfp/projects/finza.ru/page_layouts',
    });
    api.compile(
        function(match, block, elem, mod, elemMod, oninit, xjstOptions, wrap,
                 replace, extend, mode, def, content, appendContent,
                 prependContent, attrs, addAttrs, js, addJs, mix, addMix, mods,
                 addMods, addElemMods, elemMods, tag, cls, bem, local, applyCtx,
                 applyNext, apply) {
          /* BEM-XJST User code here: */
          /* begin: /home/mfp/projects/finza.ru/page_layouts/node_modules/bem-components/common.blocks/icon/icon.bemhtml.js */
          block('icon')(
              tag()('span'),
              addAttrs()(function() {
                var attrs = {},
                    url = this.ctx.url;
                if (url) attrs.style = 'background-image:url(' + url + ')';
                return attrs;
              }),
          );

          /* end: /home/mfp/projects/finza.ru/page_layouts/node_modules/bem-components/common.blocks/icon/icon.bemhtml.js */

          ;oninit(function(exports, context) {
            var BEMContext = exports.BEMContext || context.BEMContext;
            BEMContext.prototype.require = function(lib) {
              return this._libs[lib];
            };
          });
          ;
        });
    exports = api.exportApply(exports);
    if (libs) exports.BEMContext.prototype._libs = libs;
    return exports;
  };

  var glob = this.window || this.global || this;
  var exp = typeof exports !== 'undefined' ? exports : global;
  if (typeof modules === 'object') {

    modules.define('BEMHTML', [], function(provide) {
      var engine = buildBemXjst({});
      provide(engine);
    });
  } else {
    var _libs = {};

    if (Object.keys(_libs).length) {
      BEMHTML = buildBemXjst(_libs);
      exp['BEMHTML'] = BEMHTML;
      exp['BEMHTML'].libs = _libs;
    } else {
      BEMHTML = buildBemXjst(glob);
      exp['BEMHTML'] = BEMHTML;
      exp['BEMHTML'].libs = glob;
    }
  }
})(typeof window !== 'undefined' ?
    window :
    typeof global !== 'undefined' ? global : this);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVzdGF0ZS5icm93c2VyLmJlbWh0bWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImVzdGF0ZS5icm93c2VyLmJlbWh0bWwuanMifQ==